/*! jQuery v1.7.2 jquery.com | jquery.org/license */
(function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cu(a){if(!cj[a]){var b=c.body,d=f("<"+a+">").appendTo(b),e=d.css("display");d.remove();if(e==="none"||e===""){ck||(ck=c.createElement("iframe"),ck.frameBorder=ck.width=ck.height=0),b.appendChild(ck);if(!cl||!ck.createElement)cl=(ck.contentWindow||ck.contentDocument).document,cl.write((f.support.boxModel?"<!doctype html>":"")+"<html><body>"),cl.close();d=cl.createElement(a),cl.body.appendChild(d),e=f.css(d,"display"),b.removeChild(ck)}cj[a]=e}return cj[a]}function ct(a,b){var c={};f.each(cp.concat.apply([],cp.slice(0,b)),function(){c[this]=a});return c}function cs(){cq=b}function cr(){setTimeout(cs,0);return cq=f.now()}function ci(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}function ch(){try{return new a.XMLHttpRequest}catch(b){}}function cb(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g<i;g++){if(g===1)for(h in a.converters)typeof h=="string"&&(e[h.toLowerCase()]=a.converters[h]);l=k,k=d[g];if(k==="*")k=l;else if(l!=="*"&&l!==k){m=l+" "+k,n=e[m]||e["* "+k];if(!n){p=b;for(o in e){j=o.split(" ");if(j[0]===l||j[0]==="*"){p=e[j[1]+" "+k];if(p){o=e[o],o===!0?n=p:p===!0&&(n=o);break}}}}!n&&!p&&f.error("No conversion from "+m.replace(" "," to ")),n!==!0&&(c=n?n(c):p(o(c)))}}return c}function ca(a,c,d){var e=a.contents,f=a.dataTypes,g=a.responseFields,h,i,j,k;for(i in g)i in d&&(c[g[i]]=d[i]);while(f[0]==="*")f.shift(),h===b&&(h=a.mimeType||c.getResponseHeader("content-type"));if(h)for(i in e)if(e[i]&&e[i].test(h)){f.unshift(i);break}if(f[0]in d)j=f[0];else{for(i in d){if(!f[0]||a.converters[i+" "+f[0]]){j=i;break}k||(k=i)}j=j||k}if(j){j!==f[0]&&f.unshift(j);return d[j]}}function b_(a,b,c,d){if(f.isArray(b))f.each(b,function(b,e){c||bD.test(a)?d(a,e):b_(a+"["+(typeof e=="object"?b:"")+"]",e,c,d)});else if(!c&&f.type(b)==="object")for(var e in b)b_(a+"["+e+"]",b[e],c,d);else d(a,b)}function b$(a,c){var d,e,g=f.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((g[d]?a:e||(e={}))[d]=c[d]);e&&f.extend(!0,a,e)}function bZ(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h=a[f],i=0,j=h?h.length:0,k=a===bS,l;for(;i<j&&(k||!l);i++)l=h[i](c,d,e),typeof l=="string"&&(!k||g[l]?l=b:(c.dataTypes.unshift(l),l=bZ(a,c,d,e,l,g)));(k||!l)&&!g["*"]&&(l=bZ(a,c,d,e,"*",g));return l}function bY(a){return function(b,c){typeof b!="string"&&(c=b,b="*");if(f.isFunction(c)){var d=b.toLowerCase().split(bO),e=0,g=d.length,h,i,j;for(;e<g;e++)h=d[e],j=/^\+/.test(h),j&&(h=h.substr(1)||"*"),i=a[h]=a[h]||[],i[j?"unshift":"push"](c)}}}function bB(a,b,c){var d=b==="width"?a.offsetWidth:a.offsetHeight,e=b==="width"?1:0,g=4;if(d>0){if(c!=="border")for(;e<g;e+=2)c||(d-=parseFloat(f.css(a,"padding"+bx[e]))||0),c==="margin"?d+=parseFloat(f.css(a,c+bx[e]))||0:d-=parseFloat(f.css(a,"border"+bx[e]+"Width"))||0;return d+"px"}d=by(a,b);if(d<0||d==null)d=a.style[b];if(bt.test(d))return d;d=parseFloat(d)||0;if(c)for(;e<g;e+=2)d+=parseFloat(f.css(a,"padding"+bx[e]))||0,c!=="padding"&&(d+=parseFloat(f.css(a,"border"+bx[e]+"Width"))||0),c==="margin"&&(d+=parseFloat(f.css(a,c+bx[e]))||0);return d+"px"}function bo(a){var b=c.createElement("div");bh.appendChild(b),b.innerHTML=a.outerHTML;return b.firstChild}function bn(a){var b=(a.nodeName||"").toLowerCase();b==="input"?bm(a):b!=="script"&&typeof a.getElementsByTagName!="undefined"&&f.grep(a.getElementsByTagName("input"),bm)}function bm(a){if(a.type==="checkbox"||a.type==="radio")a.defaultChecked=a.checked}function bl(a){return typeof a.getElementsByTagName!="undefined"?a.getElementsByTagName("*"):typeof a.querySelectorAll!="undefined"?a.querySelectorAll("*"):[]}function bk(a,b){var c;b.nodeType===1&&(b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase(),c==="object"?b.outerHTML=a.outerHTML:c!=="input"||a.type!=="checkbox"&&a.type!=="radio"?c==="option"?b.selected=a.defaultSelected:c==="input"||c==="textarea"?b.defaultValue=a.defaultValue:c==="script"&&b.text!==a.text&&(b.text=a.text):(a.checked&&(b.defaultChecked=b.checked=a.checked),b.value!==a.value&&(b.value=a.value)),b.removeAttribute(f.expando),b.removeAttribute("_submit_attached"),b.removeAttribute("_change_attached"))}function bj(a,b){if(b.nodeType===1&&!!f.hasData(a)){var c,d,e,g=f._data(a),h=f._data(b,g),i=g.events;if(i){delete h.handle,h.events={};for(c in i)for(d=0,e=i[c].length;d<e;d++)f.event.add(b,c,i[c][d])}h.data&&(h.data=f.extend({},h.data))}}function bi(a,b){return f.nodeName(a,"table")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function U(a){var b=V.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function T(a,b,c){b=b||0;if(f.isFunction(b))return f.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return f.grep(a,function(a,d){return a===b===c});if(typeof b=="string"){var d=f.grep(a,function(a){return a.nodeType===1});if(O.test(b))return f.filter(b,d,!c);b=f.filter(b,d)}return f.grep(a,function(a,d){return f.inArray(a,b)>=0===c})}function S(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function K(){return!0}function J(){return!1}function n(a,b,c){var d=b+"defer",e=b+"queue",g=b+"mark",h=f._data(a,d);h&&(c==="queue"||!f._data(a,e))&&(c==="mark"||!f._data(a,g))&&setTimeout(function(){!f._data(a,e)&&!f._data(a,g)&&(f.removeData(a,d,!0),h.fire())},0)}function m(a){for(var b in a){if(b==="data"&&f.isEmptyObject(a[b]))continue;if(b!=="toJSON")return!1}return!0}function l(a,c,d){if(d===b&&a.nodeType===1){var e="data-"+c.replace(k,"-$1").toLowerCase();d=a.getAttribute(e);if(typeof d=="string"){try{d=d==="true"?!0:d==="false"?!1:d==="null"?null:f.isNumeric(d)?+d:j.test(d)?f.parseJSON(d):d}catch(g){}f.data(a,c,d)}else d=b}return d}function h(a){var b=g[a]={},c,d;a=a.split(/\s+/);for(c=0,d=a.length;c<d;c++)b[a[c]]=!0;return b}var c=a.document,d=a.navigator,e=a.location,f=function(){function J(){if(!e.isReady){try{c.documentElement.doScroll("left")}catch(a){setTimeout(J,1);return}e.ready()}}var e=function(a,b){return new e.fn.init(a,b,h)},f=a.jQuery,g=a.$,h,i=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,j=/\S/,k=/^\s+/,l=/\s+$/,m=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,n=/^[\],:{}\s]*$/,o=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,p=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,q=/(?:^|:|,)(?:\s*\[)+/g,r=/(webkit)[ \/]([\w.]+)/,s=/(opera)(?:.*version)?[ \/]([\w.]+)/,t=/(msie) ([\w.]+)/,u=/(mozilla)(?:.*? rv:([\w.]+))?/,v=/-([a-z]|[0-9])/ig,w=/^-ms-/,x=function(a,b){return(b+"").toUpperCase()},y=d.userAgent,z,A,B,C=Object.prototype.toString,D=Object.prototype.hasOwnProperty,E=Array.prototype.push,F=Array.prototype.slice,G=String.prototype.trim,H=Array.prototype.indexOf,I={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a==="body"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a=="string"){a.charAt(0)!=="<"||a.charAt(a.length-1)!==">"||a.length<3?g=i.exec(a):g=[null,a,null];if(g&&(g[1]||!d)){if(g[1]){d=d instanceof e?d[0]:d,k=d?d.ownerDocument||d:c,j=m.exec(a),j?e.isPlainObject(d)?(a=[c.createElement(j[1])],e.fn.attr.call(a,d,!0)):a=[k.createElement(j[1])]:(j=e.buildFragment([g[1]],[k]),a=(j.cacheable?e.clone(j.fragment):j.fragment).childNodes);return e.merge(this,a)}h=c.getElementById(g[2]);if(h&&h.parentNode){if(h.id!==g[2])return f.find(a);this.length=1,this[0]=h}this.context=c,this.selector=a;return this}return!d||d.jquery?(d||f).find(a):this.constructor(d).find(a)}if(e.isFunction(a))return f.ready(a);a.selector!==b&&(this.selector=a.selector,this.context=a.context);return e.makeArray(a,this)},selector:"",jquery:"1.7.2",length:0,size:function(){return this.length},toArray:function(){return F.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=this.constructor();e.isArray(a)?E.apply(d,a):e.merge(d,a),d.prevObject=this,d.context=this.context,b==="find"?d.selector=this.selector+(this.selector?" ":"")+c:b&&(d.selector=this.selector+"."+b+"("+c+")");return d},each:function(a,b){return e.each(this,a,b)},ready:function(a){e.bindReady(),A.add(a);return this},eq:function(a){a=+a;return a===-1?this.slice(a):this.slice(a,a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(F.apply(this,arguments),"slice",F.call(arguments).join(","))},map:function(a){return this.pushStack(e.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:E,sort:[].sort,splice:[].splice},e.fn.init.prototype=e.fn,e.extend=e.fn.extend=function(){var a,c,d,f,g,h,i=arguments[0]||{},j=1,k=arguments.length,l=!1;typeof i=="boolean"&&(l=i,i=arguments[1]||{},j=2),typeof i!="object"&&!e.isFunction(i)&&(i={}),k===j&&(i=this,--j);for(;j<k;j++)if((a=arguments[j])!=null)for(c in a){d=i[c],f=a[c];if(i===f)continue;l&&f&&(e.isPlainObject(f)||(g=e.isArray(f)))?(g?(g=!1,h=d&&e.isArray(d)?d:[]):h=d&&e.isPlainObject(d)?d:{},i[c]=e.extend(l,h,f)):f!==b&&(i[c]=f)}return i},e.extend({noConflict:function(b){a.$===e&&(a.$=g),b&&a.jQuery===e&&(a.jQuery=f);return e},isReady:!1,readyWait:1,holdReady:function(a){a?e.readyWait++:e.ready(!0)},ready:function(a){if(a===!0&&!--e.readyWait||a!==!0&&!e.isReady){if(!c.body)return setTimeout(e.ready,1);e.isReady=!0;if(a!==!0&&--e.readyWait>0)return;A.fireWith(c,[e]),e.fn.trigger&&e(c).trigger("ready").off("ready")}},bindReady:function(){if(!A){A=e.Callbacks("once memory");if(c.readyState==="complete")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener("DOMContentLoaded",B,!1),a.addEventListener("load",e.ready,!1);else if(c.attachEvent){c.attachEvent("onreadystatechange",B),a.attachEvent("onload",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&J()}}},isFunction:function(a){return e.type(a)==="function"},isArray:Array.isArray||function(a){return e.type(a)==="array"},isWindow:function(a){return a!=null&&a==a.window},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):I[C.call(a)]||"object"},isPlainObject:function(a){if(!a||e.type(a)!=="object"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!D.call(a,"constructor")&&!D.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}var d;for(d in a);return d===b||D.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw new Error(a)},parseJSON:function(b){if(typeof b!="string"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(n.test(b.replace(o,"@").replace(p,"]").replace(q,"")))return(new Function("return "+b))();e.error("Invalid JSON: "+b)},parseXML:function(c){if(typeof c!="string"||!c)return null;var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,"text/xml")):(d=new ActiveXObject("Microsoft.XMLDOM"),d.async="false",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName("parsererror").length)&&e.error("Invalid XML: "+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(w,"ms-").replace(v,x)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g<h;)if(c.apply(a[g++],d)===!1)break}else if(i){for(f in a)if(c.call(a[f],f,a[f])===!1)break}else for(;g<h;)if(c.call(a[g],g,a[g++])===!1)break;return a},trim:G?function(a){return a==null?"":G.call(a)}:function(a){return a==null?"":(a+"").replace(k,"").replace(l,"")},makeArray:function(a,b){var c=b||[];if(a!=null){var d=e.type(a);a.length==null||d==="string"||d==="function"||d==="regexp"||e.isWindow(a)?E.call(c,a):e.merge(c,a)}return c},inArray:function(a,b,c){var d;if(b){if(H)return H.call(b,a,c);d=b.length,c=c?c<0?Math.max(0,d+c):c:0;for(;c<d;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,c){var d=a.length,e=0;if(typeof c.length=="number")for(var f=c.length;e<f;e++)a[d++]=c[e];else while(c[e]!==b)a[d++]=c[e++];a.length=d;return a},grep:function(a,b,c){var d=[],e;c=!!c;for(var f=0,g=a.length;f<g;f++)e=!!b(a[f],f),c!==e&&d.push(a[f]);return d},map:function(a,c,d){var f,g,h=[],i=0,j=a.length,k=a instanceof e||j!==b&&typeof j=="number"&&(j>0&&a[0]&&a[j-1]||j===0||e.isArray(a));if(k)for(;i<j;i++)f=c(a[i],i,d),f!=null&&(h[h.length]=f);else for(g in a)f=c(a[g],g,d),f!=null&&(h[h.length]=f);return h.concat.apply([],h)},guid:1,proxy:function(a,c){if(typeof c=="string"){var d=a[c];c=a,a=d}if(!e.isFunction(a))return b;var f=F.call(arguments,2),g=function(){return a.apply(c,f.concat(F.call(arguments)))};g.guid=a.guid=a.guid||g.guid||e.guid++;return g},access:function(a,c,d,f,g,h,i){var j,k=d==null,l=0,m=a.length;if(d&&typeof d=="object"){for(l in d)e.access(a,c,l,d[l],1,h,f);g=1}else if(f!==b){j=i===b&&e.isFunction(f),k&&(j?(j=c,c=function(a,b,c){return j.call(e(a),c)}):(c.call(a,f),c=null));if(c)for(;l<m;l++)c(a[l],d,j?f.call(a[l],l,c(a[l],d)):f,i);g=1}return g?a:k?c.call(a):m?c(a[0],d):h},now:function(){return(new Date).getTime()},uaMatch:function(a){a=a.toLowerCase();var b=r.exec(a)||s.exec(a)||t.exec(a)||a.indexOf("compatible")<0&&u.exec(a)||[];return{browser:b[1]||"",version:b[2]||"0"}},sub:function(){function a(b,c){return new a.fn.init(b,c)}e.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function(d,f){f&&f instanceof e&&!(f instanceof a)&&(f=a(f));return e.fn.init.call(this,d,f,b)},a.fn.init.prototype=a.fn;var b=a(c);return a},browser:{}}),e.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(a,b){I["[object "+b+"]"]=b.toLowerCase()}),z=e.uaMatch(y),z.browser&&(e.browser[z.browser]=!0,e.browser.version=z.version),e.browser.webkit&&(e.browser.safari=!0),j.test(" ")&&(k=/^[\s\xA0]+/,l=/[\s\xA0]+$/),h=e(c),c.addEventListener?B=function(){c.removeEventListener("DOMContentLoaded",B,!1),e.ready()}:c.attachEvent&&(B=function(){c.readyState==="complete"&&(c.detachEvent("onreadystatechange",B),e.ready())});return e}(),g={};f.Callbacks=function(a){a=a?g[a]||h(a):{};var c=[],d=[],e,i,j,k,l,m,n=function(b){var d,e,g,h,i;for(d=0,e=b.length;d<e;d++)g=b[d],h=f.type(g),h==="array"?n(g):h==="function"&&(!a.unique||!p.has(g))&&c.push(g)},o=function(b,f){f=f||[],e=!a.memory||[b,f],i=!0,j=!0,m=k||0,k=0,l=c.length;for(;c&&m<l;m++)if(c[m].apply(b,f)===!1&&a.stopOnFalse){e=!0;break}j=!1,c&&(a.once?e===!0?p.disable():c=[]:d&&d.length&&(e=d.shift(),p.fireWith(e[0],e[1])))},p={add:function(){if(c){var a=c.length;n(arguments),j?l=c.length:e&&e!==!0&&(k=a,o(e[0],e[1]))}return this},remove:function(){if(c){var b=arguments,d=0,e=b.length;for(;d<e;d++)for(var f=0;f<c.length;f++)if(b[d]===c[f]){j&&f<=l&&(l--,f<=m&&m--),c.splice(f--,1);if(a.unique)break}}return this},has:function(a){if(c){var b=0,d=c.length;for(;b<d;b++)if(a===c[b])return!0}return!1},empty:function(){c=[];return this},disable:function(){c=d=e=b;return this},disabled:function(){return!c},lock:function(){d=b,(!e||e===!0)&&p.disable();return this},locked:function(){return!d},fireWith:function(b,c){d&&(j?a.once||d.push([b,c]):(!a.once||!e)&&o(b,c));return this},fire:function(){p.fireWith(this,arguments);return this},fired:function(){return!!i}};return p};var i=[].slice;f.extend({Deferred:function(a){var b=f.Callbacks("once memory"),c=f.Callbacks("once memory"),d=f.Callbacks("memory"),e="pending",g={resolve:b,reject:c,notify:d},h={done:b.add,fail:c.add,progress:d.add,state:function(){return e},isResolved:b.fired,isRejected:c.fired,then:function(a,b,c){i.done(a).fail(b).progress(c);return this},always:function(){i.done.apply(i,arguments).fail.apply(i,arguments);return this},pipe:function(a,b,c){return f.Deferred(function(d){f.each({done:[a,"resolve"],fail:[b,"reject"],progress:[c,"notify"]},function(a,b){var c=b[0],e=b[1],g;f.isFunction(c)?i[a](function(){g=c.apply(this,arguments),g&&f.isFunction(g.promise)?g.promise().then(d.resolve,d.reject,d.notify):d[e+"With"](this===i?d:this,[g])}):i[a](d[e])})}).promise()},promise:function(a){if(a==null)a=h;else for(var b in h)a[b]=h[b];return a}},i=h.promise({}),j;for(j in g)i[j]=g[j].fire,i[j+"With"]=g[j].fireWith;i.done(function(){e="resolved"},c.disable,d.lock).fail(function(){e="rejected"},b.disable,d.lock),a&&a.call(i,i);return i},when:function(a){function m(a){return function(b){e[a]=arguments.length>1?i.call(arguments,0):b,j.notifyWith(k,e)}}function l(a){return function(c){b[a]=arguments.length>1?i.call(arguments,0):c,--g||j.resolveWith(j,b)}}var b=i.call(arguments,0),c=0,d=b.length,e=Array(d),g=d,h=d,j=d<=1&&a&&f.isFunction(a.promise)?a:f.Deferred(),k=j.promise();if(d>1){for(;c<d;c++)b[c]&&b[c].promise&&f.isFunction(b[c].promise)?b[c].promise().then(l(c),j.reject,m(c)):--g;g||j.resolveWith(j,b)}else j!==a&&j.resolveWith(j,d?[a]:[]);return k}}),f.support=function(){var b,d,e,g,h,i,j,k,l,m,n,o,p=c.createElement("div"),q=c.documentElement;p.setAttribute("className","t"),p.innerHTML="   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>",d=p.getElementsByTagName("*"),e=p.getElementsByTagName("a")[0];if(!d||!d.length||!e)return{};g=c.createElement("select"),h=g.appendChild(c.createElement("option")),i=p.getElementsByTagName("input")[0],b={leadingWhitespace:p.firstChild.nodeType===3,tbody:!p.getElementsByTagName("tbody").length,htmlSerialize:!!p.getElementsByTagName("link").length,style:/top/.test(e.getAttribute("style")),hrefNormalized:e.getAttribute("href")==="/a",opacity:/^0.55/.test(e.style.opacity),cssFloat:!!e.style.cssFloat,checkOn:i.value==="on",optSelected:h.selected,getSetAttribute:p.className!=="t",enctype:!!c.createElement("form").enctype,html5Clone:c.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,pixelMargin:!0},f.boxModel=b.boxModel=c.compatMode==="CSS1Compat",i.checked=!0,b.noCloneChecked=i.cloneNode(!0).checked,g.disabled=!0,b.optDisabled=!h.disabled;try{delete p.test}catch(r){b.deleteExpando=!1}!p.addEventListener&&p.attachEvent&&p.fireEvent&&(p.attachEvent("onclick",function(){b.noCloneEvent=!1}),p.cloneNode(!0).fireEvent("onclick")),i=c.createElement("input"),i.value="t",i.setAttribute("type","radio"),b.radioValue=i.value==="t",i.setAttribute("checked","checked"),i.setAttribute("name","t"),p.appendChild(i),j=c.createDocumentFragment(),j.appendChild(p.lastChild),b.checkClone=j.cloneNode(!0).cloneNode(!0).lastChild.checked,b.appendChecked=i.checked,j.removeChild(i),j.appendChild(p);if(p.attachEvent)for(n in{submit:1,change:1,focusin:1})m="on"+n,o=m in p,o||(p.setAttribute(m,"return;"),o=typeof p[m]=="function"),b[n+"Bubbles"]=o;j.removeChild(p),j=g=h=p=i=null,f(function(){var d,e,g,h,i,j,l,m,n,q,r,s,t,u=c.getElementsByTagName("body")[0];!u||(m=1,t="padding:0;margin:0;border:",r="position:absolute;top:0;left:0;width:1px;height:1px;",s=t+"0;visibility:hidden;",n="style='"+r+t+"5px solid #000;",q="<div "+n+"display:block;'><div style='"+t+"0;display:block;overflow:hidden;'></div></div>"+"<table "+n+"' cellpadding='0' cellspacing='0'>"+"<tr><td></td></tr></table>",d=c.createElement("div"),d.style.cssText=s+"width:0;height:0;position:static;top:0;margin-top:"+m+"px",u.insertBefore(d,u.firstChild),p=c.createElement("div"),d.appendChild(p),p.innerHTML="<table><tr><td style='"+t+"0;display:none'></td><td>t</td></tr></table>",k=p.getElementsByTagName("td"),o=k[0].offsetHeight===0,k[0].style.display="",k[1].style.display="none",b.reliableHiddenOffsets=o&&k[0].offsetHeight===0,a.getComputedStyle&&(p.innerHTML="",l=c.createElement("div"),l.style.width="0",l.style.marginRight="0",p.style.width="2px",p.appendChild(l),b.reliableMarginRight=(parseInt((a.getComputedStyle(l,null)||{marginRight:0}).marginRight,10)||0)===0),typeof p.style.zoom!="undefined"&&(p.innerHTML="",p.style.width=p.style.padding="1px",p.style.border=0,p.style.overflow="hidden",p.style.display="inline",p.style.zoom=1,b.inlineBlockNeedsLayout=p.offsetWidth===3,p.style.display="block",p.style.overflow="visible",p.innerHTML="<div style='width:5px;'></div>",b.shrinkWrapBlocks=p.offsetWidth!==3),p.style.cssText=r+s,p.innerHTML=q,e=p.firstChild,g=e.firstChild,i=e.nextSibling.firstChild.firstChild,j={doesNotAddBorder:g.offsetTop!==5,doesAddBorderForTableAndCells:i.offsetTop===5},g.style.position="fixed",g.style.top="20px",j.fixedPosition=g.offsetTop===20||g.offsetTop===15,g.style.position=g.style.top="",e.style.overflow="hidden",e.style.position="relative",j.subtractsBorderForOverflowNotVisible=g.offsetTop===-5,j.doesNotIncludeMarginInBodyOffset=u.offsetTop!==m,a.getComputedStyle&&(p.style.marginTop="1%",b.pixelMargin=(a.getComputedStyle(p,null)||{marginTop:0}).marginTop!=="1%"),typeof d.style.zoom!="undefined"&&(d.style.zoom=1),u.removeChild(d),l=p=d=null,f.extend(b,j))});return b}();var j=/^(?:\{.*\}|\[.*\])$/,k=/([A-Z])/g;f.extend({cache:{},uuid:0,expando:"jQuery"+(f.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(a){a=a.nodeType?f.cache[a[f.expando]]:a[f.expando];return!!a&&!m(a)},data:function(a,c,d,e){if(!!f.acceptData(a)){var g,h,i,j=f.expando,k=typeof c=="string",l=a.nodeType,m=l?f.cache:a,n=l?a[j]:a[j]&&j,o=c==="events";if((!n||!m[n]||!o&&!e&&!m[n].data)&&k&&d===b)return;n||(l?a[j]=n=++f.uuid:n=j),m[n]||(m[n]={},l||(m[n].toJSON=f.noop));if(typeof c=="object"||typeof c=="function")e?m[n]=f.extend(m[n],c):m[n].data=f.extend(m[n].data,c);g=h=m[n],e||(h.data||(h.data={}),h=h.data),d!==b&&(h[f.camelCase(c)]=d);if(o&&!h[c])return g.events;k?(i=h[c],i==null&&(i=h[f.camelCase(c)])):i=h;return i}},removeData:function(a,b,c){if(!!f.acceptData(a)){var d,e,g,h=f.expando,i=a.nodeType,j=i?f.cache:a,k=i?a[h]:h;if(!j[k])return;if(b){d=c?j[k]:j[k].data;if(d){f.isArray(b)||(b in d?b=[b]:(b=f.camelCase(b),b in d?b=[b]:b=b.split(" ")));for(e=0,g=b.length;e<g;e++)delete d[b[e]];if(!(c?m:f.isEmptyObject)(d))return}}if(!c){delete j[k].data;if(!m(j[k]))return}f.support.deleteExpando||!j.setInterval?delete j[k]:j[k]=null,i&&(f.support.deleteExpando?delete a[h]:a.removeAttribute?a.removeAttribute(h):a[h]=null)}},_data:function(a,b,c){return f.data(a,b,c,!0)},acceptData:function(a){if(a.nodeName){var b=f.noData[a.nodeName.toLowerCase()];if(b)return b!==!0&&a.getAttribute("classid")===b}return!0}}),f.fn.extend({data:function(a,c){var d,e,g,h,i,j=this[0],k=0,m=null;if(a===b){if(this.length){m=f.data(j);if(j.nodeType===1&&!f._data(j,"parsedAttrs")){g=j.attributes;for(i=g.length;k<i;k++)h=g[k].name,h.indexOf("data-")===0&&(h=f.camelCase(h.substring(5)),l(j,h,m[h]));f._data(j,"parsedAttrs",!0)}}return m}if(typeof a=="object")return this.each(function(){f.data(this,a)});d=a.split(".",2),d[1]=d[1]?"."+d[1]:"",e=d[1]+"!";return f.access(this,function(c){if(c===b){m=this.triggerHandler("getData"+e,[d[0]]),m===b&&j&&(m=f.data(j,a),m=l(j,a,m));return m===b&&d[1]?this.data(d[0]):m}d[1]=c,this.each(function(){var b=f(this);b.triggerHandler("setData"+e,d),f.data(this,a,c),b.triggerHandler("changeData"+e,d)})},null,c,arguments.length>1,null,!1)},removeData:function(a){return this.each(function(){f.removeData(this,a)})}}),f.extend({_mark:function(a,b){a&&(b=(b||"fx")+"mark",f._data(a,b,(f._data(a,b)||0)+1))},_unmark:function(a,b,c){a!==!0&&(c=b,b=a,a=!1);if(b){c=c||"fx";var d=c+"mark",e=a?0:(f._data(b,d)||1)-1;e?f._data(b,d,e):(f.removeData(b,d,!0),n(b,c,"mark"))}},queue:function(a,b,c){var d;if(a){b=(b||"fx")+"queue",d=f._data(a,b),c&&(!d||f.isArray(c)?d=f._data(a,b,f.makeArray(c)):d.push(c));return d||[]}},dequeue:function(a,b){b=b||"fx";var c=f.queue(a,b),d=c.shift(),e={};d==="inprogress"&&(d=c.shift()),d&&(b==="fx"&&c.unshift("inprogress"),f._data(a,b+".run",e),d.call(a,function(){f.dequeue(a,b)},e)),c.length||(f.removeData(a,b+"queue "+b+".run",!0),n(a,b,"queue"))}}),f.fn.extend({queue:function(a,c){var d=2;typeof a!="string"&&(c=a,a="fx",d--);if(arguments.length<d)return f.queue(this[0],a);return c===b?this:this.each(function(){var b=f.queue(this,a,c);a==="fx"&&b[0]!=="inprogress"&&f.dequeue(this,a)})},dequeue:function(a){return this.each(function(){f.dequeue(this,a)})},delay:function(a,b){a=f.fx?f.fx.speeds[a]||a:a,b=b||"fx";return this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,c){function m(){--h||d.resolveWith(e,[e])}typeof a!="string"&&(c=a,a=b),a=a||"fx";var d=f.Deferred(),e=this,g=e.length,h=1,i=a+"defer",j=a+"queue",k=a+"mark",l;while(g--)if(l=f.data(e[g],i,b,!0)||(f.data(e[g],j,b,!0)||f.data(e[g],k,b,!0))&&f.data(e[g],i,f.Callbacks("once memory"),!0))h++,l.add(m);m();return d.promise(c)}});var o=/[\n\t\r]/g,p=/\s+/,q=/\r/g,r=/^(?:button|input)$/i,s=/^(?:button|input|object|select|textarea)$/i,t=/^a(?:rea)?$/i,u=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,v=f.support.getSetAttribute,w,x,y;f.fn.extend({attr:function(a,b){return f.access(this,f.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){f.removeAttr(this,a)})},prop:function(a,b){return f.access(this,f.prop,a,b,arguments.length>1)},removeProp:function(a){a=f.propFix[a]||a;return this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,g,h,i;if(f.isFunction(a))return this.each(function(b){f(this).addClass(a.call(this,b,this.className))});if(a&&typeof a=="string"){b=a.split(p);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{g=" "+e.className+" ";for(h=0,i=b.length;h<i;h++)~g.indexOf(" "+b[h]+" ")||(g+=b[h]+" ");e.className=f.trim(g)}}}return this},removeClass:function(a){var c,d,e,g,h,i,j;if(f.isFunction(a))return this.each(function(b){f(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a=="string"||a===b){c=(a||"").split(p);for(d=0,e=this.length;d<e;d++){g=this[d];if(g.nodeType===1&&g.className)if(a){h=(" "+g.className+" ").replace(o," ");for(i=0,j=c.length;i<j;i++)h=h.replace(" "+c[i]+" "," ");g.className=f.trim(h)}else g.className=""}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b=="boolean";if(f.isFunction(a))return this.each(function(c){f(this).toggleClass(a.call(this,c,this.className,b),b)});return this.each(function(){if(c==="string"){var e,g=0,h=f(this),i=b,j=a.split(p);while(e=j[g++])i=d?i:!h.hasClass(e),h[i?"addClass":"removeClass"](e)}else if(c==="undefined"||c==="boolean")this.className&&f._data(this,"__className__",this.className),this.className=this.className||a===!1?"":f._data(this,"__className__")||""})},hasClass:function(a){var b=" "+a+" ",c=0,d=this.length;for(;c<d;c++)if(this[c].nodeType===1&&(" "+this[c].className+" ").replace(o," ").indexOf(b)>-1)return!0;return!1},val:function(a){var c,d,e,g=this[0];{if(!!arguments.length){e=f.isFunction(a);return this.each(function(d){var g=f(this),h;if(this.nodeType===1){e?h=a.call(this,d,g.val()):h=a,h==null?h="":typeof h=="number"?h+="":f.isArray(h)&&(h=f.map(h,function(a){return a==null?"":a+""})),c=f.valHooks[this.type]||f.valHooks[this.nodeName.toLowerCase()];if(!c||!("set"in c)||c.set(this,h,"value")===b)this.value=h}})}if(g){c=f.valHooks[g.type]||f.valHooks[g.nodeName.toLowerCase()];if(c&&"get"in c&&(d=c.get(g,"value"))!==b)return d;d=g.value;return typeof d=="string"?d.replace(q,""):d==null?"":d}}}}),f.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c,d,e,g=a.selectedIndex,h=[],i=a.options,j=a.type==="select-one";if(g<0)return null;c=j?g:0,d=j?g+1:i.length;for(;c<d;c++){e=i[c];if(e.selected&&(f.support.optDisabled?!e.disabled:e.getAttribute("disabled")===null)&&(!e.parentNode.disabled||!f.nodeName(e.parentNode,"optgroup"))){b=f(e).val();if(j)return b;h.push(b)}}if(j&&!h.length&&i.length)return f(i[g]).val();return h},set:function(a,b){var c=f.makeArray(b);f(a).find("option").each(function(){this.selected=f.inArray(f(this).val(),c)>=0}),c.length||(a.selectedIndex=-1);return c}}},attrFn:{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0},attr:function(a,c,d,e){var g,h,i,j=a.nodeType;if(!!a&&j!==3&&j!==8&&j!==2){if(e&&c in f.attrFn)return f(a)[c](d);if(typeof a.getAttribute=="undefined")return f.prop(a,c,d);i=j!==1||!f.isXMLDoc(a),i&&(c=c.toLowerCase(),h=f.attrHooks[c]||(u.test(c)?x:w));if(d!==b){if(d===null){f.removeAttr(a,c);return}if(h&&"set"in h&&i&&(g=h.set(a,d,c))!==b)return g;a.setAttribute(c,""+d);return d}if(h&&"get"in h&&i&&(g=h.get(a,c))!==null)return g;g=a.getAttribute(c);return g===null?b:g}},removeAttr:function(a,b){var c,d,e,g,h,i=0;if(b&&a.nodeType===1){d=b.toLowerCase().split(p),g=d.length;for(;i<g;i++)e=d[i],e&&(c=f.propFix[e]||e,h=u.test(e),h||f.attr(a,e,""),a.removeAttribute(v?e:c),h&&c in a&&(a[c]=!1))}},attrHooks:{type:{set:function(a,b){if(r.test(a.nodeName)&&a.parentNode)f.error("type property can't be changed");else if(!f.support.radioValue&&b==="radio"&&f.nodeName(a,"input")){var c=a.value;a.setAttribute("type",b),c&&(a.value=c);return b}}},value:{get:function(a,b){if(w&&f.nodeName(a,"button"))return w.get(a,b);return b in a?a.value:null},set:function(a,b,c){if(w&&f.nodeName(a,"button"))return w.set(a,b,c);a.value=b}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(a,c,d){var e,g,h,i=a.nodeType;if(!!a&&i!==3&&i!==8&&i!==2){h=i!==1||!f.isXMLDoc(a),h&&(c=f.propFix[c]||c,g=f.propHooks[c]);return d!==b?g&&"set"in g&&(e=g.set(a,d,c))!==b?e:a[c]=d:g&&"get"in g&&(e=g.get(a,c))!==null?e:a[c]}},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode("tabindex");return c&&c.specified?parseInt(c.value,10):s.test(a.nodeName)||t.test(a.nodeName)&&a.href?0:b}}}}),f.attrHooks.tabindex=f.propHooks.tabIndex,x={get:function(a,c){var d,e=f.prop(a,c);return e===!0||typeof e!="boolean"&&(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;b===!1?f.removeAttr(a,c):(d=f.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase()));return c}},v||(y={name:!0,id:!0,coords:!0},w=f.valHooks.button={get:function(a,c){var d;d=a.getAttributeNode(c);return d&&(y[c]?d.nodeValue!=="":d.specified)?d.nodeValue:b},set:function(a,b,d){var e=a.getAttributeNode(d);e||(e=c.createAttribute(d),a.setAttributeNode(e));return e.nodeValue=b+""}},f.attrHooks.tabindex.set=w.set,f.each(["width","height"],function(a,b){f.attrHooks[b]=f.extend(f.attrHooks[b],{set:function(a,c){if(c===""){a.setAttribute(b,"auto");return c}}})}),f.attrHooks.contenteditable={get:w.get,set:function(a,b,c){b===""&&(b="false"),w.set(a,b,c)}}),f.support.hrefNormalized||f.each(["href","src","width","height"],function(a,c){f.attrHooks[c]=f.extend(f.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),f.support.style||(f.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=""+b}}),f.support.optSelected||(f.propHooks.selected=f.extend(f.propHooks.selected,{get:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex);return null}})),f.support.enctype||(f.propFix.enctype="encoding"),f.support.checkOn||f.each(["radio","checkbox"],function(){f.valHooks[this]={get:function(a){return a.getAttribute("value")===null?"on":a.value}}}),f.each(["radio","checkbox"],function(){f.valHooks[this]=f.extend(f.valHooks[this],{set:function(a,b){if(f.isArray(b))return a.checked=f.inArray(f(a).val(),b)>=0}})});var z=/^(?:textarea|input|select)$/i,A=/^([^\.]*)?(?:\.(.+))?$/,B=/(?:^|\s)hover(\.\S+)?\b/,C=/^key/,D=/^(?:mouse|contextmenu)|click/,E=/^(?:focusinfocus|focusoutblur)$/,F=/^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,G=function(
a){var b=F.exec(a);b&&(b[1]=(b[1]||"").toLowerCase(),b[3]=b[3]&&new RegExp("(?:^|\\s)"+b[3]+"(?:\\s|$)"));return b},H=function(a,b){var c=a.attributes||{};return(!b[1]||a.nodeName.toLowerCase()===b[1])&&(!b[2]||(c.id||{}).value===b[2])&&(!b[3]||b[3].test((c["class"]||{}).value))},I=function(a){return f.event.special.hover?a:a.replace(B,"mouseenter$1 mouseleave$1")};f.event={add:function(a,c,d,e,g){var h,i,j,k,l,m,n,o,p,q,r,s;if(!(a.nodeType===3||a.nodeType===8||!c||!d||!(h=f._data(a)))){d.handler&&(p=d,d=p.handler,g=p.selector),d.guid||(d.guid=f.guid++),j=h.events,j||(h.events=j={}),i=h.handle,i||(h.handle=i=function(a){return typeof f!="undefined"&&(!a||f.event.triggered!==a.type)?f.event.dispatch.apply(i.elem,arguments):b},i.elem=a),c=f.trim(I(c)).split(" ");for(k=0;k<c.length;k++){l=A.exec(c[k])||[],m=l[1],n=(l[2]||"").split(".").sort(),s=f.event.special[m]||{},m=(g?s.delegateType:s.bindType)||m,s=f.event.special[m]||{},o=f.extend({type:m,origType:l[1],data:e,handler:d,guid:d.guid,selector:g,quick:g&&G(g),namespace:n.join(".")},p),r=j[m];if(!r){r=j[m]=[],r.delegateCount=0;if(!s.setup||s.setup.call(a,e,n,i)===!1)a.addEventListener?a.addEventListener(m,i,!1):a.attachEvent&&a.attachEvent("on"+m,i)}s.add&&(s.add.call(a,o),o.handler.guid||(o.handler.guid=d.guid)),g?r.splice(r.delegateCount++,0,o):r.push(o),f.event.global[m]=!0}a=null}},global:{},remove:function(a,b,c,d,e){var g=f.hasData(a)&&f._data(a),h,i,j,k,l,m,n,o,p,q,r,s;if(!!g&&!!(o=g.events)){b=f.trim(I(b||"")).split(" ");for(h=0;h<b.length;h++){i=A.exec(b[h])||[],j=k=i[1],l=i[2];if(!j){for(j in o)f.event.remove(a,j+b[h],c,d,!0);continue}p=f.event.special[j]||{},j=(d?p.delegateType:p.bindType)||j,r=o[j]||[],m=r.length,l=l?new RegExp("(^|\\.)"+l.split(".").sort().join("\\.(?:.*\\.)?")+"(\\.|$)"):null;for(n=0;n<r.length;n++)s=r[n],(e||k===s.origType)&&(!c||c.guid===s.guid)&&(!l||l.test(s.namespace))&&(!d||d===s.selector||d==="**"&&s.selector)&&(r.splice(n--,1),s.selector&&r.delegateCount--,p.remove&&p.remove.call(a,s));r.length===0&&m!==r.length&&((!p.teardown||p.teardown.call(a,l)===!1)&&f.removeEvent(a,j,g.handle),delete o[j])}f.isEmptyObject(o)&&(q=g.handle,q&&(q.elem=null),f.removeData(a,["events","handle"],!0))}},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,e,g){if(!e||e.nodeType!==3&&e.nodeType!==8){var h=c.type||c,i=[],j,k,l,m,n,o,p,q,r,s;if(E.test(h+f.event.triggered))return;h.indexOf("!")>=0&&(h=h.slice(0,-1),k=!0),h.indexOf(".")>=0&&(i=h.split("."),h=i.shift(),i.sort());if((!e||f.event.customEvent[h])&&!f.event.global[h])return;c=typeof c=="object"?c[f.expando]?c:new f.Event(h,c):new f.Event(h),c.type=h,c.isTrigger=!0,c.exclusive=k,c.namespace=i.join("."),c.namespace_re=c.namespace?new RegExp("(^|\\.)"+i.join("\\.(?:.*\\.)?")+"(\\.|$)"):null,o=h.indexOf(":")<0?"on"+h:"";if(!e){j=f.cache;for(l in j)j[l].events&&j[l].events[h]&&f.event.trigger(c,d,j[l].handle.elem,!0);return}c.result=b,c.target||(c.target=e),d=d!=null?f.makeArray(d):[],d.unshift(c),p=f.event.special[h]||{};if(p.trigger&&p.trigger.apply(e,d)===!1)return;r=[[e,p.bindType||h]];if(!g&&!p.noBubble&&!f.isWindow(e)){s=p.delegateType||h,m=E.test(s+h)?e:e.parentNode,n=null;for(;m;m=m.parentNode)r.push([m,s]),n=m;n&&n===e.ownerDocument&&r.push([n.defaultView||n.parentWindow||a,s])}for(l=0;l<r.length&&!c.isPropagationStopped();l++)m=r[l][0],c.type=r[l][1],q=(f._data(m,"events")||{})[c.type]&&f._data(m,"handle"),q&&q.apply(m,d),q=o&&m[o],q&&f.acceptData(m)&&q.apply(m,d)===!1&&c.preventDefault();c.type=h,!g&&!c.isDefaultPrevented()&&(!p._default||p._default.apply(e.ownerDocument,d)===!1)&&(h!=="click"||!f.nodeName(e,"a"))&&f.acceptData(e)&&o&&e[h]&&(h!=="focus"&&h!=="blur"||c.target.offsetWidth!==0)&&!f.isWindow(e)&&(n=e[o],n&&(e[o]=null),f.event.triggered=h,e[h](),f.event.triggered=b,n&&(e[o]=n));return c.result}},dispatch:function(c){c=f.event.fix(c||a.event);var d=(f._data(this,"events")||{})[c.type]||[],e=d.delegateCount,g=[].slice.call(arguments,0),h=!c.exclusive&&!c.namespace,i=f.event.special[c.type]||{},j=[],k,l,m,n,o,p,q,r,s,t,u;g[0]=c,c.delegateTarget=this;if(!i.preDispatch||i.preDispatch.call(this,c)!==!1){if(e&&(!c.button||c.type!=="click")){n=f(this),n.context=this.ownerDocument||this;for(m=c.target;m!=this;m=m.parentNode||this)if(m.disabled!==!0){p={},r=[],n[0]=m;for(k=0;k<e;k++)s=d[k],t=s.selector,p[t]===b&&(p[t]=s.quick?H(m,s.quick):n.is(t)),p[t]&&r.push(s);r.length&&j.push({elem:m,matches:r})}}d.length>e&&j.push({elem:this,matches:d.slice(e)});for(k=0;k<j.length&&!c.isPropagationStopped();k++){q=j[k],c.currentTarget=q.elem;for(l=0;l<q.matches.length&&!c.isImmediatePropagationStopped();l++){s=q.matches[l];if(h||!c.namespace&&!s.namespace||c.namespace_re&&c.namespace_re.test(s.namespace))c.data=s.data,c.handleObj=s,o=((f.event.special[s.origType]||{}).handle||s.handler).apply(q.elem,g),o!==b&&(c.result=o,o===!1&&(c.preventDefault(),c.stopPropagation()))}}i.postDispatch&&i.postDispatch.call(this,c);return c.result}},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){a.which==null&&(a.which=b.charCode!=null?b.charCode:b.keyCode);return a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,d){var e,f,g,h=d.button,i=d.fromElement;a.pageX==null&&d.clientX!=null&&(e=a.target.ownerDocument||c,f=e.documentElement,g=e.body,a.pageX=d.clientX+(f&&f.scrollLeft||g&&g.scrollLeft||0)-(f&&f.clientLeft||g&&g.clientLeft||0),a.pageY=d.clientY+(f&&f.scrollTop||g&&g.scrollTop||0)-(f&&f.clientTop||g&&g.clientTop||0)),!a.relatedTarget&&i&&(a.relatedTarget=i===a.target?d.toElement:i),!a.which&&h!==b&&(a.which=h&1?1:h&2?3:h&4?2:0);return a}},fix:function(a){if(a[f.expando])return a;var d,e,g=a,h=f.event.fixHooks[a.type]||{},i=h.props?this.props.concat(h.props):this.props;a=f.Event(g);for(d=i.length;d;)e=i[--d],a[e]=g[e];a.target||(a.target=g.srcElement||c),a.target.nodeType===3&&(a.target=a.target.parentNode),a.metaKey===b&&(a.metaKey=a.ctrlKey);return h.filter?h.filter(a,g):a},special:{ready:{setup:f.bindReady},load:{noBubble:!0},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(a,b,c){f.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}},simulate:function(a,b,c,d){var e=f.extend(new f.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?f.event.trigger(e,null,b):f.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},f.event.handle=f.event.dispatch,f.removeEvent=c.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){a.detachEvent&&a.detachEvent("on"+b,c)},f.Event=function(a,b){if(!(this instanceof f.Event))return new f.Event(a,b);a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?K:J):this.type=a,b&&f.extend(this,b),this.timeStamp=a&&a.timeStamp||f.now(),this[f.expando]=!0},f.Event.prototype={preventDefault:function(){this.isDefaultPrevented=K;var a=this.originalEvent;!a||(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){this.isPropagationStopped=K;var a=this.originalEvent;!a||(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=K,this.stopPropagation()},isDefaultPrevented:J,isPropagationStopped:J,isImmediatePropagationStopped:J},f.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){f.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c=this,d=a.relatedTarget,e=a.handleObj,g=e.selector,h;if(!d||d!==c&&!f.contains(c,d))a.type=e.origType,h=e.handler.apply(this,arguments),a.type=b;return h}}}),f.support.submitBubbles||(f.event.special.submit={setup:function(){if(f.nodeName(this,"form"))return!1;f.event.add(this,"click._submit keypress._submit",function(a){var c=a.target,d=f.nodeName(c,"input")||f.nodeName(c,"button")?c.form:b;d&&!d._submit_attached&&(f.event.add(d,"submit._submit",function(a){a._submit_bubble=!0}),d._submit_attached=!0)})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&f.event.simulate("submit",this.parentNode,a,!0))},teardown:function(){if(f.nodeName(this,"form"))return!1;f.event.remove(this,"._submit")}}),f.support.changeBubbles||(f.event.special.change={setup:function(){if(z.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")f.event.add(this,"propertychange._change",function(a){a.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),f.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1,f.event.simulate("change",this,a,!0))});return!1}f.event.add(this,"beforeactivate._change",function(a){var b=a.target;z.test(b.nodeName)&&!b._change_attached&&(f.event.add(b,"change._change",function(a){this.parentNode&&!a.isSimulated&&!a.isTrigger&&f.event.simulate("change",this.parentNode,a,!0)}),b._change_attached=!0)})},handle:function(a){var b=a.target;if(this!==b||a.isSimulated||a.isTrigger||b.type!=="radio"&&b.type!=="checkbox")return a.handleObj.handler.apply(this,arguments)},teardown:function(){f.event.remove(this,"._change");return z.test(this.nodeName)}}),f.support.focusinBubbles||f.each({focus:"focusin",blur:"focusout"},function(a,b){var d=0,e=function(a){f.event.simulate(b,a.target,f.event.fix(a),!0)};f.event.special[b]={setup:function(){d++===0&&c.addEventListener(a,e,!0)},teardown:function(){--d===0&&c.removeEventListener(a,e,!0)}}}),f.fn.extend({on:function(a,c,d,e,g){var h,i;if(typeof a=="object"){typeof c!="string"&&(d=d||c,c=b);for(i in a)this.on(i,c,d,a[i],g);return this}d==null&&e==null?(e=c,d=c=b):e==null&&(typeof c=="string"?(e=d,d=b):(e=d,d=c,c=b));if(e===!1)e=J;else if(!e)return this;g===1&&(h=e,e=function(a){f().off(a);return h.apply(this,arguments)},e.guid=h.guid||(h.guid=f.guid++));return this.each(function(){f.event.add(this,a,e,d,c)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,c,d){if(a&&a.preventDefault&&a.handleObj){var e=a.handleObj;f(a.delegateTarget).off(e.namespace?e.origType+"."+e.namespace:e.origType,e.selector,e.handler);return this}if(typeof a=="object"){for(var g in a)this.off(g,c,a[g]);return this}if(c===!1||typeof c=="function")d=c,c=b;d===!1&&(d=J);return this.each(function(){f.event.remove(this,a,d,c)})},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},live:function(a,b,c){f(this.context).on(a,this.selector,b,c);return this},die:function(a,b){f(this.context).off(a,this.selector||"**",b);return this},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return arguments.length==1?this.off(a,"**"):this.off(b,a,c)},trigger:function(a,b){return this.each(function(){f.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return f.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||f.guid++,d=0,e=function(c){var e=(f._data(this,"lastToggle"+a.guid)||0)%d;f._data(this,"lastToggle"+a.guid,e+1),c.preventDefault();return b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),f.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){f.fn[b]=function(a,c){c==null&&(c=a,a=null);return arguments.length>0?this.on(b,null,a,c):this.trigger(b)},f.attrFn&&(f.attrFn[b]=!0),C.test(b)&&(f.event.fixHooks[b]=f.event.keyHooks),D.test(b)&&(f.event.fixHooks[b]=f.event.mouseHooks)}),function(){function x(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}if(j.nodeType===1){g||(j[d]=c,j.sizset=h);if(typeof b!="string"){if(j===b){k=!0;break}}else if(m.filter(b,[j]).length>0){k=j;break}}j=j[a]}e[h]=k}}}function w(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}j.nodeType===1&&!g&&(j[d]=c,j.sizset=h);if(j.nodeName.toLowerCase()===b){k=j;break}j=j[a]}e[h]=k}}}var a=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,d="sizcache"+(Math.random()+"").replace(".",""),e=0,g=Object.prototype.toString,h=!1,i=!0,j=/\\/g,k=/\r\n/g,l=/\W/;[0,0].sort(function(){i=!1;return 0});var m=function(b,d,e,f){e=e||[],d=d||c;var h=d;if(d.nodeType!==1&&d.nodeType!==9)return[];if(!b||typeof b!="string")return e;var i,j,k,l,n,q,r,t,u=!0,v=m.isXML(d),w=[],x=b;do{a.exec(""),i=a.exec(x);if(i){x=i[3],w.push(i[1]);if(i[2]){l=i[3];break}}}while(i);if(w.length>1&&p.exec(b))if(w.length===2&&o.relative[w[0]])j=y(w[0]+w[1],d,f);else{j=o.relative[w[0]]?[d]:m(w.shift(),d);while(w.length)b=w.shift(),o.relative[b]&&(b+=w.shift()),j=y(b,j,f)}else{!f&&w.length>1&&d.nodeType===9&&!v&&o.match.ID.test(w[0])&&!o.match.ID.test(w[w.length-1])&&(n=m.find(w.shift(),d,v),d=n.expr?m.filter(n.expr,n.set)[0]:n.set[0]);if(d){n=f?{expr:w.pop(),set:s(f)}:m.find(w.pop(),w.length===1&&(w[0]==="~"||w[0]==="+")&&d.parentNode?d.parentNode:d,v),j=n.expr?m.filter(n.expr,n.set):n.set,w.length>0?k=s(j):u=!1;while(w.length)q=w.pop(),r=q,o.relative[q]?r=w.pop():q="",r==null&&(r=d),o.relative[q](k,r,v)}else k=w=[]}k||(k=j),k||m.error(q||b);if(g.call(k)==="[object Array]")if(!u)e.push.apply(e,k);else if(d&&d.nodeType===1)for(t=0;k[t]!=null;t++)k[t]&&(k[t]===!0||k[t].nodeType===1&&m.contains(d,k[t]))&&e.push(j[t]);else for(t=0;k[t]!=null;t++)k[t]&&k[t].nodeType===1&&e.push(j[t]);else s(k,e);l&&(m(l,h,e,f),m.uniqueSort(e));return e};m.uniqueSort=function(a){if(u){h=i,a.sort(u);if(h)for(var b=1;b<a.length;b++)a[b]===a[b-1]&&a.splice(b--,1)}return a},m.matches=function(a,b){return m(a,null,null,b)},m.matchesSelector=function(a,b){return m(b,null,null,[a]).length>0},m.find=function(a,b,c){var d,e,f,g,h,i;if(!a)return[];for(e=0,f=o.order.length;e<f;e++){h=o.order[e];if(g=o.leftMatch[h].exec(a)){i=g[1],g.splice(1,1);if(i.substr(i.length-1)!=="\\"){g[1]=(g[1]||"").replace(j,""),d=o.find[h](g,b,c);if(d!=null){a=a.replace(o.match[h],"");break}}}}d||(d=typeof b.getElementsByTagName!="undefined"?b.getElementsByTagName("*"):[]);return{set:d,expr:a}},m.filter=function(a,c,d,e){var f,g,h,i,j,k,l,n,p,q=a,r=[],s=c,t=c&&c[0]&&m.isXML(c[0]);while(a&&c.length){for(h in o.filter)if((f=o.leftMatch[h].exec(a))!=null&&f[2]){k=o.filter[h],l=f[1],g=!1,f.splice(1,1);if(l.substr(l.length-1)==="\\")continue;s===r&&(r=[]);if(o.preFilter[h]){f=o.preFilter[h](f,s,d,r,e,t);if(!f)g=i=!0;else if(f===!0)continue}if(f)for(n=0;(j=s[n])!=null;n++)j&&(i=k(j,f,n,s),p=e^i,d&&i!=null?p?g=!0:s[n]=!1:p&&(r.push(j),g=!0));if(i!==b){d||(s=r),a=a.replace(o.match[h],"");if(!g)return[];break}}if(a===q)if(g==null)m.error(a);else break;q=a}return s},m.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)};var n=m.getText=function(a){var b,c,d=a.nodeType,e="";if(d){if(d===1||d===9||d===11){if(typeof a.textContent=="string")return a.textContent;if(typeof a.innerText=="string")return a.innerText.replace(k,"");for(a=a.firstChild;a;a=a.nextSibling)e+=n(a)}else if(d===3||d===4)return a.nodeValue}else for(b=0;c=a[b];b++)c.nodeType!==8&&(e+=n(c));return e},o=m.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(a){return a.getAttribute("href")},type:function(a){return a.getAttribute("type")}},relative:{"+":function(a,b){var c=typeof b=="string",d=c&&!l.test(b),e=c&&!d;d&&(b=b.toLowerCase());for(var f=0,g=a.length,h;f<g;f++)if(h=a[f]){while((h=h.previousSibling)&&h.nodeType!==1);a[f]=e||h&&h.nodeName.toLowerCase()===b?h||!1:h===b}e&&m.filter(b,a,!0)},">":function(a,b){var c,d=typeof b=="string",e=0,f=a.length;if(d&&!l.test(b)){b=b.toLowerCase();for(;e<f;e++){c=a[e];if(c){var g=c.parentNode;a[e]=g.nodeName.toLowerCase()===b?g:!1}}}else{for(;e<f;e++)c=a[e],c&&(a[e]=d?c.parentNode:c.parentNode===b);d&&m.filter(b,a,!0)}},"":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("parentNode",b,f,a,d,c)},"~":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("previousSibling",b,f,a,d,c)}},find:{ID:function(a,b,c){if(typeof b.getElementById!="undefined"&&!c){var d=b.getElementById(a[1]);return d&&d.parentNode?[d]:[]}},NAME:function(a,b){if(typeof b.getElementsByName!="undefined"){var c=[],d=b.getElementsByName(a[1]);for(var e=0,f=d.length;e<f;e++)d[e].getAttribute("name")===a[1]&&c.push(d[e]);return c.length===0?null:c}},TAG:function(a,b){if(typeof b.getElementsByTagName!="undefined")return b.getElementsByTagName(a[1])}},preFilter:{CLASS:function(a,b,c,d,e,f){a=" "+a[1].replace(j,"")+" ";if(f)return a;for(var g=0,h;(h=b[g])!=null;g++)h&&(e^(h.className&&(" "+h.className+" ").replace(/[\t\n\r]/g," ").indexOf(a)>=0)?c||d.push(h):c&&(b[g]=!1));return!1},ID:function(a){return a[1].replace(j,"")},TAG:function(a,b){return a[1].replace(j,"").toLowerCase()},CHILD:function(a){if(a[1]==="nth"){a[2]||m.error(a[0]),a[2]=a[2].replace(/^\+|\s*/g,"");var b=/(-?)(\d*)(?:n([+\-]?\d*))?/.exec(a[2]==="even"&&"2n"||a[2]==="odd"&&"2n+1"||!/\D/.test(a[2])&&"0n+"+a[2]||a[2]);a[2]=b[1]+(b[2]||1)-0,a[3]=b[3]-0}else a[2]&&m.error(a[0]);a[0]=e++;return a},ATTR:function(a,b,c,d,e,f){var g=a[1]=a[1].replace(j,"");!f&&o.attrMap[g]&&(a[1]=o.attrMap[g]),a[4]=(a[4]||a[5]||"").replace(j,""),a[2]==="~="&&(a[4]=" "+a[4]+" ");return a},PSEUDO:function(b,c,d,e,f){if(b[1]==="not")if((a.exec(b[3])||"").length>1||/^\w/.test(b[3]))b[3]=m(b[3],null,null,c);else{var g=m.filter(b[3],c,d,!0^f);d||e.push.apply(e,g);return!1}else if(o.match.POS.test(b[0])||o.match.CHILD.test(b[0]))return!0;return b},POS:function(a){a.unshift(!0);return a}},filters:{enabled:function(a){return a.disabled===!1&&a.type!=="hidden"},disabled:function(a){return a.disabled===!0},checked:function(a){return a.checked===!0},selected:function(a){a.parentNode&&a.parentNode.selectedIndex;return a.selected===!0},parent:function(a){return!!a.firstChild},empty:function(a){return!a.firstChild},has:function(a,b,c){return!!m(c[3],a).length},header:function(a){return/h\d/i.test(a.nodeName)},text:function(a){var b=a.getAttribute("type"),c=a.type;return a.nodeName.toLowerCase()==="input"&&"text"===c&&(b===c||b===null)},radio:function(a){return a.nodeName.toLowerCase()==="input"&&"radio"===a.type},checkbox:function(a){return a.nodeName.toLowerCase()==="input"&&"checkbox"===a.type},file:function(a){return a.nodeName.toLowerCase()==="input"&&"file"===a.type},password:function(a){return a.nodeName.toLowerCase()==="input"&&"password"===a.type},submit:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"submit"===a.type},image:function(a){return a.nodeName.toLowerCase()==="input"&&"image"===a.type},reset:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"reset"===a.type},button:function(a){var b=a.nodeName.toLowerCase();return b==="input"&&"button"===a.type||b==="button"},input:function(a){return/input|select|textarea|button/i.test(a.nodeName)},focus:function(a){return a===a.ownerDocument.activeElement}},setFilters:{first:function(a,b){return b===0},last:function(a,b,c,d){return b===d.length-1},even:function(a,b){return b%2===0},odd:function(a,b){return b%2===1},lt:function(a,b,c){return b<c[3]-0},gt:function(a,b,c){return b>c[3]-0},nth:function(a,b,c){return c[3]-0===b},eq:function(a,b,c){return c[3]-0===b}},filter:{PSEUDO:function(a,b,c,d){var e=b[1],f=o.filters[e];if(f)return f(a,c,b,d);if(e==="contains")return(a.textContent||a.innerText||n([a])||"").indexOf(b[3])>=0;if(e==="not"){var g=b[3];for(var h=0,i=g.length;h<i;h++)if(g[h]===a)return!1;return!0}m.error(e)},CHILD:function(a,b){var c,e,f,g,h,i,j,k=b[1],l=a;switch(k){case"only":case"first":while(l=l.previousSibling)if(l.nodeType===1)return!1;if(k==="first")return!0;l=a;case"last":while(l=l.nextSibling)if(l.nodeType===1)return!1;return!0;case"nth":c=b[2],e=b[3];if(c===1&&e===0)return!0;f=b[0],g=a.parentNode;if(g&&(g[d]!==f||!a.nodeIndex)){i=0;for(l=g.firstChild;l;l=l.nextSibling)l.nodeType===1&&(l.nodeIndex=++i);g[d]=f}j=a.nodeIndex-e;return c===0?j===0:j%c===0&&j/c>=0}},ID:function(a,b){return a.nodeType===1&&a.getAttribute("id")===b},TAG:function(a,b){return b==="*"&&a.nodeType===1||!!a.nodeName&&a.nodeName.toLowerCase()===b},CLASS:function(a,b){return(" "+(a.className||a.getAttribute("class"))+" ").indexOf(b)>-1},ATTR:function(a,b){var c=b[1],d=m.attr?m.attr(a,c):o.attrHandle[c]?o.attrHandle[c](a):a[c]!=null?a[c]:a.getAttribute(c),e=d+"",f=b[2],g=b[4];return d==null?f==="!=":!f&&m.attr?d!=null:f==="="?e===g:f==="*="?e.indexOf(g)>=0:f==="~="?(" "+e+" ").indexOf(g)>=0:g?f==="!="?e!==g:f==="^="?e.indexOf(g)===0:f==="$="?e.substr(e.length-g.length)===g:f==="|="?e===g||e.substr(0,g.length+1)===g+"-":!1:e&&d!==!1},POS:function(a,b,c,d){var e=b[2],f=o.setFilters[e];if(f)return f(a,c,b,d)}}},p=o.match.POS,q=function(a,b){return"\\"+(b-0+1)};for(var r in o.match)o.match[r]=new RegExp(o.match[r].source+/(?![^\[]*\])(?![^\(]*\))/.source),o.leftMatch[r]=new RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[r].source.replace(/\\(\d+)/g,q));o.match.globalPOS=p;var s=function(a,b){a=Array.prototype.slice.call(a,0);if(b){b.push.apply(b,a);return b}return a};try{Array.prototype.slice.call(c.documentElement.childNodes,0)[0].nodeType}catch(t){s=function(a,b){var c=0,d=b||[];if(g.call(a)==="[object Array]")Array.prototype.push.apply(d,a);else if(typeof a.length=="number")for(var e=a.length;c<e;c++)d.push(a[c]);else for(;a[c];c++)d.push(a[c]);return d}}var u,v;c.documentElement.compareDocumentPosition?u=function(a,b){if(a===b){h=!0;return 0}if(!a.compareDocumentPosition||!b.compareDocumentPosition)return a.compareDocumentPosition?-1:1;return a.compareDocumentPosition(b)&4?-1:1}:(u=function(a,b){if(a===b){h=!0;return 0}if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],f=[],g=a.parentNode,i=b.parentNode,j=g;if(g===i)return v(a,b);if(!g)return-1;if(!i)return 1;while(j)e.unshift(j),j=j.parentNode;j=i;while(j)f.unshift(j),j=j.parentNode;c=e.length,d=f.length;for(var k=0;k<c&&k<d;k++)if(e[k]!==f[k])return v(e[k],f[k]);return k===c?v(a,f[k],-1):v(e[k],b,1)},v=function(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}),function(){var a=c.createElement("div"),d="script"+(new Date).getTime(),e=c.documentElement;a.innerHTML="<a name='"+d+"'/>",e.insertBefore(a,e.firstChild),c.getElementById(d)&&(o.find.ID=function(a,c,d){if(typeof c.getElementById!="undefined"&&!d){var e=c.getElementById(a[1]);return e?e.id===a[1]||typeof e.getAttributeNode!="undefined"&&e.getAttributeNode("id").nodeValue===a[1]?[e]:b:[]}},o.filter.ID=function(a,b){var c=typeof a.getAttributeNode!="undefined"&&a.getAttributeNode("id");return a.nodeType===1&&c&&c.nodeValue===b}),e.removeChild(a),e=a=null}(),function(){var a=c.createElement("div");a.appendChild(c.createComment("")),a.getElementsByTagName("*").length>0&&(o.find.TAG=function(a,b){var c=b.getElementsByTagName(a[1]);if(a[1]==="*"){var d=[];for(var e=0;c[e];e++)c[e].nodeType===1&&d.push(c[e]);c=d}return c}),a.innerHTML="<a href='#'></a>",a.firstChild&&typeof a.firstChild.getAttribute!="undefined"&&a.firstChild.getAttribute("href")!=="#"&&(o.attrHandle.href=function(a){return a.getAttribute("href",2)}),a=null}(),c.querySelectorAll&&function(){var a=m,b=c.createElement("div"),d="__sizzle__";b.innerHTML="<p class='TEST'></p>";if(!b.querySelectorAll||b.querySelectorAll(".TEST").length!==0){m=function(b,e,f,g){e=e||c;if(!g&&!m.isXML(e)){var h=/^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(b);if(h&&(e.nodeType===1||e.nodeType===9)){if(h[1])return s(e.getElementsByTagName(b),f);if(h[2]&&o.find.CLASS&&e.getElementsByClassName)return s(e.getElementsByClassName(h[2]),f)}if(e.nodeType===9){if(b==="body"&&e.body)return s([e.body],f);if(h&&h[3]){var i=e.getElementById(h[3]);if(!i||!i.parentNode)return s([],f);if(i.id===h[3])return s([i],f)}try{return s(e.querySelectorAll(b),f)}catch(j){}}else if(e.nodeType===1&&e.nodeName.toLowerCase()!=="object"){var k=e,l=e.getAttribute("id"),n=l||d,p=e.parentNode,q=/^\s*[+~]/.test(b);l?n=n.replace(/'/g,"\\$&"):e.setAttribute("id",n),q&&p&&(e=e.parentNode);try{if(!q||p)return s(e.querySelectorAll("[id='"+n+"'] "+b),f)}catch(r){}finally{l||k.removeAttribute("id")}}}return a(b,e,f,g)};for(var e in a)m[e]=a[e];b=null}}(),function(){var a=c.documentElement,b=a.matchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.msMatchesSelector;if(b){var d=!b.call(c.createElement("div"),"div"),e=!1;try{b.call(c.documentElement,"[test!='']:sizzle")}catch(f){e=!0}m.matchesSelector=function(a,c){c=c.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!m.isXML(a))try{if(e||!o.match.PSEUDO.test(c)&&!/!=/.test(c)){var f=b.call(a,c);if(f||!d||a.document&&a.document.nodeType!==11)return f}}catch(g){}return m(c,null,null,[a]).length>0}}}(),function(){var a=c.createElement("div");a.innerHTML="<div class='test e'></div><div class='test'></div>";if(!!a.getElementsByClassName&&a.getElementsByClassName("e").length!==0){a.lastChild.className="e";if(a.getElementsByClassName("e").length===1)return;o.order.splice(1,0,"CLASS"),o.find.CLASS=function(a,b,c){if(typeof b.getElementsByClassName!="undefined"&&!c)return b.getElementsByClassName(a[1])},a=null}}(),c.documentElement.contains?m.contains=function(a,b){return a!==b&&(a.contains?a.contains(b):!0)}:c.documentElement.compareDocumentPosition?m.contains=function(a,b){return!!(a.compareDocumentPosition(b)&16)}:m.contains=function(){return!1},m.isXML=function(a){var b=(a?a.ownerDocument||a:0).documentElement;return b?b.nodeName!=="HTML":!1};var y=function(a,b,c){var d,e=[],f="",g=b.nodeType?[b]:b;while(d=o.match.PSEUDO.exec(a))f+=d[0],a=a.replace(o.match.PSEUDO,"");a=o.relative[a]?a+"*":a;for(var h=0,i=g.length;h<i;h++)m(a,g[h],e,c);return m.filter(f,e)};m.attr=f.attr,m.selectors.attrMap={},f.find=m,f.expr=m.selectors,f.expr[":"]=f.expr.filters,f.unique=m.uniqueSort,f.text=m.getText,f.isXMLDoc=m.isXML,f.contains=m.contains}();var L=/Until$/,M=/^(?:parents|prevUntil|prevAll)/,N=/,/,O=/^.[^:#\[\.,]*$/,P=Array.prototype.slice,Q=f.expr.match.globalPOS,R={children:!0,contents:!0,next:!0,prev:!0};f.fn.extend({find:function(a){var b=this,c,d;if(typeof a!="string")return f(a).filter(function(){for(c=0,d=b.length;c<d;c++)if(f.contains(b[c],this))return!0});var e=this.pushStack("","find",a),g,h,i;for(c=0,d=this.length;c<d;c++){g=e.length,f.find(a,this[c],e);if(c>0)for(h=g;h<e.length;h++)for(i=0;i<g;i++)if(e[i]===e[h]){e.splice(h--,1);break}}return e},has:function(a){var b=f(a);return this.filter(function(){for(var a=0,c=b.length;a<c;a++)if(f.contains(this,b[a]))return!0})},not:function(a){return this.pushStack(T(this,a,!1),"not",a)},filter:function(a){return this.pushStack(T(this,a,!0),"filter",a)},is:function(a){return!!a&&(typeof a=="string"?Q.test(a)?f(a,this.context).index(this[0])>=0:f.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c=[],d,e,g=this[0];if(f.isArray(a)){var h=1;while(g&&g.ownerDocument&&g!==b){for(d=0;d<a.length;d++)f(g).is(a[d])&&c.push({selector:a[d],elem:g,level:h});g=g.parentNode,h++}return c}var i=Q.test(a)||typeof a!="string"?f(a,b||this.context):0;for(d=0,e=this.length;d<e;d++){g=this[d];while(g){if(i?i.index(g)>-1:f.find.matchesSelector(g,a)){c.push(g);break}g=g.parentNode;if(!g||!g.ownerDocument||g===b||g.nodeType===11)break}}c=c.length>1?f.unique(c):c;return this.pushStack(c,"closest",a)},index:function(a){if(!a)return this[0]&&this[0].parentNode?this.prevAll().length:-1;if(typeof a=="string")return f.inArray(this[0],f(a));return f.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var c=typeof a=="string"?f(a,b):f.makeArray(a&&a.nodeType?[a]:a),d=f.merge(this.get(),c);return this.pushStack(S(c[0])||S(d[0])?d:f.unique(d))},andSelf:function(){return this.add(this.prevObject)}}),f.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return f.dir(a,"parentNode")},parentsUntil:function(a,b,c){return f.dir(a,"parentNode",c)},next:function(a){return f.nth(a,2,"nextSibling")},prev:function(a){return f.nth(a,2,"previousSibling")},nextAll:function(a){return f.dir(a,"nextSibling")},prevAll:function(a){return f.dir(a,"previousSibling")},nextUntil:function(a,b,c){return f.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return f.dir(a,"previousSibling",c)},siblings:function(a){return f.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return f.sibling(a.firstChild)},contents:function(a){return f.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:f.makeArray(a.childNodes)}},function(a,b){f.fn[a]=function(c,d){var e=f.map(this,b,c);L.test(a)||(d=c),d&&typeof d=="string"&&(e=f.filter(d,e)),e=this.length>1&&!R[a]?f.unique(e):e,(this.length>1||N.test(d))&&M.test(a)&&(e=e.reverse());return this.pushStack(e,a,P.call(arguments).join(","))}}),f.extend({filter:function(a,b,c){c&&(a=":not("+a+")");return b.length===1?f.find.matchesSelector(b[0],a)?[b[0]]:[]:f.find.matches(a,b)},dir:function(a,c,d){var e=[],g=a[c];while(g&&g.nodeType!==9&&(d===b||g.nodeType!==1||!f(g).is(d)))g.nodeType===1&&e.push(g),g=g[c];return e},nth:function(a,b,c,d){b=b||1;var e=0;for(;a;a=a[c])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var V="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",W=/ jQuery\d+="(?:\d+|null)"/g,X=/^\s+/,Y=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Z=/<([\w:]+)/,$=/<tbody/i,_=/<|&#?\w+;/,ba=/<(?:script|style)/i,bb=/<(?:script|object|embed|option|style)/i,bc=new RegExp("<(?:"+V+")[\\s/>]","i"),bd=/checked\s*(?:[^=]|=\s*.checked.)/i,be=/\/(java|ecma)script/i,bf=/^\s*<!(?:\[CDATA\[|\-\-)/,bg={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},bh=U(c);bg.optgroup=bg.option,bg.tbody=bg.tfoot=bg.colgroup=bg.caption=bg.thead,bg.th=bg.td,f.support.htmlSerialize||(bg._default=[1,"div<div>","</div>"]),f.fn.extend({text:function(a){return f.access(this,function(a){return a===b?f.text(this):this.empty().append((this[0]&&this[0].ownerDocument||c).createTextNode(a))},null,a,arguments.length)},wrapAll:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapAll(a.call(this,b))});if(this[0]){var b=f(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapInner(a.call(this,b))});return this.each(function(){var b=f(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=f.isFunction(a);return this.each(function(c){f(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){f.nodeName(this,"body")||f(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=f
.clean(arguments);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,f.clean(arguments));return a}},remove:function(a,b){for(var c=0,d;(d=this[c])!=null;c++)if(!a||f.filter(a,[d]).length)!b&&d.nodeType===1&&(f.cleanData(d.getElementsByTagName("*")),f.cleanData([d])),d.parentNode&&d.parentNode.removeChild(d);return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++){b.nodeType===1&&f.cleanData(b.getElementsByTagName("*"));while(b.firstChild)b.removeChild(b.firstChild)}return this},clone:function(a,b){a=a==null?!1:a,b=b==null?a:b;return this.map(function(){return f.clone(this,a,b)})},html:function(a){return f.access(this,function(a){var c=this[0]||{},d=0,e=this.length;if(a===b)return c.nodeType===1?c.innerHTML.replace(W,""):null;if(typeof a=="string"&&!ba.test(a)&&(f.support.leadingWhitespace||!X.test(a))&&!bg[(Z.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Y,"<$1></$2>");try{for(;d<e;d++)c=this[d]||{},c.nodeType===1&&(f.cleanData(c.getElementsByTagName("*")),c.innerHTML=a);c=0}catch(g){}}c&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(f.isFunction(a))return this.each(function(b){var c=f(this),d=c.html();c.replaceWith(a.call(this,b,d))});typeof a!="string"&&(a=f(a).detach());return this.each(function(){var b=this.nextSibling,c=this.parentNode;f(this).remove(),b?f(b).before(a):f(c).append(a)})}return this.length?this.pushStack(f(f.isFunction(a)?a():a),"replaceWith",a):this},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){var e,g,h,i,j=a[0],k=[];if(!f.support.checkClone&&arguments.length===3&&typeof j=="string"&&bd.test(j))return this.each(function(){f(this).domManip(a,c,d,!0)});if(f.isFunction(j))return this.each(function(e){var g=f(this);a[0]=j.call(this,e,c?g.html():b),g.domManip(a,c,d)});if(this[0]){i=j&&j.parentNode,f.support.parentNode&&i&&i.nodeType===11&&i.childNodes.length===this.length?e={fragment:i}:e=f.buildFragment(a,this,k),h=e.fragment,h.childNodes.length===1?g=h=h.firstChild:g=h.firstChild;if(g){c=c&&f.nodeName(g,"tr");for(var l=0,m=this.length,n=m-1;l<m;l++)d.call(c?bi(this[l],g):this[l],e.cacheable||m>1&&l<n?f.clone(h,!0,!0):h)}k.length&&f.each(k,function(a,b){b.src?f.ajax({type:"GET",global:!1,url:b.src,async:!1,dataType:"script"}):f.globalEval((b.text||b.textContent||b.innerHTML||"").replace(bf,"/*$0*/")),b.parentNode&&b.parentNode.removeChild(b)})}return this}}),f.buildFragment=function(a,b,d){var e,g,h,i,j=a[0];b&&b[0]&&(i=b[0].ownerDocument||b[0]),i.createDocumentFragment||(i=c),a.length===1&&typeof j=="string"&&j.length<512&&i===c&&j.charAt(0)==="<"&&!bb.test(j)&&(f.support.checkClone||!bd.test(j))&&(f.support.html5Clone||!bc.test(j))&&(g=!0,h=f.fragments[j],h&&h!==1&&(e=h)),e||(e=i.createDocumentFragment(),f.clean(a,i,e,d)),g&&(f.fragments[j]=h?e:1);return{fragment:e,cacheable:g}},f.fragments={},f.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){f.fn[a]=function(c){var d=[],e=f(c),g=this.length===1&&this[0].parentNode;if(g&&g.nodeType===11&&g.childNodes.length===1&&e.length===1){e[b](this[0]);return this}for(var h=0,i=e.length;h<i;h++){var j=(h>0?this.clone(!0):this).get();f(e[h])[b](j),d=d.concat(j)}return this.pushStack(d,a,e.selector)}}),f.extend({clone:function(a,b,c){var d,e,g,h=f.support.html5Clone||f.isXMLDoc(a)||!bc.test("<"+a.nodeName+">")?a.cloneNode(!0):bo(a);if((!f.support.noCloneEvent||!f.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!f.isXMLDoc(a)){bk(a,h),d=bl(a),e=bl(h);for(g=0;d[g];++g)e[g]&&bk(d[g],e[g])}if(b){bj(a,h);if(c){d=bl(a),e=bl(h);for(g=0;d[g];++g)bj(d[g],e[g])}}d=e=null;return h},clean:function(a,b,d,e){var g,h,i,j=[];b=b||c,typeof b.createElement=="undefined"&&(b=b.ownerDocument||b[0]&&b[0].ownerDocument||c);for(var k=0,l;(l=a[k])!=null;k++){typeof l=="number"&&(l+="");if(!l)continue;if(typeof l=="string")if(!_.test(l))l=b.createTextNode(l);else{l=l.replace(Y,"<$1></$2>");var m=(Z.exec(l)||["",""])[1].toLowerCase(),n=bg[m]||bg._default,o=n[0],p=b.createElement("div"),q=bh.childNodes,r;b===c?bh.appendChild(p):U(b).appendChild(p),p.innerHTML=n[1]+l+n[2];while(o--)p=p.lastChild;if(!f.support.tbody){var s=$.test(l),t=m==="table"&&!s?p.firstChild&&p.firstChild.childNodes:n[1]==="<table>"&&!s?p.childNodes:[];for(i=t.length-1;i>=0;--i)f.nodeName(t[i],"tbody")&&!t[i].childNodes.length&&t[i].parentNode.removeChild(t[i])}!f.support.leadingWhitespace&&X.test(l)&&p.insertBefore(b.createTextNode(X.exec(l)[0]),p.firstChild),l=p.childNodes,p&&(p.parentNode.removeChild(p),q.length>0&&(r=q[q.length-1],r&&r.parentNode&&r.parentNode.removeChild(r)))}var u;if(!f.support.appendChecked)if(l[0]&&typeof (u=l.length)=="number")for(i=0;i<u;i++)bn(l[i]);else bn(l);l.nodeType?j.push(l):j=f.merge(j,l)}if(d){g=function(a){return!a.type||be.test(a.type)};for(k=0;j[k];k++){h=j[k];if(e&&f.nodeName(h,"script")&&(!h.type||be.test(h.type)))e.push(h.parentNode?h.parentNode.removeChild(h):h);else{if(h.nodeType===1){var v=f.grep(h.getElementsByTagName("script"),g);j.splice.apply(j,[k+1,0].concat(v))}d.appendChild(h)}}}return j},cleanData:function(a){var b,c,d=f.cache,e=f.event.special,g=f.support.deleteExpando;for(var h=0,i;(i=a[h])!=null;h++){if(i.nodeName&&f.noData[i.nodeName.toLowerCase()])continue;c=i[f.expando];if(c){b=d[c];if(b&&b.events){for(var j in b.events)e[j]?f.event.remove(i,j):f.removeEvent(i,j,b.handle);b.handle&&(b.handle.elem=null)}g?delete i[f.expando]:i.removeAttribute&&i.removeAttribute(f.expando),delete d[c]}}}});var bp=/alpha\([^)]*\)/i,bq=/opacity=([^)]*)/,br=/([A-Z]|^ms)/g,bs=/^[\-+]?(?:\d*\.)?\d+$/i,bt=/^-?(?:\d*\.)?\d+(?!px)[^\d\s]+$/i,bu=/^([\-+])=([\-+.\de]+)/,bv=/^margin/,bw={position:"absolute",visibility:"hidden",display:"block"},bx=["Top","Right","Bottom","Left"],by,bz,bA;f.fn.css=function(a,c){return f.access(this,function(a,c,d){return d!==b?f.style(a,c,d):f.css(a,c)},a,c,arguments.length>1)},f.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=by(a,"opacity");return c===""?"1":c}return a.style.opacity}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":f.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,c,d,e){if(!!a&&a.nodeType!==3&&a.nodeType!==8&&!!a.style){var g,h,i=f.camelCase(c),j=a.style,k=f.cssHooks[i];c=f.cssProps[i]||i;if(d===b){if(k&&"get"in k&&(g=k.get(a,!1,e))!==b)return g;return j[c]}h=typeof d,h==="string"&&(g=bu.exec(d))&&(d=+(g[1]+1)*+g[2]+parseFloat(f.css(a,c)),h="number");if(d==null||h==="number"&&isNaN(d))return;h==="number"&&!f.cssNumber[i]&&(d+="px");if(!k||!("set"in k)||(d=k.set(a,d))!==b)try{j[c]=d}catch(l){}}},css:function(a,c,d){var e,g;c=f.camelCase(c),g=f.cssHooks[c],c=f.cssProps[c]||c,c==="cssFloat"&&(c="float");if(g&&"get"in g&&(e=g.get(a,!0,d))!==b)return e;if(by)return by(a,c)},swap:function(a,b,c){var d={},e,f;for(f in b)d[f]=a.style[f],a.style[f]=b[f];e=c.call(a);for(f in b)a.style[f]=d[f];return e}}),f.curCSS=f.css,c.defaultView&&c.defaultView.getComputedStyle&&(bz=function(a,b){var c,d,e,g,h=a.style;b=b.replace(br,"-$1").toLowerCase(),(d=a.ownerDocument.defaultView)&&(e=d.getComputedStyle(a,null))&&(c=e.getPropertyValue(b),c===""&&!f.contains(a.ownerDocument.documentElement,a)&&(c=f.style(a,b))),!f.support.pixelMargin&&e&&bv.test(b)&&bt.test(c)&&(g=h.width,h.width=c,c=e.width,h.width=g);return c}),c.documentElement.currentStyle&&(bA=function(a,b){var c,d,e,f=a.currentStyle&&a.currentStyle[b],g=a.style;f==null&&g&&(e=g[b])&&(f=e),bt.test(f)&&(c=g.left,d=a.runtimeStyle&&a.runtimeStyle.left,d&&(a.runtimeStyle.left=a.currentStyle.left),g.left=b==="fontSize"?"1em":f,f=g.pixelLeft+"px",g.left=c,d&&(a.runtimeStyle.left=d));return f===""?"auto":f}),by=bz||bA,f.each(["height","width"],function(a,b){f.cssHooks[b]={get:function(a,c,d){if(c)return a.offsetWidth!==0?bB(a,b,d):f.swap(a,bw,function(){return bB(a,b,d)})},set:function(a,b){return bs.test(b)?b+"px":b}}}),f.support.opacity||(f.cssHooks.opacity={get:function(a,b){return bq.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=f.isNumeric(b)?"alpha(opacity="+b*100+")":"",g=d&&d.filter||c.filter||"";c.zoom=1;if(b>=1&&f.trim(g.replace(bp,""))===""){c.removeAttribute("filter");if(d&&!d.filter)return}c.filter=bp.test(g)?g.replace(bp,e):g+" "+e}}),f(function(){f.support.reliableMarginRight||(f.cssHooks.marginRight={get:function(a,b){return f.swap(a,{display:"inline-block"},function(){return b?by(a,"margin-right"):a.style.marginRight})}})}),f.expr&&f.expr.filters&&(f.expr.filters.hidden=function(a){var b=a.offsetWidth,c=a.offsetHeight;return b===0&&c===0||!f.support.reliableHiddenOffsets&&(a.style&&a.style.display||f.css(a,"display"))==="none"},f.expr.filters.visible=function(a){return!f.expr.filters.hidden(a)}),f.each({margin:"",padding:"",border:"Width"},function(a,b){f.cssHooks[a+b]={expand:function(c){var d,e=typeof c=="string"?c.split(" "):[c],f={};for(d=0;d<4;d++)f[a+bx[d]+b]=e[d]||e[d-2]||e[0];return f}}});var bC=/%20/g,bD=/\[\]$/,bE=/\r?\n/g,bF=/#.*$/,bG=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,bH=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,bI=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,bJ=/^(?:GET|HEAD)$/,bK=/^\/\//,bL=/\?/,bM=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,bN=/^(?:select|textarea)/i,bO=/\s+/,bP=/([?&])_=[^&]*/,bQ=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,bR=f.fn.load,bS={},bT={},bU,bV,bW=["*/"]+["*"];try{bU=e.href}catch(bX){bU=c.createElement("a"),bU.href="",bU=bU.href}bV=bQ.exec(bU.toLowerCase())||[],f.fn.extend({load:function(a,c,d){if(typeof a!="string"&&bR)return bR.apply(this,arguments);if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var g=a.slice(e,a.length);a=a.slice(0,e)}var h="GET";c&&(f.isFunction(c)?(d=c,c=b):typeof c=="object"&&(c=f.param(c,f.ajaxSettings.traditional),h="POST"));var i=this;f.ajax({url:a,type:h,dataType:"html",data:c,complete:function(a,b,c){c=a.responseText,a.isResolved()&&(a.done(function(a){c=a}),i.html(g?f("<div>").append(c.replace(bM,"")).find(g):c)),d&&i.each(d,[c,b,a])}});return this},serialize:function(){return f.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?f.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||bN.test(this.nodeName)||bH.test(this.type))}).map(function(a,b){var c=f(this).val();return c==null?null:f.isArray(c)?f.map(c,function(a,c){return{name:b.name,value:a.replace(bE,"\r\n")}}):{name:b.name,value:c.replace(bE,"\r\n")}}).get()}}),f.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){f.fn[b]=function(a){return this.on(b,a)}}),f.each(["get","post"],function(a,c){f[c]=function(a,d,e,g){f.isFunction(d)&&(g=g||e,e=d,d=b);return f.ajax({type:c,url:a,data:d,success:e,dataType:g})}}),f.extend({getScript:function(a,c){return f.get(a,b,c,"script")},getJSON:function(a,b,c){return f.get(a,b,c,"json")},ajaxSetup:function(a,b){b?b$(a,f.ajaxSettings):(b=a,a=f.ajaxSettings),b$(a,b);return a},ajaxSettings:{url:bU,isLocal:bI.test(bV[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded; charset=UTF-8",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":bW},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":a.String,"text html":!0,"text json":f.parseJSON,"text xml":f.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:bY(bS),ajaxTransport:bY(bT),ajax:function(a,c){function w(a,c,l,m){if(s!==2){s=2,q&&clearTimeout(q),p=b,n=m||"",v.readyState=a>0?4:0;var o,r,u,w=c,x=l?ca(d,v,l):b,y,z;if(a>=200&&a<300||a===304){if(d.ifModified){if(y=v.getResponseHeader("Last-Modified"))f.lastModified[k]=y;if(z=v.getResponseHeader("Etag"))f.etag[k]=z}if(a===304)w="notmodified",o=!0;else try{r=cb(d,x),w="success",o=!0}catch(A){w="parsererror",u=A}}else{u=w;if(!w||a)w="error",a<0&&(a=0)}v.status=a,v.statusText=""+(c||w),o?h.resolveWith(e,[r,w,v]):h.rejectWith(e,[v,w,u]),v.statusCode(j),j=b,t&&g.trigger("ajax"+(o?"Success":"Error"),[v,d,o?r:u]),i.fireWith(e,[v,w]),t&&(g.trigger("ajaxComplete",[v,d]),--f.active||f.event.trigger("ajaxStop"))}}typeof a=="object"&&(c=a,a=b),c=c||{};var d=f.ajaxSetup({},c),e=d.context||d,g=e!==d&&(e.nodeType||e instanceof f)?f(e):f.event,h=f.Deferred(),i=f.Callbacks("once memory"),j=d.statusCode||{},k,l={},m={},n,o,p,q,r,s=0,t,u,v={readyState:0,setRequestHeader:function(a,b){if(!s){var c=a.toLowerCase();a=m[c]=m[c]||a,l[a]=b}return this},getAllResponseHeaders:function(){return s===2?n:null},getResponseHeader:function(a){var c;if(s===2){if(!o){o={};while(c=bG.exec(n))o[c[1].toLowerCase()]=c[2]}c=o[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){s||(d.mimeType=a);return this},abort:function(a){a=a||"abort",p&&p.abort(a),w(0,a);return this}};h.promise(v),v.success=v.done,v.error=v.fail,v.complete=i.add,v.statusCode=function(a){if(a){var b;if(s<2)for(b in a)j[b]=[j[b],a[b]];else b=a[v.status],v.then(b,b)}return this},d.url=((a||d.url)+"").replace(bF,"").replace(bK,bV[1]+"//"),d.dataTypes=f.trim(d.dataType||"*").toLowerCase().split(bO),d.crossDomain==null&&(r=bQ.exec(d.url.toLowerCase()),d.crossDomain=!(!r||r[1]==bV[1]&&r[2]==bV[2]&&(r[3]||(r[1]==="http:"?80:443))==(bV[3]||(bV[1]==="http:"?80:443)))),d.data&&d.processData&&typeof d.data!="string"&&(d.data=f.param(d.data,d.traditional)),bZ(bS,d,c,v);if(s===2)return!1;t=d.global,d.type=d.type.toUpperCase(),d.hasContent=!bJ.test(d.type),t&&f.active++===0&&f.event.trigger("ajaxStart");if(!d.hasContent){d.data&&(d.url+=(bL.test(d.url)?"&":"?")+d.data,delete d.data),k=d.url;if(d.cache===!1){var x=f.now(),y=d.url.replace(bP,"$1_="+x);d.url=y+(y===d.url?(bL.test(d.url)?"&":"?")+"_="+x:"")}}(d.data&&d.hasContent&&d.contentType!==!1||c.contentType)&&v.setRequestHeader("Content-Type",d.contentType),d.ifModified&&(k=k||d.url,f.lastModified[k]&&v.setRequestHeader("If-Modified-Since",f.lastModified[k]),f.etag[k]&&v.setRequestHeader("If-None-Match",f.etag[k])),v.setRequestHeader("Accept",d.dataTypes[0]&&d.accepts[d.dataTypes[0]]?d.accepts[d.dataTypes[0]]+(d.dataTypes[0]!=="*"?", "+bW+"; q=0.01":""):d.accepts["*"]);for(u in d.headers)v.setRequestHeader(u,d.headers[u]);if(d.beforeSend&&(d.beforeSend.call(e,v,d)===!1||s===2)){v.abort();return!1}for(u in{success:1,error:1,complete:1})v[u](d[u]);p=bZ(bT,d,c,v);if(!p)w(-1,"No Transport");else{v.readyState=1,t&&g.trigger("ajaxSend",[v,d]),d.async&&d.timeout>0&&(q=setTimeout(function(){v.abort("timeout")},d.timeout));try{s=1,p.send(l,w)}catch(z){if(s<2)w(-1,z);else throw z}}return v},param:function(a,c){var d=[],e=function(a,b){b=f.isFunction(b)?b():b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};c===b&&(c=f.ajaxSettings.traditional);if(f.isArray(a)||a.jquery&&!f.isPlainObject(a))f.each(a,function(){e(this.name,this.value)});else for(var g in a)b_(g,a[g],c,e);return d.join("&").replace(bC,"+")}}),f.extend({active:0,lastModified:{},etag:{}});var cc=f.now(),cd=/(\=)\?(&|$)|\?\?/i;f.ajaxSetup({jsonp:"callback",jsonpCallback:function(){return f.expando+"_"+cc++}}),f.ajaxPrefilter("json jsonp",function(b,c,d){var e=typeof b.data=="string"&&/^application\/x\-www\-form\-urlencoded/.test(b.contentType);if(b.dataTypes[0]==="jsonp"||b.jsonp!==!1&&(cd.test(b.url)||e&&cd.test(b.data))){var g,h=b.jsonpCallback=f.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,i=a[h],j=b.url,k=b.data,l="$1"+h+"$2";b.jsonp!==!1&&(j=j.replace(cd,l),b.url===j&&(e&&(k=k.replace(cd,l)),b.data===k&&(j+=(/\?/.test(j)?"&":"?")+b.jsonp+"="+h))),b.url=j,b.data=k,a[h]=function(a){g=[a]},d.always(function(){a[h]=i,g&&f.isFunction(i)&&a[h](g[0])}),b.converters["script json"]=function(){g||f.error(h+" was not called");return g[0]},b.dataTypes[0]="json";return"script"}}),f.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(a){f.globalEval(a);return a}}}),f.ajaxPrefilter("script",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),f.ajaxTransport("script",function(a){if(a.crossDomain){var d,e=c.head||c.getElementsByTagName("head")[0]||c.documentElement;return{send:function(f,g){d=c.createElement("script"),d.async="async",a.scriptCharset&&(d.charset=a.scriptCharset),d.src=a.url,d.onload=d.onreadystatechange=function(a,c){if(c||!d.readyState||/loaded|complete/.test(d.readyState))d.onload=d.onreadystatechange=null,e&&d.parentNode&&e.removeChild(d),d=b,c||g(200,"success")},e.insertBefore(d,e.firstChild)},abort:function(){d&&d.onload(0,1)}}}});var ce=a.ActiveXObject?function(){for(var a in cg)cg[a](0,1)}:!1,cf=0,cg;f.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&ch()||ci()}:ch,function(a){f.extend(f.support,{ajax:!!a,cors:!!a&&"withCredentials"in a})}(f.ajaxSettings.xhr()),f.support.ajax&&f.ajaxTransport(function(c){if(!c.crossDomain||f.support.cors){var d;return{send:function(e,g){var h=c.xhr(),i,j;c.username?h.open(c.type,c.url,c.async,c.username,c.password):h.open(c.type,c.url,c.async);if(c.xhrFields)for(j in c.xhrFields)h[j]=c.xhrFields[j];c.mimeType&&h.overrideMimeType&&h.overrideMimeType(c.mimeType),!c.crossDomain&&!e["X-Requested-With"]&&(e["X-Requested-With"]="XMLHttpRequest");try{for(j in e)h.setRequestHeader(j,e[j])}catch(k){}h.send(c.hasContent&&c.data||null),d=function(a,e){var j,k,l,m,n;try{if(d&&(e||h.readyState===4)){d=b,i&&(h.onreadystatechange=f.noop,ce&&delete cg[i]);if(e)h.readyState!==4&&h.abort();else{j=h.status,l=h.getAllResponseHeaders(),m={},n=h.responseXML,n&&n.documentElement&&(m.xml=n);try{m.text=h.responseText}catch(a){}try{k=h.statusText}catch(o){k=""}!j&&c.isLocal&&!c.crossDomain?j=m.text?200:404:j===1223&&(j=204)}}}catch(p){e||g(-1,p)}m&&g(j,k,m,l)},!c.async||h.readyState===4?d():(i=++cf,ce&&(cg||(cg={},f(a).unload(ce)),cg[i]=d),h.onreadystatechange=d)},abort:function(){d&&d(0,1)}}}});var cj={},ck,cl,cm=/^(?:toggle|show|hide)$/,cn=/^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,co,cp=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]],cq;f.fn.extend({show:function(a,b,c){var d,e;if(a||a===0)return this.animate(ct("show",3),a,b,c);for(var g=0,h=this.length;g<h;g++)d=this[g],d.style&&(e=d.style.display,!f._data(d,"olddisplay")&&e==="none"&&(e=d.style.display=""),(e===""&&f.css(d,"display")==="none"||!f.contains(d.ownerDocument.documentElement,d))&&f._data(d,"olddisplay",cu(d.nodeName)));for(g=0;g<h;g++){d=this[g];if(d.style){e=d.style.display;if(e===""||e==="none")d.style.display=f._data(d,"olddisplay")||""}}return this},hide:function(a,b,c){if(a||a===0)return this.animate(ct("hide",3),a,b,c);var d,e,g=0,h=this.length;for(;g<h;g++)d=this[g],d.style&&(e=f.css(d,"display"),e!=="none"&&!f._data(d,"olddisplay")&&f._data(d,"olddisplay",e));for(g=0;g<h;g++)this[g].style&&(this[g].style.display="none");return this},_toggle:f.fn.toggle,toggle:function(a,b,c){var d=typeof a=="boolean";f.isFunction(a)&&f.isFunction(b)?this._toggle.apply(this,arguments):a==null||d?this.each(function(){var b=d?a:f(this).is(":hidden");f(this)[b?"show":"hide"]()}):this.animate(ct("toggle",3),a,b,c);return this},fadeTo:function(a,b,c,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){function g(){e.queue===!1&&f._mark(this);var b=f.extend({},e),c=this.nodeType===1,d=c&&f(this).is(":hidden"),g,h,i,j,k,l,m,n,o,p,q;b.animatedProperties={};for(i in a){g=f.camelCase(i),i!==g&&(a[g]=a[i],delete a[i]);if((k=f.cssHooks[g])&&"expand"in k){l=k.expand(a[g]),delete a[g];for(i in l)i in a||(a[i]=l[i])}}for(g in a){h=a[g],f.isArray(h)?(b.animatedProperties[g]=h[1],h=a[g]=h[0]):b.animatedProperties[g]=b.specialEasing&&b.specialEasing[g]||b.easing||"swing";if(h==="hide"&&d||h==="show"&&!d)return b.complete.call(this);c&&(g==="height"||g==="width")&&(b.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY],f.css(this,"display")==="inline"&&f.css(this,"float")==="none"&&(!f.support.inlineBlockNeedsLayout||cu(this.nodeName)==="inline"?this.style.display="inline-block":this.style.zoom=1))}b.overflow!=null&&(this.style.overflow="hidden");for(i in a)j=new f.fx(this,b,i),h=a[i],cm.test(h)?(q=f._data(this,"toggle"+i)||(h==="toggle"?d?"show":"hide":0),q?(f._data(this,"toggle"+i,q==="show"?"hide":"show"),j[q]()):j[h]()):(m=cn.exec(h),n=j.cur(),m?(o=parseFloat(m[2]),p=m[3]||(f.cssNumber[i]?"":"px"),p!=="px"&&(f.style(this,i,(o||1)+p),n=(o||1)/j.cur()*n,f.style(this,i,n+p)),m[1]&&(o=(m[1]==="-="?-1:1)*o+n),j.custom(n,o,p)):j.custom(n,h,""));return!0}var e=f.speed(b,c,d);if(f.isEmptyObject(a))return this.each(e.complete,[!1]);a=f.extend({},a);return e.queue===!1?this.each(g):this.queue(e.queue,g)},stop:function(a,c,d){typeof a!="string"&&(d=c,c=a,a=b),c&&a!==!1&&this.queue(a||"fx",[]);return this.each(function(){function h(a,b,c){var e=b[c];f.removeData(a,c,!0),e.stop(d)}var b,c=!1,e=f.timers,g=f._data(this);d||f._unmark(!0,this);if(a==null)for(b in g)g[b]&&g[b].stop&&b.indexOf(".run")===b.length-4&&h(this,g,b);else g[b=a+".run"]&&g[b].stop&&h(this,g,b);for(b=e.length;b--;)e[b].elem===this&&(a==null||e[b].queue===a)&&(d?e[b](!0):e[b].saveState(),c=!0,e.splice(b,1));(!d||!c)&&f.dequeue(this,a)})}}),f.each({slideDown:ct("show",1),slideUp:ct("hide",1),slideToggle:ct("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){f.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),f.extend({speed:function(a,b,c){var d=a&&typeof a=="object"?f.extend({},a):{complete:c||!c&&b||f.isFunction(a)&&a,duration:a,easing:c&&b||b&&!f.isFunction(b)&&b};d.duration=f.fx.off?0:typeof d.duration=="number"?d.duration:d.duration in f.fx.speeds?f.fx.speeds[d.duration]:f.fx.speeds._default;if(d.queue==null||d.queue===!0)d.queue="fx";d.old=d.complete,d.complete=function(a){f.isFunction(d.old)&&d.old.call(this),d.queue?f.dequeue(this,d.queue):a!==!1&&f._unmark(this)};return d},easing:{linear:function(a){return a},swing:function(a){return-Math.cos(a*Math.PI)/2+.5}},timers:[],fx:function(a,b,c){this.options=b,this.elem=a,this.prop=c,b.orig=b.orig||{}}}),f.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this),(f.fx.step[this.prop]||f.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a,b=f.css(this.elem,this.prop);return isNaN(a=parseFloat(b))?!b||b==="auto"?0:b:a},custom:function(a,c,d){function h(a){return e.step(a)}var e=this,g=f.fx;this.startTime=cq||cr(),this.end=c,this.now=this.start=a,this.pos=this.state=0,this.unit=d||this.unit||(f.cssNumber[this.prop]?"":"px"),h.queue=this.options.queue,h.elem=this.elem,h.saveState=function(){f._data(e.elem,"fxshow"+e.prop)===b&&(e.options.hide?f._data(e.elem,"fxshow"+e.prop,e.start):e.options.show&&f._data(e.elem,"fxshow"+e.prop,e.end))},h()&&f.timers.push(h)&&!co&&(co=setInterval(g.tick,g.interval))},show:function(){var a=f._data(this.elem,"fxshow"+this.prop);this.options.orig[this.prop]=a||f.style(this.elem,this.prop),this.options.show=!0,a!==b?this.custom(this.cur(),a):this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur()),f(this.elem).show()},hide:function(){this.options.orig[this.prop]=f._data(this.elem,"fxshow"+this.prop)||f.style(this.elem,this.prop),this.options.hide=!0,this.custom(this.cur(),0)},step:function(a){var b,c,d,e=cq||cr(),g=!0,h=this.elem,i=this.options;if(a||e>=i.duration+this.startTime){this.now=this.end,this.pos=this.state=1,this.update(),i.animatedProperties[this.prop]=!0;for(b in i.animatedProperties)i.animatedProperties[b]!==!0&&(g=!1);if(g){i.overflow!=null&&!f.support.shrinkWrapBlocks&&f.each(["","X","Y"],function(a,b){h.style["overflow"+b]=i.overflow[a]}),i.hide&&f(h).hide();if(i.hide||i.show)for(b in i.animatedProperties)f.style(h,b,i.orig[b]),f.removeData(h,"fxshow"+b,!0),f.removeData(h,"toggle"+b,!0);d=i.complete,d&&(i.complete=!1,d.call(h))}return!1}i.duration==Infinity?this.now=e:(c=e-this.startTime,this.state=c/i.duration,this.pos=f.easing[i.animatedProperties[this.prop]](this.state,c,0,1,i.duration),this.now=this.start+(this.end-this.start)*this.pos),this.update();return!0}},f.extend(f.fx,{tick:function(){var a,b=f.timers,c=0;for(;c<b.length;c++)a=b[c],!a()&&b[c]===a&&b.splice(c--,1);b.length||f.fx.stop()},interval:13,stop:function(){clearInterval(co),co=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){f.style(a.elem,"opacity",a.now)},_default:function(a){a.elem.style&&a.elem.style[a.prop]!=null?a.elem.style[a.prop]=a.now+a.unit:a.elem[a.prop]=a.now}}}),f.each(cp.concat.apply([],cp),function(a,b){b.indexOf("margin")&&(f.fx.step[b]=function(a){f.style(a.elem,b,Math.max(0,a.now)+a.unit)})}),f.expr&&f.expr.filters&&(f.expr.filters.animated=function(a){return f.grep(f.timers,function(b){return a===b.elem}).length});var cv,cw=/^t(?:able|d|h)$/i,cx=/^(?:body|html)$/i;"getBoundingClientRect"in c.documentElement?cv=function(a,b,c,d){try{d=a.getBoundingClientRect()}catch(e){}if(!d||!f.contains(c,a))return d?{top:d.top,left:d.left}:{top:0,left:0};var g=b.body,h=cy(b),i=c.clientTop||g.clientTop||0,j=c.clientLeft||g.clientLeft||0,k=h.pageYOffset||f.support.boxModel&&c.scrollTop||g.scrollTop,l=h.pageXOffset||f.support.boxModel&&c.scrollLeft||g.scrollLeft,m=d.top+k-i,n=d.left+l-j;return{top:m,left:n}}:cv=function(a,b,c){var d,e=a.offsetParent,g=a,h=b.body,i=b.defaultView,j=i?i.getComputedStyle(a,null):a.currentStyle,k=a.offsetTop,l=a.offsetLeft;while((a=a.parentNode)&&a!==h&&a!==c){if(f.support.fixedPosition&&j.position==="fixed")break;d=i?i.getComputedStyle(a,null):a.currentStyle,k-=a.scrollTop,l-=a.scrollLeft,a===e&&(k+=a.offsetTop,l+=a.offsetLeft,f.support.doesNotAddBorder&&(!f.support.doesAddBorderForTableAndCells||!cw.test(a.nodeName))&&(k+=parseFloat(d.borderTopWidth)||0,l+=parseFloat(d.borderLeftWidth)||0),g=e,e=a.offsetParent),f.support.subtractsBorderForOverflowNotVisible&&d.overflow!=="visible"&&(k+=parseFloat(d.borderTopWidth)||0,l+=parseFloat(d.borderLeftWidth)||0),j=d}if(j.position==="relative"||j.position==="static")k+=h.offsetTop,l+=h.offsetLeft;f.support.fixedPosition&&j.position==="fixed"&&(k+=Math.max(c.scrollTop,h.scrollTop),l+=Math.max(c.scrollLeft,h.scrollLeft));return{top:k,left:l}},f.fn.offset=function(a){if(arguments.length)return a===b?this:this.each(function(b){f.offset.setOffset(this,a,b)});var c=this[0],d=c&&c.ownerDocument;if(!d)return null;if(c===d.body)return f.offset.bodyOffset(c);return cv(c,d,d.documentElement)},f.offset={bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;f.support.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(f.css(a,"marginTop"))||0,c+=parseFloat(f.css(a,"marginLeft"))||0);return{top:b,left:c}},setOffset:function(a,b,c){var d=f.css(a,"position");d==="static"&&(a.style.position="relative");var e=f(a),g=e.offset(),h=f.css(a,"top"),i=f.css(a,"left"),j=(d==="absolute"||d==="fixed")&&f.inArray("auto",[h,i])>-1,k={},l={},m,n;j?(l=e.position(),m=l.top,n=l.left):(m=parseFloat(h)||0,n=parseFloat(i)||0),f.isFunction(b)&&(b=b.call(a,c,g)),b.top!=null&&(k.top=b.top-g.top+m),b.left!=null&&(k.left=b.left-g.left+n),"using"in b?b.using.call(a,k):e.css(k)}},f.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),c=this.offset(),d=cx.test(b[0].nodeName)?{top:0,left:0}:b.offset();c.top-=parseFloat(f.css(a,"marginTop"))||0,c.left-=parseFloat(f.css(a,"marginLeft"))||0,d.top+=parseFloat(f.css(b[0],"borderTopWidth"))||0,d.left+=parseFloat(f.css(b[0],"borderLeftWidth"))||0;return{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||c.body;while(a&&!cx.test(a.nodeName)&&f.css(a,"position")==="static")a=a.offsetParent;return a})}}),f.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,c){var d=/Y/.test(c);f.fn[a]=function(e){return f.access(this,function(a,e,g){var h=cy(a);if(g===b)return h?c in h?h[c]:f.support.boxModel&&h.document.documentElement[e]||h.document.body[e]:a[e];h?h.scrollTo(d?f(h).scrollLeft():g,d?g:f(h).scrollTop()):a[e]=g},a,e,arguments.length,null)}}),f.each({Height:"height",Width:"width"},function(a,c){var d="client"+a,e="scroll"+a,g="offset"+a;f.fn["inner"+a]=function(){var a=this[0];return a?a.style?parseFloat(f.css(a,c,"padding")):this[c]():null},f.fn["outer"+a]=function(a){var b=this[0];return b?b.style?parseFloat(f.css(b,c,a?"margin":"border")):this[c]():null},f.fn[c]=function(a){return f.access(this,function(a,c,h){var i,j,k,l;if(f.isWindow(a)){i=a.document,j=i.documentElement[d];return f.support.boxModel&&j||i.body&&i.body[d]||j}if(a.nodeType===9){i=a.documentElement;if(i[d]>=i[e])return i[d];return Math.max(a.body[e],i[e],a.body[g],i[g])}if(h===b){k=f.css(a,c),l=parseFloat(k);return f.isNumeric(l)?l:k}f(a).css(c,h)},c,a,arguments.length,null)}}),a.jQuery=a.$=f,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return f})})(window);/*!
 * jQuery Cookie Plugin v1.4.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2006, 2014 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD (Register as an anonymous module)
		define(['jquery'], factory);
	} else if (typeof exports === 'object') {
		// Node/CommonJS
		module.exports = factory(require('jquery'));
	} else {
		// Browser globals
		factory(jQuery);
	}
}(function ($) {

	var pluses = /\+/g;

	function encode(s) {
		return config.raw ? s : encodeURIComponent(s);
	}

	function decode(s) {
		return config.raw ? s : decodeURIComponent(s);
	}

	function stringifyCookieValue(value) {
		return encode(config.json ? JSON.stringify(value) : String(value));
	}

	function parseCookieValue(s) {
		if (s.indexOf('"') === 0) {
			// This is a quoted cookie as according to RFC2068, unescape...
			s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
		}

		try {
			// Replace server-side written pluses with spaces.
			// If we can't decode the cookie, ignore it, it's unusable.
			// If we can't parse the cookie, ignore it, it's unusable.
			s = decodeURIComponent(s.replace(pluses, ' '));
			return config.json ? JSON.parse(s) : s;
		} catch(e) {}
	}

	function read(s, converter) {
		var value = config.raw ? s : parseCookieValue(s);
		return $.isFunction(converter) ? converter(value) : value;
	}

	var config = $.cookie = function (key, value, options) {

		// Write

		if (arguments.length > 1 && !$.isFunction(value)) {
			options = $.extend({}, config.defaults, options);

			if (typeof options.expires === 'number') {
				var days = options.expires, t = options.expires = new Date();
				t.setMilliseconds(t.getMilliseconds() + days * 864e+5);
			}

			return (document.cookie = [
				encode(key), '=', stringifyCookieValue(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path    ? '; path=' + options.path : '',
				options.domain  ? '; domain=' + options.domain : '',
				options.secure  ? '; secure' : ''
			].join(''));
		}

		// Read

		var result = key ? undefined : {},
			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all. Also prevents odd result when
			// calling $.cookie().
			cookies = document.cookie ? document.cookie.split('; ') : [],
			i = 0,
			l = cookies.length;

		for (; i < l; i++) {
			var parts = cookies[i].split('='),
				name = decode(parts.shift()),
				cookie = parts.join('=');

			if (key === name) {
				// If second argument (value) is a function it's a converter...
				result = read(cookie, value);
				break;
			}

			// Prevent storing a cookie that we couldn't decode.
			if (!key && (cookie = read(cookie)) !== undefined) {
				result[name] = cookie;
			}
		}

		return result;
	};

	config.defaults = {};

	$.removeCookie = function (key, options) {
		// Must not alter options, thus extending a fresh object...
		$.cookie(key, '', $.extend({}, options, { expires: -1 }));
		return !$.cookie(key);
	};

}));
/*! jQuery UI - v1.9.2 - 2014-08-06
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.position.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js
* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */

(function(e,t){function i(t,i){var a,n,o,r=t.nodeName.toLowerCase();return"area"===r?(a=t.parentNode,n=a.name,t.href&&n&&"map"===a.nodeName.toLowerCase()?(o=e("img[usemap=#"+n+"]")[0],!!o&&s(o)):!1):(/input|select|textarea|button|object/.test(r)?!t.disabled:"a"===r?t.href||i:i)&&s(t)}function s(t){return e.expr.filters.visible(t)&&!e(t).parents().andSelf().filter(function(){return"hidden"===e.css(this,"visibility")}).length}var a=0,n=/^ui-id-\d+$/;e.ui=e.ui||{},e.ui.version||(e.extend(e.ui,{version:"1.9.2",keyCode:{BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}}),e.fn.extend({_focus:e.fn.focus,focus:function(t,i){return"number"==typeof t?this.each(function(){var s=this;setTimeout(function(){e(s).focus(),i&&i.call(s)},t)}):this._focus.apply(this,arguments)},scrollParent:function(){var t;return t=e.ui.ie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?this.parents().filter(function(){return/(relative|absolute|fixed)/.test(e.css(this,"position"))&&/(auto|scroll)/.test(e.css(this,"overflow")+e.css(this,"overflow-y")+e.css(this,"overflow-x"))}).eq(0):this.parents().filter(function(){return/(auto|scroll)/.test(e.css(this,"overflow")+e.css(this,"overflow-y")+e.css(this,"overflow-x"))}).eq(0),/fixed/.test(this.css("position"))||!t.length?e(document):t},zIndex:function(i){if(i!==t)return this.css("zIndex",i);if(this.length)for(var s,a,n=e(this[0]);n.length&&n[0]!==document;){if(s=n.css("position"),("absolute"===s||"relative"===s||"fixed"===s)&&(a=parseInt(n.css("zIndex"),10),!isNaN(a)&&0!==a))return a;n=n.parent()}return 0},uniqueId:function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++a)})},removeUniqueId:function(){return this.each(function(){n.test(this.id)&&e(this).removeAttr("id")})}}),e.extend(e.expr[":"],{data:e.expr.createPseudo?e.expr.createPseudo(function(t){return function(i){return!!e.data(i,t)}}):function(t,i,s){return!!e.data(t,s[3])},focusable:function(t){return i(t,!isNaN(e.attr(t,"tabindex")))},tabbable:function(t){var s=e.attr(t,"tabindex"),a=isNaN(s);return(a||s>=0)&&i(t,!a)}}),e(function(){var t=document.body,i=t.appendChild(i=document.createElement("div"));i.offsetHeight,e.extend(i.style,{minHeight:"100px",height:"auto",padding:0,borderWidth:0}),e.support.minHeight=100===i.offsetHeight,e.support.selectstart="onselectstart"in i,t.removeChild(i).style.display="none"}),e("<a>").outerWidth(1).jquery||e.each(["Width","Height"],function(i,s){function a(t,i,s,a){return e.each(n,function(){i-=parseFloat(e.css(t,"padding"+this))||0,s&&(i-=parseFloat(e.css(t,"border"+this+"Width"))||0),a&&(i-=parseFloat(e.css(t,"margin"+this))||0)}),i}var n="Width"===s?["Left","Right"]:["Top","Bottom"],o=s.toLowerCase(),r={innerWidth:e.fn.innerWidth,innerHeight:e.fn.innerHeight,outerWidth:e.fn.outerWidth,outerHeight:e.fn.outerHeight};e.fn["inner"+s]=function(i){return i===t?r["inner"+s].call(this):this.each(function(){e(this).css(o,a(this,i)+"px")})},e.fn["outer"+s]=function(t,i){return"number"!=typeof t?r["outer"+s].call(this,t):this.each(function(){e(this).css(o,a(this,t,!0,i)+"px")})}}),e("<a>").data("a-b","a").removeData("a-b").data("a-b")&&(e.fn.removeData=function(t){return function(i){return arguments.length?t.call(this,e.camelCase(i)):t.call(this)}}(e.fn.removeData)),function(){var t=/msie ([\w.]+)/.exec(navigator.userAgent.toLowerCase())||[];e.ui.ie=t.length?!0:!1,e.ui.ie6=6===parseFloat(t[1],10)}(),e.fn.extend({disableSelection:function(){return this.bind((e.support.selectstart?"selectstart":"mousedown")+".ui-disableSelection",function(e){e.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}}),e.extend(e.ui,{plugin:{add:function(t,i,s){var a,n=e.ui[t].prototype;for(a in s)n.plugins[a]=n.plugins[a]||[],n.plugins[a].push([i,s[a]])},call:function(e,t,i){var s,a=e.plugins[t];if(a&&e.element[0].parentNode&&11!==e.element[0].parentNode.nodeType)for(s=0;a.length>s;s++)e.options[a[s][0]]&&a[s][1].apply(e.element,i)}},contains:e.contains,hasScroll:function(t,i){if("hidden"===e(t).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",a=!1;return t[s]>0?!0:(t[s]=1,a=t[s]>0,t[s]=0,a)},isOverAxis:function(e,t,i){return e>t&&t+i>e},isOver:function(t,i,s,a,n,o){return e.ui.isOverAxis(t,s,n)&&e.ui.isOverAxis(i,a,o)}}))})(jQuery);(function(e,t){var i=0,s=Array.prototype.slice,a=e.cleanData;e.cleanData=function(t){for(var i,s=0;null!=(i=t[s]);s++)try{e(i).triggerHandler("remove")}catch(n){}a(t)},e.widget=function(i,s,a){var n,o,r,h,l=i.split(".")[0];i=i.split(".")[1],n=l+"-"+i,a||(a=s,s=e.Widget),e.expr[":"][n.toLowerCase()]=function(t){return!!e.data(t,n)},e[l]=e[l]||{},o=e[l][i],r=e[l][i]=function(e,i){return this._createWidget?(arguments.length&&this._createWidget(e,i),t):new r(e,i)},e.extend(r,o,{version:a.version,_proto:e.extend({},a),_childConstructors:[]}),h=new s,h.options=e.widget.extend({},h.options),e.each(a,function(t,i){e.isFunction(i)&&(a[t]=function(){var e=function(){return s.prototype[t].apply(this,arguments)},a=function(e){return s.prototype[t].apply(this,e)};return function(){var t,s=this._super,n=this._superApply;return this._super=e,this._superApply=a,t=i.apply(this,arguments),this._super=s,this._superApply=n,t}}())}),r.prototype=e.widget.extend(h,{widgetEventPrefix:o?h.widgetEventPrefix:i},a,{constructor:r,namespace:l,widgetName:i,widgetBaseClass:n,widgetFullName:n}),o?(e.each(o._childConstructors,function(t,i){var s=i.prototype;e.widget(s.namespace+"."+s.widgetName,r,i._proto)}),delete o._childConstructors):s._childConstructors.push(r),e.widget.bridge(i,r)},e.widget.extend=function(i){for(var a,n,o=s.call(arguments,1),r=0,h=o.length;h>r;r++)for(a in o[r])n=o[r][a],o[r].hasOwnProperty(a)&&n!==t&&(i[a]=e.isPlainObject(n)?e.isPlainObject(i[a])?e.widget.extend({},i[a],n):e.widget.extend({},n):n);return i},e.widget.bridge=function(i,a){var n=a.prototype.widgetFullName||i;e.fn[i]=function(o){var r="string"==typeof o,h=s.call(arguments,1),l=this;return o=!r&&h.length?e.widget.extend.apply(null,[o].concat(h)):o,r?this.each(function(){var s,a=e.data(this,n);return a?e.isFunction(a[o])&&"_"!==o.charAt(0)?(s=a[o].apply(a,h),s!==a&&s!==t?(l=s&&s.jquery?l.pushStack(s.get()):s,!1):t):e.error("no such method '"+o+"' for "+i+" widget instance"):e.error("cannot call methods on "+i+" prior to initialization; "+"attempted to call method '"+o+"'")}):this.each(function(){var t=e.data(this,n);t?t.option(o||{})._init():e.data(this,n,new a(o,this))}),l}},e.Widget=function(){},e.Widget._childConstructors=[],e.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{disabled:!1,create:null},_createWidget:function(t,s){s=e(s||this.defaultElement||this)[0],this.element=e(s),this.uuid=i++,this.eventNamespace="."+this.widgetName+this.uuid,this.options=e.widget.extend({},this.options,this._getCreateOptions(),t),this.bindings=e(),this.hoverable=e(),this.focusable=e(),s!==this&&(e.data(s,this.widgetName,this),e.data(s,this.widgetFullName,this),this._on(!0,this.element,{remove:function(e){e.target===s&&this.destroy()}}),this.document=e(s.style?s.ownerDocument:s.document||s),this.window=e(this.document[0].defaultView||this.document[0].parentWindow)),this._create(),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:e.noop,_getCreateEventData:e.noop,_create:e.noop,_init:e.noop,destroy:function(){this._destroy(),this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)),this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName+"-disabled "+"ui-state-disabled"),this.bindings.unbind(this.eventNamespace),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")},_destroy:e.noop,widget:function(){return this.element},option:function(i,s){var a,n,o,r=i;if(0===arguments.length)return e.widget.extend({},this.options);if("string"==typeof i)if(r={},a=i.split("."),i=a.shift(),a.length){for(n=r[i]=e.widget.extend({},this.options[i]),o=0;a.length-1>o;o++)n[a[o]]=n[a[o]]||{},n=n[a[o]];if(i=a.pop(),s===t)return n[i]===t?null:n[i];n[i]=s}else{if(s===t)return this.options[i]===t?null:this.options[i];r[i]=s}return this._setOptions(r),this},_setOptions:function(e){var t;for(t in e)this._setOption(t,e[t]);return this},_setOption:function(e,t){return this.options[e]=t,"disabled"===e&&(this.widget().toggleClass(this.widgetFullName+"-disabled ui-state-disabled",!!t).attr("aria-disabled",t),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")),this},enable:function(){return this._setOption("disabled",!1)},disable:function(){return this._setOption("disabled",!0)},_on:function(i,s,a){var n,o=this;"boolean"!=typeof i&&(a=s,s=i,i=!1),a?(s=n=e(s),this.bindings=this.bindings.add(s)):(a=s,s=this.element,n=this.widget()),e.each(a,function(a,r){function h(){return i||o.options.disabled!==!0&&!e(this).hasClass("ui-state-disabled")?("string"==typeof r?o[r]:r).apply(o,arguments):t}"string"!=typeof r&&(h.guid=r.guid=r.guid||h.guid||e.guid++);var l=a.match(/^(\w+)\s*(.*)$/),u=l[1]+o.eventNamespace,d=l[2];d?n.delegate(d,u,h):s.bind(u,h)})},_off:function(e,t){t=(t||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.unbind(t).undelegate(t)},_delay:function(e,t){function i(){return("string"==typeof e?s[e]:e).apply(s,arguments)}var s=this;return setTimeout(i,t||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){e(t.currentTarget).addClass("ui-state-hover")},mouseleave:function(t){e(t.currentTarget).removeClass("ui-state-hover")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){e(t.currentTarget).addClass("ui-state-focus")},focusout:function(t){e(t.currentTarget).removeClass("ui-state-focus")}})},_trigger:function(t,i,s){var a,n,o=this.options[t];if(s=s||{},i=e.Event(i),i.type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),i.target=this.element[0],n=i.originalEvent)for(a in n)a in i||(i[a]=n[a]);return this.element.trigger(i,s),!(e.isFunction(o)&&o.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},e.each({show:"fadeIn",hide:"fadeOut"},function(t,i){e.Widget.prototype["_"+t]=function(s,a,n){"string"==typeof a&&(a={effect:a});var o,r=a?a===!0||"number"==typeof a?i:a.effect||i:t;a=a||{},"number"==typeof a&&(a={duration:a}),o=!e.isEmptyObject(a),a.complete=n,a.delay&&s.delay(a.delay),o&&e.effects&&(e.effects.effect[r]||e.uiBackCompat!==!1&&e.effects[r])?s[t](a):r!==t&&s[r]?s[r](a.duration,a.easing,n):s.queue(function(i){e(this)[t](),n&&n.call(s[0]),i()})}}),e.uiBackCompat!==!1&&(e.Widget.prototype._getCreateOptions=function(){return e.metadata&&e.metadata.get(this.element[0])[this.widgetName]})})(jQuery);(function(e){var t=!1;e(document).mouseup(function(){t=!1}),e.widget("ui.mouse",{version:"1.9.2",options:{cancel:"input,textarea,button,select,option",distance:1,delay:0},_mouseInit:function(){var t=this;this.element.bind("mousedown."+this.widgetName,function(e){return t._mouseDown(e)}).bind("click."+this.widgetName,function(i){return!0===e.data(i.target,t.widgetName+".preventClickEvent")?(e.removeData(i.target,t.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):undefined}),this.started=!1},_mouseDestroy:function(){this.element.unbind("."+this.widgetName),this._mouseMoveDelegate&&e(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(i){if(!t){this._mouseStarted&&this._mouseUp(i),this._mouseDownEvent=i;var s=this,a=1===i.which,n="string"==typeof this.options.cancel&&i.target.nodeName?e(i.target).closest(this.options.cancel).length:!1;return a&&!n&&this._mouseCapture(i)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){s.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(i)&&this._mouseDelayMet(i)&&(this._mouseStarted=this._mouseStart(i)!==!1,!this._mouseStarted)?(i.preventDefault(),!0):(!0===e.data(i.target,this.widgetName+".preventClickEvent")&&e.removeData(i.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(e){return s._mouseMove(e)},this._mouseUpDelegate=function(e){return s._mouseUp(e)},e(document).bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate),i.preventDefault(),t=!0,!0)):!0}},_mouseMove:function(t){return!e.ui.ie||document.documentMode>=9||t.button?this._mouseStarted?(this._mouseDrag(t),t.preventDefault()):(this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,t)!==!1,this._mouseStarted?this._mouseDrag(t):this._mouseUp(t)),!this._mouseStarted):this._mouseUp(t)},_mouseUp:function(t){return e(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,t.target===this._mouseDownEvent.target&&e.data(t.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(t)),!1},_mouseDistanceMet:function(e){return Math.max(Math.abs(this._mouseDownEvent.pageX-e.pageX),Math.abs(this._mouseDownEvent.pageY-e.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}})})(jQuery);(function(e,t){function i(e,t,i){return[parseInt(e[0],10)*(c.test(e[0])?t/100:1),parseInt(e[1],10)*(c.test(e[1])?i/100:1)]}function s(t,i){return parseInt(e.css(t,i),10)||0}e.ui=e.ui||{};var a,n=Math.max,o=Math.abs,r=Math.round,h=/left|center|right/,l=/top|center|bottom/,u=/[\+\-]\d+%?/,d=/^\w+/,c=/%$/,p=e.fn.position;e.position={scrollbarWidth:function(){if(a!==t)return a;var i,s,n=e("<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),o=n.children()[0];return e("body").append(n),i=o.offsetWidth,n.css("overflow","scroll"),s=o.offsetWidth,i===s&&(s=n[0].clientWidth),n.remove(),a=i-s},getScrollInfo:function(t){var i=t.isWindow?"":t.element.css("overflow-x"),s=t.isWindow?"":t.element.css("overflow-y"),a="scroll"===i||"auto"===i&&t.width<t.element[0].scrollWidth,n="scroll"===s||"auto"===s&&t.height<t.element[0].scrollHeight;return{width:a?e.position.scrollbarWidth():0,height:n?e.position.scrollbarWidth():0}},getWithinInfo:function(t){var i=e(t||window),s=e.isWindow(i[0]);return{element:i,isWindow:s,offset:i.offset()||{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:s?i.width():i.outerWidth(),height:s?i.height():i.outerHeight()}}},e.fn.position=function(t){if(!t||!t.of)return p.apply(this,arguments);t=e.extend({},t);var a,c,f,m,g,v=e(t.of),y=e.position.getWithinInfo(t.within),b=e.position.getScrollInfo(y),_=v[0],x=(t.collision||"flip").split(" "),w={};return 9===_.nodeType?(c=v.width(),f=v.height(),m={top:0,left:0}):e.isWindow(_)?(c=v.width(),f=v.height(),m={top:v.scrollTop(),left:v.scrollLeft()}):_.preventDefault?(t.at="left top",c=f=0,m={top:_.pageY,left:_.pageX}):(c=v.outerWidth(),f=v.outerHeight(),m=v.offset()),g=e.extend({},m),e.each(["my","at"],function(){var e,i,s=(t[this]||"").split(" ");1===s.length&&(s=h.test(s[0])?s.concat(["center"]):l.test(s[0])?["center"].concat(s):["center","center"]),s[0]=h.test(s[0])?s[0]:"center",s[1]=l.test(s[1])?s[1]:"center",e=u.exec(s[0]),i=u.exec(s[1]),w[this]=[e?e[0]:0,i?i[0]:0],t[this]=[d.exec(s[0])[0],d.exec(s[1])[0]]}),1===x.length&&(x[1]=x[0]),"right"===t.at[0]?g.left+=c:"center"===t.at[0]&&(g.left+=c/2),"bottom"===t.at[1]?g.top+=f:"center"===t.at[1]&&(g.top+=f/2),a=i(w.at,c,f),g.left+=a[0],g.top+=a[1],this.each(function(){var h,l,u=e(this),d=u.outerWidth(),p=u.outerHeight(),_=s(this,"marginLeft"),k=s(this,"marginTop"),D=d+_+s(this,"marginRight")+b.width,T=p+k+s(this,"marginBottom")+b.height,S=e.extend({},g),M=i(w.my,u.outerWidth(),u.outerHeight());"right"===t.my[0]?S.left-=d:"center"===t.my[0]&&(S.left-=d/2),"bottom"===t.my[1]?S.top-=p:"center"===t.my[1]&&(S.top-=p/2),S.left+=M[0],S.top+=M[1],e.support.offsetFractions||(S.left=r(S.left),S.top=r(S.top)),h={marginLeft:_,marginTop:k},e.each(["left","top"],function(i,s){e.ui.position[x[i]]&&e.ui.position[x[i]][s](S,{targetWidth:c,targetHeight:f,elemWidth:d,elemHeight:p,collisionPosition:h,collisionWidth:D,collisionHeight:T,offset:[a[0]+M[0],a[1]+M[1]],my:t.my,at:t.at,within:y,elem:u})}),e.fn.bgiframe&&u.bgiframe(),t.using&&(l=function(e){var i=m.left-S.left,s=i+c-d,a=m.top-S.top,r=a+f-p,h={target:{element:v,left:m.left,top:m.top,width:c,height:f},element:{element:u,left:S.left,top:S.top,width:d,height:p},horizontal:0>s?"left":i>0?"right":"center",vertical:0>r?"top":a>0?"bottom":"middle"};d>c&&c>o(i+s)&&(h.horizontal="center"),p>f&&f>o(a+r)&&(h.vertical="middle"),h.important=n(o(i),o(s))>n(o(a),o(r))?"horizontal":"vertical",t.using.call(this,e,h)}),u.offset(e.extend(S,{using:l}))})},e.ui.position={fit:{left:function(e,t){var i,s=t.within,a=s.isWindow?s.scrollLeft:s.offset.left,o=s.width,r=e.left-t.collisionPosition.marginLeft,h=a-r,l=r+t.collisionWidth-o-a;t.collisionWidth>o?h>0&&0>=l?(i=e.left+h+t.collisionWidth-o-a,e.left+=h-i):e.left=l>0&&0>=h?a:h>l?a+o-t.collisionWidth:a:h>0?e.left+=h:l>0?e.left-=l:e.left=n(e.left-r,e.left)},top:function(e,t){var i,s=t.within,a=s.isWindow?s.scrollTop:s.offset.top,o=t.within.height,r=e.top-t.collisionPosition.marginTop,h=a-r,l=r+t.collisionHeight-o-a;t.collisionHeight>o?h>0&&0>=l?(i=e.top+h+t.collisionHeight-o-a,e.top+=h-i):e.top=l>0&&0>=h?a:h>l?a+o-t.collisionHeight:a:h>0?e.top+=h:l>0?e.top-=l:e.top=n(e.top-r,e.top)}},flip:{left:function(e,t){var i,s,a=t.within,n=a.offset.left+a.scrollLeft,r=a.width,h=a.isWindow?a.scrollLeft:a.offset.left,l=e.left-t.collisionPosition.marginLeft,u=l-h,d=l+t.collisionWidth-r-h,c="left"===t.my[0]?-t.elemWidth:"right"===t.my[0]?t.elemWidth:0,p="left"===t.at[0]?t.targetWidth:"right"===t.at[0]?-t.targetWidth:0,f=-2*t.offset[0];0>u?(i=e.left+c+p+f+t.collisionWidth-r-n,(0>i||o(u)>i)&&(e.left+=c+p+f)):d>0&&(s=e.left-t.collisionPosition.marginLeft+c+p+f-h,(s>0||d>o(s))&&(e.left+=c+p+f))},top:function(e,t){var i,s,a=t.within,n=a.offset.top+a.scrollTop,r=a.height,h=a.isWindow?a.scrollTop:a.offset.top,l=e.top-t.collisionPosition.marginTop,u=l-h,d=l+t.collisionHeight-r-h,c="top"===t.my[1],p=c?-t.elemHeight:"bottom"===t.my[1]?t.elemHeight:0,f="top"===t.at[1]?t.targetHeight:"bottom"===t.at[1]?-t.targetHeight:0,m=-2*t.offset[1];0>u?(s=e.top+p+f+m+t.collisionHeight-r-n,e.top+p+f+m>u&&(0>s||o(u)>s)&&(e.top+=p+f+m)):d>0&&(i=e.top-t.collisionPosition.marginTop+p+f+m-h,e.top+p+f+m>d&&(i>0||d>o(i))&&(e.top+=p+f+m))}},flipfit:{left:function(){e.ui.position.flip.left.apply(this,arguments),e.ui.position.fit.left.apply(this,arguments)},top:function(){e.ui.position.flip.top.apply(this,arguments),e.ui.position.fit.top.apply(this,arguments)}}},function(){var t,i,s,a,n,o=document.getElementsByTagName("body")[0],r=document.createElement("div");t=document.createElement(o?"div":"body"),s={visibility:"hidden",width:0,height:0,border:0,margin:0,background:"none"},o&&e.extend(s,{position:"absolute",left:"-1000px",top:"-1000px"});for(n in s)t.style[n]=s[n];t.appendChild(r),i=o||document.documentElement,i.insertBefore(t,i.firstChild),r.style.cssText="position: absolute; left: 10.7432222px;",a=e(r).offset().left,e.support.offsetFractions=a>10&&11>a,t.innerHTML="",i.removeChild(t)}(),e.uiBackCompat!==!1&&function(e){var i=e.fn.position;e.fn.position=function(s){if(!s||!s.offset)return i.call(this,s);var a=s.offset.split(" "),n=s.at.split(" ");return 1===a.length&&(a[1]=a[0]),/^\d/.test(a[0])&&(a[0]="+"+a[0]),/^\d/.test(a[1])&&(a[1]="+"+a[1]),1===n.length&&(/left|center|right/.test(n[0])?n[1]="center":(n[1]=n[0],n[0]="center")),i.call(this,e.extend(s,{at:n[0]+a[0]+" "+n[1]+a[1],offset:t}))}}(jQuery)})(jQuery);(function(e){e.widget("ui.draggable",e.ui.mouse,{version:"1.9.2",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1},_create:function(){"original"!=this.options.helper||/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative"),this.options.addClasses&&this.element.addClass("ui-draggable"),this.options.disabled&&this.element.addClass("ui-draggable-disabled"),this._mouseInit()},_destroy:function(){this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),this._mouseDestroy()},_mouseCapture:function(t){var i=this.options;return this.helper||i.disabled||e(t.target).is(".ui-resizable-handle")?!1:(this.handle=this._getHandle(t),this.handle?(e(i.iframeFix===!0?"iframe":i.iframeFix).each(function(){e('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>').css({width:this.offsetWidth+"px",height:this.offsetHeight+"px",position:"absolute",opacity:"0.001",zIndex:1e3}).css(e(this).offset()).appendTo("body")}),!0):!1)},_mouseStart:function(t){var i=this.options;return this.helper=this._createHelper(t),this.helper.addClass("ui-draggable-dragging"),this._cacheHelperProportions(),e.ui.ddmanager&&(e.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(),this.offset=this.positionAbs=this.element.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},e.extend(this.offset,{click:{left:t.pageX-this.offset.left,top:t.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.originalPosition=this.position=this._generatePosition(t),this.originalPageX=t.pageX,this.originalPageY=t.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),i.containment&&this._setContainment(),this._trigger("start",t)===!1?(this._clear(),!1):(this._cacheHelperProportions(),e.ui.ddmanager&&!i.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this._mouseDrag(t,!0),e.ui.ddmanager&&e.ui.ddmanager.dragStart(this,t),!0)},_mouseDrag:function(t,i){if(this.position=this._generatePosition(t),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",t,s)===!1)return this._mouseUp({}),!1;this.position=s.position}return this.options.axis&&"y"==this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"==this.options.axis||(this.helper[0].style.top=this.position.top+"px"),e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),!1},_mouseStop:function(t){var i=!1;e.ui.ddmanager&&!this.options.dropBehaviour&&(i=e.ui.ddmanager.drop(this,t)),this.dropped&&(i=this.dropped,this.dropped=!1);for(var s=this.element[0],a=!1;s&&(s=s.parentNode);)s==document&&(a=!0);if(!a&&"original"===this.options.helper)return!1;if("invalid"==this.options.revert&&!i||"valid"==this.options.revert&&i||this.options.revert===!0||e.isFunction(this.options.revert)&&this.options.revert.call(this.element,i)){var n=this;e(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){n._trigger("stop",t)!==!1&&n._clear()})}else this._trigger("stop",t)!==!1&&this._clear();return!1},_mouseUp:function(t){return e("div.ui-draggable-iframeFix").each(function(){this.parentNode.removeChild(this)}),e.ui.ddmanager&&e.ui.ddmanager.dragStop(this,t),e.ui.mouse.prototype._mouseUp.call(this,t)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear(),this},_getHandle:function(t){var i=this.options.handle&&e(this.options.handle,this.element).length?!1:!0;return e(this.options.handle,this.element).find("*").andSelf().each(function(){this==t.target&&(i=!0)}),i},_createHelper:function(t){var i=this.options,s=e.isFunction(i.helper)?e(i.helper.apply(this.element[0],[t])):"clone"==i.helper?this.element.clone().removeAttr("id"):this.element;return s.parents("body").length||s.appendTo("parent"==i.appendTo?this.element[0].parentNode:i.appendTo),s[0]==this.element[0]||/(fixed|absolute)/.test(s.css("position"))||s.css("position","absolute"),s},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var t=this.offsetParent.offset();return"absolute"==this.cssPosition&&this.scrollParent[0]!=document&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&"html"==this.offsetParent[0].tagName.toLowerCase()&&e.ui.ie)&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"==this.cssPosition){var e=this.element.position();return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:e.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t=this.options;if("parent"==t.containment&&(t.containment=this.helper[0].parentNode),("document"==t.containment||"window"==t.containment)&&(this.containment=["document"==t.containment?0:e(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,"document"==t.containment?0:e(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,("document"==t.containment?0:e(window).scrollLeft())+e("document"==t.containment?document:window).width()-this.helperProportions.width-this.margins.left,("document"==t.containment?0:e(window).scrollTop())+(e("document"==t.containment?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(t.containment)||t.containment.constructor==Array)t.containment.constructor==Array&&(this.containment=t.containment);else{var i=e(t.containment),s=i[0];if(!s)return;i.offset();var a="hidden"!=e(s).css("overflow");this.containment=[(parseInt(e(s).css("borderLeftWidth"),10)||0)+(parseInt(e(s).css("paddingLeft"),10)||0),(parseInt(e(s).css("borderTopWidth"),10)||0)+(parseInt(e(s).css("paddingTop"),10)||0),(a?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(e(s).css("borderLeftWidth"),10)||0)-(parseInt(e(s).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(a?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(e(s).css("borderTopWidth"),10)||0)-(parseInt(e(s).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relative_container=i}},_convertPositionTo:function(t,i){i||(i=this.position);var s="absolute"==t?1:-1,a=(this.options,"absolute"!=this.cssPosition||this.scrollParent[0]!=document&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent),n=/(html|body)/i.test(a[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"==this.cssPosition?-this.scrollParent.scrollTop():n?0:a.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"==this.cssPosition?-this.scrollParent.scrollLeft():n?0:a.scrollLeft())*s}},_generatePosition:function(t){var i=this.options,s="absolute"!=this.cssPosition||this.scrollParent[0]!=document&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,a=/(html|body)/i.test(s[0].tagName),n=t.pageX,o=t.pageY;if(this.originalPosition){var r;if(this.containment){if(this.relative_container){var h=this.relative_container.offset();r=[this.containment[0]+h.left,this.containment[1]+h.top,this.containment[2]+h.left,this.containment[3]+h.top]}else r=this.containment;t.pageX-this.offset.click.left<r[0]&&(n=r[0]+this.offset.click.left),t.pageY-this.offset.click.top<r[1]&&(o=r[1]+this.offset.click.top),t.pageX-this.offset.click.left>r[2]&&(n=r[2]+this.offset.click.left),t.pageY-this.offset.click.top>r[3]&&(o=r[3]+this.offset.click.top)}if(i.grid){var l=i.grid[1]?this.originalPageY+Math.round((o-this.originalPageY)/i.grid[1])*i.grid[1]:this.originalPageY;o=r?l-this.offset.click.top<r[1]||l-this.offset.click.top>r[3]?l-this.offset.click.top<r[1]?l+i.grid[1]:l-i.grid[1]:l:l;var u=i.grid[0]?this.originalPageX+Math.round((n-this.originalPageX)/i.grid[0])*i.grid[0]:this.originalPageX;n=r?u-this.offset.click.left<r[0]||u-this.offset.click.left>r[2]?u-this.offset.click.left<r[0]?u+i.grid[0]:u-i.grid[0]:u:u}}return{top:o-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"==this.cssPosition?-this.scrollParent.scrollTop():a?0:s.scrollTop()),left:n-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"==this.cssPosition?-this.scrollParent.scrollLeft():a?0:s.scrollLeft())}},_clear:function(){this.helper.removeClass("ui-draggable-dragging"),this.helper[0]==this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1},_trigger:function(t,i,s){return s=s||this._uiHash(),e.ui.plugin.call(this,t,[i,s]),"drag"==t&&(this.positionAbs=this._convertPositionTo("absolute")),e.Widget.prototype._trigger.call(this,t,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),e.ui.plugin.add("draggable","connectToSortable",{start:function(t,i){var s=e(this).data("draggable"),a=s.options,n=e.extend({},i,{item:s.element});s.sortables=[],e(a.connectToSortable).each(function(){var i=e.data(this,"sortable");i&&!i.options.disabled&&(s.sortables.push({instance:i,shouldRevert:i.options.revert}),i.refreshPositions(),i._trigger("activate",t,n))})},stop:function(t,i){var s=e(this).data("draggable"),a=e.extend({},i,{item:s.element});e.each(s.sortables,function(){this.instance.isOver?(this.instance.isOver=0,s.cancelHelperRemoval=!0,this.instance.cancelHelperRemoval=!1,this.shouldRevert&&(this.instance.options.revert=!0),this.instance._mouseStop(t),this.instance.options.helper=this.instance.options._helper,"original"==s.options.helper&&this.instance.currentItem.css({top:"auto",left:"auto"})):(this.instance.cancelHelperRemoval=!1,this.instance._trigger("deactivate",t,a))})},drag:function(t,i){var s=e(this).data("draggable"),a=this;e.each(s.sortables,function(){var n=!1,o=this;this.instance.positionAbs=s.positionAbs,this.instance.helperProportions=s.helperProportions,this.instance.offset.click=s.offset.click,this.instance._intersectsWith(this.instance.containerCache)&&(n=!0,e.each(s.sortables,function(){return this.instance.positionAbs=s.positionAbs,this.instance.helperProportions=s.helperProportions,this.instance.offset.click=s.offset.click,this!=o&&this.instance._intersectsWith(this.instance.containerCache)&&e.ui.contains(o.instance.element[0],this.instance.element[0])&&(n=!1),n})),n?(this.instance.isOver||(this.instance.isOver=1,this.instance.currentItem=e(a).clone().removeAttr("id").appendTo(this.instance.element).data("sortable-item",!0),this.instance.options._helper=this.instance.options.helper,this.instance.options.helper=function(){return i.helper[0]},t.target=this.instance.currentItem[0],this.instance._mouseCapture(t,!0),this.instance._mouseStart(t,!0,!0),this.instance.offset.click.top=s.offset.click.top,this.instance.offset.click.left=s.offset.click.left,this.instance.offset.parent.left-=s.offset.parent.left-this.instance.offset.parent.left,this.instance.offset.parent.top-=s.offset.parent.top-this.instance.offset.parent.top,s._trigger("toSortable",t),s.dropped=this.instance.element,s.currentItem=s.element,this.instance.fromOutside=s),this.instance.currentItem&&this.instance._mouseDrag(t)):this.instance.isOver&&(this.instance.isOver=0,this.instance.cancelHelperRemoval=!0,this.instance.options.revert=!1,this.instance._trigger("out",t,this.instance._uiHash(this.instance)),this.instance._mouseStop(t,!0),this.instance.options.helper=this.instance.options._helper,this.instance.currentItem.remove(),this.instance.placeholder&&this.instance.placeholder.remove(),s._trigger("fromSortable",t),s.dropped=!1)})}}),e.ui.plugin.add("draggable","cursor",{start:function(){var t=e("body"),i=e(this).data("draggable").options;t.css("cursor")&&(i._cursor=t.css("cursor")),t.css("cursor",i.cursor)},stop:function(){var t=e(this).data("draggable").options;t._cursor&&e("body").css("cursor",t._cursor)}}),e.ui.plugin.add("draggable","opacity",{start:function(t,i){var s=e(i.helper),a=e(this).data("draggable").options;s.css("opacity")&&(a._opacity=s.css("opacity")),s.css("opacity",a.opacity)},stop:function(t,i){var s=e(this).data("draggable").options;s._opacity&&e(i.helper).css("opacity",s._opacity)}}),e.ui.plugin.add("draggable","scroll",{start:function(){var t=e(this).data("draggable");t.scrollParent[0]!=document&&"HTML"!=t.scrollParent[0].tagName&&(t.overflowOffset=t.scrollParent.offset())},drag:function(t){var i=e(this).data("draggable"),s=i.options,a=!1;i.scrollParent[0]!=document&&"HTML"!=i.scrollParent[0].tagName?(s.axis&&"x"==s.axis||(i.overflowOffset.top+i.scrollParent[0].offsetHeight-t.pageY<s.scrollSensitivity?i.scrollParent[0].scrollTop=a=i.scrollParent[0].scrollTop+s.scrollSpeed:t.pageY-i.overflowOffset.top<s.scrollSensitivity&&(i.scrollParent[0].scrollTop=a=i.scrollParent[0].scrollTop-s.scrollSpeed)),s.axis&&"y"==s.axis||(i.overflowOffset.left+i.scrollParent[0].offsetWidth-t.pageX<s.scrollSensitivity?i.scrollParent[0].scrollLeft=a=i.scrollParent[0].scrollLeft+s.scrollSpeed:t.pageX-i.overflowOffset.left<s.scrollSensitivity&&(i.scrollParent[0].scrollLeft=a=i.scrollParent[0].scrollLeft-s.scrollSpeed))):(s.axis&&"x"==s.axis||(t.pageY-e(document).scrollTop()<s.scrollSensitivity?a=e(document).scrollTop(e(document).scrollTop()-s.scrollSpeed):e(window).height()-(t.pageY-e(document).scrollTop())<s.scrollSensitivity&&(a=e(document).scrollTop(e(document).scrollTop()+s.scrollSpeed))),s.axis&&"y"==s.axis||(t.pageX-e(document).scrollLeft()<s.scrollSensitivity?a=e(document).scrollLeft(e(document).scrollLeft()-s.scrollSpeed):e(window).width()-(t.pageX-e(document).scrollLeft())<s.scrollSensitivity&&(a=e(document).scrollLeft(e(document).scrollLeft()+s.scrollSpeed)))),a!==!1&&e.ui.ddmanager&&!s.dropBehaviour&&e.ui.ddmanager.prepareOffsets(i,t)}}),e.ui.plugin.add("draggable","snap",{start:function(){var t=e(this).data("draggable"),i=t.options;t.snapElements=[],e(i.snap.constructor!=String?i.snap.items||":data(draggable)":i.snap).each(function(){var i=e(this),s=i.offset();this!=t.element[0]&&t.snapElements.push({item:this,width:i.outerWidth(),height:i.outerHeight(),top:s.top,left:s.left})})},drag:function(t,i){for(var s=e(this).data("draggable"),a=s.options,n=a.snapTolerance,o=i.offset.left,r=o+s.helperProportions.width,h=i.offset.top,l=h+s.helperProportions.height,u=s.snapElements.length-1;u>=0;u--){var d=s.snapElements[u].left,c=d+s.snapElements[u].width,p=s.snapElements[u].top,f=p+s.snapElements[u].height;if(o>d-n&&c+n>o&&h>p-n&&f+n>h||o>d-n&&c+n>o&&l>p-n&&f+n>l||r>d-n&&c+n>r&&h>p-n&&f+n>h||r>d-n&&c+n>r&&l>p-n&&f+n>l){if("inner"!=a.snapMode){var m=n>=Math.abs(p-l),g=n>=Math.abs(f-h),v=n>=Math.abs(d-r),y=n>=Math.abs(c-o);m&&(i.position.top=s._convertPositionTo("relative",{top:p-s.helperProportions.height,left:0}).top-s.margins.top),g&&(i.position.top=s._convertPositionTo("relative",{top:f,left:0}).top-s.margins.top),v&&(i.position.left=s._convertPositionTo("relative",{top:0,left:d-s.helperProportions.width}).left-s.margins.left),y&&(i.position.left=s._convertPositionTo("relative",{top:0,left:c}).left-s.margins.left)}var b=m||g||v||y;if("outer"!=a.snapMode){var m=n>=Math.abs(p-h),g=n>=Math.abs(f-l),v=n>=Math.abs(d-o),y=n>=Math.abs(c-r);m&&(i.position.top=s._convertPositionTo("relative",{top:p,left:0}).top-s.margins.top),g&&(i.position.top=s._convertPositionTo("relative",{top:f-s.helperProportions.height,left:0}).top-s.margins.top),v&&(i.position.left=s._convertPositionTo("relative",{top:0,left:d}).left-s.margins.left),y&&(i.position.left=s._convertPositionTo("relative",{top:0,left:c-s.helperProportions.width}).left-s.margins.left)}!s.snapElements[u].snapping&&(m||g||v||y||b)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,t,e.extend(s._uiHash(),{snapItem:s.snapElements[u].item})),s.snapElements[u].snapping=m||g||v||y||b}else s.snapElements[u].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,t,e.extend(s._uiHash(),{snapItem:s.snapElements[u].item})),s.snapElements[u].snapping=!1}}}),e.ui.plugin.add("draggable","stack",{start:function(){var t=e(this).data("draggable").options,i=e.makeArray(e(t.stack)).sort(function(t,i){return(parseInt(e(t).css("zIndex"),10)||0)-(parseInt(e(i).css("zIndex"),10)||0)});if(i.length){var s=parseInt(i[0].style.zIndex)||0;e(i).each(function(e){this.style.zIndex=s+e}),this[0].style.zIndex=s+i.length}}}),e.ui.plugin.add("draggable","zIndex",{start:function(t,i){var s=e(i.helper),a=e(this).data("draggable").options;s.css("zIndex")&&(a._zIndex=s.css("zIndex")),s.css("zIndex",a.zIndex)},stop:function(t,i){var s=e(this).data("draggable").options;s._zIndex&&e(i.helper).css("zIndex",s._zIndex)}})})(jQuery);(function(e){e.widget("ui.droppable",{version:"1.9.2",widgetEventPrefix:"drop",options:{accept:"*",activeClass:!1,addClasses:!0,greedy:!1,hoverClass:!1,scope:"default",tolerance:"intersect"},_create:function(){var t=this.options,i=t.accept;this.isover=0,this.isout=1,this.accept=e.isFunction(i)?i:function(e){return e.is(i)},this.proportions={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight},e.ui.ddmanager.droppables[t.scope]=e.ui.ddmanager.droppables[t.scope]||[],e.ui.ddmanager.droppables[t.scope].push(this),t.addClasses&&this.element.addClass("ui-droppable")},_destroy:function(){for(var t=e.ui.ddmanager.droppables[this.options.scope],i=0;t.length>i;i++)t[i]==this&&t.splice(i,1);this.element.removeClass("ui-droppable ui-droppable-disabled")},_setOption:function(t,i){"accept"==t&&(this.accept=e.isFunction(i)?i:function(e){return e.is(i)}),e.Widget.prototype._setOption.apply(this,arguments)},_activate:function(t){var i=e.ui.ddmanager.current;this.options.activeClass&&this.element.addClass(this.options.activeClass),i&&this._trigger("activate",t,this.ui(i))},_deactivate:function(t){var i=e.ui.ddmanager.current;this.options.activeClass&&this.element.removeClass(this.options.activeClass),i&&this._trigger("deactivate",t,this.ui(i))},_over:function(t){var i=e.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!=this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this.options.hoverClass&&this.element.addClass(this.options.hoverClass),this._trigger("over",t,this.ui(i)))},_out:function(t){var i=e.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!=this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("out",t,this.ui(i)))},_drop:function(t,i){var s=i||e.ui.ddmanager.current;if(!s||(s.currentItem||s.element)[0]==this.element[0])return!1;var a=!1;return this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function(){var t=e.data(this,"droppable");return t.options.greedy&&!t.options.disabled&&t.options.scope==s.options.scope&&t.accept.call(t.element[0],s.currentItem||s.element)&&e.ui.intersect(s,e.extend(t,{offset:t.element.offset()}),t.options.tolerance)?(a=!0,!1):undefined}),a?!1:this.accept.call(this.element[0],s.currentItem||s.element)?(this.options.activeClass&&this.element.removeClass(this.options.activeClass),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("drop",t,this.ui(s)),this.element):!1},ui:function(e){return{draggable:e.currentItem||e.element,helper:e.helper,position:e.position,offset:e.positionAbs}}}),e.ui.intersect=function(t,i,s){if(!i.offset)return!1;var a=(t.positionAbs||t.position.absolute).left,n=a+t.helperProportions.width,o=(t.positionAbs||t.position.absolute).top,r=o+t.helperProportions.height,h=i.offset.left,l=h+i.proportions.width,u=i.offset.top,d=u+i.proportions.height;switch(s){case"fit":return a>=h&&l>=n&&o>=u&&d>=r;case"intersect":return a+t.helperProportions.width/2>h&&l>n-t.helperProportions.width/2&&o+t.helperProportions.height/2>u&&d>r-t.helperProportions.height/2;case"pointer":var c=(t.positionAbs||t.position.absolute).left+(t.clickOffset||t.offset.click).left,p=(t.positionAbs||t.position.absolute).top+(t.clickOffset||t.offset.click).top,f=e.ui.isOver(p,c,u,h,i.proportions.height,i.proportions.width);return f;case"touch":return(o>=u&&d>=o||r>=u&&d>=r||u>o&&r>d)&&(a>=h&&l>=a||n>=h&&l>=n||h>a&&n>l);default:return!1}},e.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(t,i){var s=e.ui.ddmanager.droppables[t.options.scope]||[],a=i?i.type:null,n=(t.currentItem||t.element).find(":data(droppable)").andSelf();e:for(var o=0;s.length>o;o++)if(!(s[o].options.disabled||t&&!s[o].accept.call(s[o].element[0],t.currentItem||t.element))){for(var r=0;n.length>r;r++)if(n[r]==s[o].element[0]){s[o].proportions.height=0;continue e}s[o].visible="none"!=s[o].element.css("display"),s[o].visible&&("mousedown"==a&&s[o]._activate.call(s[o],i),s[o].offset=s[o].element.offset(),s[o].proportions={width:s[o].element[0].offsetWidth,height:s[o].element[0].offsetHeight})}},drop:function(t,i){var s=!1;return e.each(e.ui.ddmanager.droppables[t.options.scope]||[],function(){this.options&&(!this.options.disabled&&this.visible&&e.ui.intersect(t,this,this.options.tolerance)&&(s=this._drop.call(this,i)||s),!this.options.disabled&&this.visible&&this.accept.call(this.element[0],t.currentItem||t.element)&&(this.isout=1,this.isover=0,this._deactivate.call(this,i)))}),s},dragStart:function(t,i){t.element.parentsUntil("body").bind("scroll.droppable",function(){t.options.refreshPositions||e.ui.ddmanager.prepareOffsets(t,i)})},drag:function(t,i){t.options.refreshPositions&&e.ui.ddmanager.prepareOffsets(t,i),e.each(e.ui.ddmanager.droppables[t.options.scope]||[],function(){if(!this.options.disabled&&!this.greedyChild&&this.visible){var s=e.ui.intersect(t,this,this.options.tolerance),a=s||1!=this.isover?s&&0==this.isover?"isover":null:"isout";if(a){var n;if(this.options.greedy){var o=this.options.scope,r=this.element.parents(":data(droppable)").filter(function(){return e.data(this,"droppable").options.scope===o});r.length&&(n=e.data(r[0],"droppable"),n.greedyChild="isover"==a?1:0)}n&&"isover"==a&&(n.isover=0,n.isout=1,n._out.call(n,i)),this[a]=1,this["isout"==a?"isover":"isout"]=0,this["isover"==a?"_over":"_out"].call(this,i),n&&"isout"==a&&(n.isout=0,n.isover=1,n._over.call(n,i))}}})},dragStop:function(t,i){t.element.parentsUntil("body").unbind("scroll.droppable"),t.options.refreshPositions||e.ui.ddmanager.prepareOffsets(t,i)}}})(jQuery);(function(e){e.widget("ui.resizable",e.ui.mouse,{version:"1.9.2",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:1e3},_create:function(){var t=this,i=this.options;if(this.element.addClass("ui-resizable"),e.extend(this,{_aspectRatio:!!i.aspectRatio,aspectRatio:i.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:i.helper||i.ghost||i.animate?i.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)&&(this.element.wrap(e('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("resizable",this.element.data("resizable")),this.elementIsWrapper=!0,this.element.css({marginLeft:this.originalElement.css("marginLeft"),marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom")}),this.originalElement.css({marginLeft:0,marginTop:0,marginRight:0,marginBottom:0}),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css({margin:this.originalElement.css("margin")}),this._proportionallyResize()),this.handles=i.handles||(e(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this.handles.constructor==String){"all"==this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw");var s=this.handles.split(",");this.handles={};for(var a=0;s.length>a;a++){var n=e.trim(s[a]),o="ui-resizable-"+n,r=e('<div class="ui-resizable-handle '+o+'"></div>');r.css({zIndex:i.zIndex}),"se"==n&&r.addClass("ui-icon ui-icon-gripsmall-diagonal-se"),this.handles[n]=".ui-resizable-"+n,this.element.append(r)}}this._renderAxis=function(t){t=t||this.element;for(var i in this.handles){if(this.handles[i].constructor==String&&(this.handles[i]=e(this.handles[i],this.element).show()),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/textarea|input|select|button/i)){var s=e(this.handles[i],this.element),a=0;a=/sw|ne|nw|se|n|s/.test(i)?s.outerHeight():s.outerWidth();var n=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join("");t.css(n,a),this._proportionallyResize()}e(this.handles[i]).length}},this._renderAxis(this.element),this._handles=e(".ui-resizable-handle",this.element).disableSelection(),this._handles.mouseover(function(){if(!t.resizing){if(this.className)var e=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);t.axis=e&&e[1]?e[1]:"se"}}),i.autoHide&&(this._handles.hide(),e(this.element).addClass("ui-resizable-autohide").mouseenter(function(){i.disabled||(e(this).removeClass("ui-resizable-autohide"),t._handles.show())}).mouseleave(function(){i.disabled||t.resizing||(e(this).addClass("ui-resizable-autohide"),t._handles.hide())})),this._mouseInit()},_destroy:function(){this._mouseDestroy();var t=function(t){e(t).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove()};if(this.elementIsWrapper){t(this.element);var i=this.element;this.originalElement.css({position:i.css("position"),width:i.outerWidth(),height:i.outerHeight(),top:i.css("top"),left:i.css("left")}).insertAfter(i),i.remove()}return this.originalElement.css("resize",this.originalResizeStyle),t(this.originalElement),this},_mouseCapture:function(t){var i=!1;for(var s in this.handles)e(this.handles[s])[0]==t.target&&(i=!0);return!this.options.disabled&&i},_mouseStart:function(i){var s=this.options,a=this.element.position(),n=this.element;this.resizing=!0,this.documentScroll={top:e(document).scrollTop(),left:e(document).scrollLeft()},(n.is(".ui-draggable")||/absolute/.test(n.css("position")))&&n.css({position:"absolute",top:a.top,left:a.left}),this._renderProxy();var o=t(this.helper.css("left")),r=t(this.helper.css("top"));s.containment&&(o+=e(s.containment).scrollLeft()||0,r+=e(s.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:o,top:r},this.size=this._helper?{width:n.outerWidth(),height:n.outerHeight()}:{width:n.width(),height:n.height()},this.originalSize=this._helper?{width:n.outerWidth(),height:n.outerHeight()}:{width:n.width(),height:n.height()},this.originalPosition={left:o,top:r},this.sizeDiff={width:n.outerWidth()-n.width(),height:n.outerHeight()-n.height()},this.originalMousePosition={left:i.pageX,top:i.pageY},this.aspectRatio="number"==typeof s.aspectRatio?s.aspectRatio:this.originalSize.width/this.originalSize.height||1;var h=e(".ui-resizable-"+this.axis).css("cursor");return e("body").css("cursor","auto"==h?this.axis+"-resize":h),n.addClass("ui-resizable-resizing"),this._propagate("start",i),!0},_mouseDrag:function(e){var t=this.helper,i=(this.options,this.originalMousePosition),s=this.axis,a=e.pageX-i.left||0,n=e.pageY-i.top||0,o=this._change[s];if(!o)return!1;var r=o.apply(this,[e,a,n]);return this._updateVirtualBoundaries(e.shiftKey),(this._aspectRatio||e.shiftKey)&&(r=this._updateRatio(r,e)),r=this._respectSize(r,e),this._propagate("resize",e),t.css({top:this.position.top+"px",left:this.position.left+"px",width:this.size.width+"px",height:this.size.height+"px"}),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),this._updateCache(r),this._trigger("resize",e,this.ui()),!1},_mouseStop:function(t){this.resizing=!1;var i=this.options,s=this;if(this._helper){var a=this._proportionallyResizeElements,n=a.length&&/textarea/i.test(a[0].nodeName),o=n&&e.ui.hasScroll(a[0],"left")?0:s.sizeDiff.height,r=n?0:s.sizeDiff.width,h={width:s.helper.width()-r,height:s.helper.height()-o},l=parseInt(s.element.css("left"),10)+(s.position.left-s.originalPosition.left)||null,u=parseInt(s.element.css("top"),10)+(s.position.top-s.originalPosition.top)||null;i.animate||this.element.css(e.extend(h,{top:u,left:l})),s.helper.height(s.size.height),s.helper.width(s.size.width),this._helper&&!i.animate&&this._proportionallyResize()}return e("body").css("cursor","auto"),this.element.removeClass("ui-resizable-resizing"),this._propagate("stop",t),this._helper&&this.helper.remove(),!1},_updateVirtualBoundaries:function(e){var t,s,a,n,o,r=this.options;o={minWidth:i(r.minWidth)?r.minWidth:0,maxWidth:i(r.maxWidth)?r.maxWidth:1/0,minHeight:i(r.minHeight)?r.minHeight:0,maxHeight:i(r.maxHeight)?r.maxHeight:1/0},(this._aspectRatio||e)&&(t=o.minHeight*this.aspectRatio,a=o.minWidth/this.aspectRatio,s=o.maxHeight*this.aspectRatio,n=o.maxWidth/this.aspectRatio,t>o.minWidth&&(o.minWidth=t),a>o.minHeight&&(o.minHeight=a),o.maxWidth>s&&(o.maxWidth=s),o.maxHeight>n&&(o.maxHeight=n)),this._vBoundaries=o},_updateCache:function(e){this.options,this.offset=this.helper.offset(),i(e.left)&&(this.position.left=e.left),i(e.top)&&(this.position.top=e.top),i(e.height)&&(this.size.height=e.height),i(e.width)&&(this.size.width=e.width)},_updateRatio:function(e){var t=(this.options,this.position),s=this.size,a=this.axis;return i(e.height)?e.width=e.height*this.aspectRatio:i(e.width)&&(e.height=e.width/this.aspectRatio),"sw"==a&&(e.left=t.left+(s.width-e.width),e.top=null),"nw"==a&&(e.top=t.top+(s.height-e.height),e.left=t.left+(s.width-e.width)),e},_respectSize:function(e,t){var s=(this.helper,this._vBoundaries),a=(this._aspectRatio||t.shiftKey,this.axis),n=i(e.width)&&s.maxWidth&&s.maxWidth<e.width,o=i(e.height)&&s.maxHeight&&s.maxHeight<e.height,r=i(e.width)&&s.minWidth&&s.minWidth>e.width,h=i(e.height)&&s.minHeight&&s.minHeight>e.height;r&&(e.width=s.minWidth),h&&(e.height=s.minHeight),n&&(e.width=s.maxWidth),o&&(e.height=s.maxHeight);var l=this.originalPosition.left+this.originalSize.width,u=this.position.top+this.size.height,d=/sw|nw|w/.test(a),c=/nw|ne|n/.test(a);r&&d&&(e.left=l-s.minWidth),n&&d&&(e.left=l-s.maxWidth),h&&c&&(e.top=u-s.minHeight),o&&c&&(e.top=u-s.maxHeight);var p=!e.width&&!e.height;return p&&!e.left&&e.top?e.top=null:p&&!e.top&&e.left&&(e.left=null),e},_proportionallyResize:function(){if(this.options,this._proportionallyResizeElements.length)for(var t=this.helper||this.element,i=0;this._proportionallyResizeElements.length>i;i++){var s=this._proportionallyResizeElements[i];if(!this.borderDif){var a=[s.css("borderTopWidth"),s.css("borderRightWidth"),s.css("borderBottomWidth"),s.css("borderLeftWidth")],n=[s.css("paddingTop"),s.css("paddingRight"),s.css("paddingBottom"),s.css("paddingLeft")];this.borderDif=e.map(a,function(e,t){var i=parseInt(e,10)||0,s=parseInt(n[t],10)||0;return i+s})}s.css({height:t.height()-this.borderDif[0]-this.borderDif[2]||0,width:t.width()-this.borderDif[1]-this.borderDif[3]||0})}},_renderProxy:function(){var t=this.element,i=this.options;if(this.elementOffset=t.offset(),this._helper){this.helper=this.helper||e('<div style="overflow:hidden;"></div>');var s=e.ui.ie6?1:0,a=e.ui.ie6?2:-1;this.helper.addClass(this._helper).css({width:this.element.outerWidth()+a,height:this.element.outerHeight()+a,position:"absolute",left:this.elementOffset.left-s+"px",top:this.elementOffset.top-s+"px",zIndex:++i.zIndex}),this.helper.appendTo("body").disableSelection()}else this.helper=this.element},_change:{e:function(e,t){return{width:this.originalSize.width+t}},w:function(e,t){var i=(this.options,this.originalSize),s=this.originalPosition;return{left:s.left+t,width:i.width-t}},n:function(e,t,i){var s=(this.options,this.originalSize),a=this.originalPosition;return{top:a.top+i,height:s.height-i}},s:function(e,t,i){return{height:this.originalSize.height+i}},se:function(t,i,s){return e.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[t,i,s]))},sw:function(t,i,s){return e.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[t,i,s]))},ne:function(t,i,s){return e.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[t,i,s]))},nw:function(t,i,s){return e.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[t,i,s]))}},_propagate:function(t,i){e.ui.plugin.call(this,t,[i,this.ui()]),"resize"!=t&&this._trigger(t,i,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),e.ui.plugin.add("resizable","alsoResize",{start:function(){var t=e(this).data("resizable"),i=t.options,s=function(t){e(t).each(function(){var t=e(this);t.data("resizable-alsoresize",{width:parseInt(t.width(),10),height:parseInt(t.height(),10),left:parseInt(t.css("left"),10),top:parseInt(t.css("top"),10)})})};"object"!=typeof i.alsoResize||i.alsoResize.parentNode?s(i.alsoResize):i.alsoResize.length?(i.alsoResize=i.alsoResize[0],s(i.alsoResize)):e.each(i.alsoResize,function(e){s(e)})},resize:function(t,i){var s=e(this).data("resizable"),a=s.options,n=s.originalSize,o=s.originalPosition,r={height:s.size.height-n.height||0,width:s.size.width-n.width||0,top:s.position.top-o.top||0,left:s.position.left-o.left||0},h=function(t,s){e(t).each(function(){var t=e(this),a=e(this).data("resizable-alsoresize"),n={},o=s&&s.length?s:t.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];e.each(o,function(e,t){var i=(a[t]||0)+(r[t]||0);i&&i>=0&&(n[t]=i||null)}),t.css(n)})};"object"!=typeof a.alsoResize||a.alsoResize.nodeType?h(a.alsoResize):e.each(a.alsoResize,function(e,t){h(e,t)})},stop:function(){e(this).removeData("resizable-alsoresize")}}),e.ui.plugin.add("resizable","animate",{stop:function(t){var i=e(this).data("resizable"),s=i.options,a=i._proportionallyResizeElements,n=a.length&&/textarea/i.test(a[0].nodeName),o=n&&e.ui.hasScroll(a[0],"left")?0:i.sizeDiff.height,r=n?0:i.sizeDiff.width,h={width:i.size.width-r,height:i.size.height-o},l=parseInt(i.element.css("left"),10)+(i.position.left-i.originalPosition.left)||null,u=parseInt(i.element.css("top"),10)+(i.position.top-i.originalPosition.top)||null;i.element.animate(e.extend(h,u&&l?{top:u,left:l}:{}),{duration:s.animateDuration,easing:s.animateEasing,step:function(){var s={width:parseInt(i.element.css("width"),10),height:parseInt(i.element.css("height"),10),top:parseInt(i.element.css("top"),10),left:parseInt(i.element.css("left"),10)};a&&a.length&&e(a[0]).css({width:s.width,height:s.height}),i._updateCache(s),i._propagate("resize",t)}})}}),e.ui.plugin.add("resizable","containment",{start:function(){var i=e(this).data("resizable"),s=i.options,a=i.element,n=s.containment,o=n instanceof e?n.get(0):/parent/.test(n)?a.parent().get(0):n;if(o)if(i.containerElement=e(o),/document/.test(n)||n==document)i.containerOffset={left:0,top:0},i.containerPosition={left:0,top:0},i.parentData={element:e(document),left:0,top:0,width:e(document).width(),height:e(document).height()||document.body.parentNode.scrollHeight};else{var r=e(o),h=[];e(["Top","Right","Left","Bottom"]).each(function(e,i){h[e]=t(r.css("padding"+i))}),i.containerOffset=r.offset(),i.containerPosition=r.position(),i.containerSize={height:r.innerHeight()-h[3],width:r.innerWidth()-h[1]};var l=i.containerOffset,u=i.containerSize.height,d=i.containerSize.width,c=e.ui.hasScroll(o,"left")?o.scrollWidth:d,p=e.ui.hasScroll(o)?o.scrollHeight:u;i.parentData={element:o,left:l.left,top:l.top,width:c,height:p}}},resize:function(t){var i=e(this).data("resizable"),s=i.options,a=(i.containerSize,i.containerOffset),n=(i.size,i.position),o=i._aspectRatio||t.shiftKey,r={top:0,left:0},h=i.containerElement;h[0]!=document&&/static/.test(h.css("position"))&&(r=a),n.left<(i._helper?a.left:0)&&(i.size.width=i.size.width+(i._helper?i.position.left-a.left:i.position.left-r.left),o&&(i.size.height=i.size.width/i.aspectRatio),i.position.left=s.helper?a.left:0),n.top<(i._helper?a.top:0)&&(i.size.height=i.size.height+(i._helper?i.position.top-a.top:i.position.top),o&&(i.size.width=i.size.height*i.aspectRatio),i.position.top=i._helper?a.top:0),i.offset.left=i.parentData.left+i.position.left,i.offset.top=i.parentData.top+i.position.top;var l=Math.abs((i._helper?i.offset.left-r.left:i.offset.left-r.left)+i.sizeDiff.width),u=Math.abs((i._helper?i.offset.top-r.top:i.offset.top-a.top)+i.sizeDiff.height),d=i.containerElement.get(0)==i.element.parent().get(0),c=/relative|absolute/.test(i.containerElement.css("position"));d&&c&&(l-=i.parentData.left),l+i.size.width>=i.parentData.width&&(i.size.width=i.parentData.width-l,o&&(i.size.height=i.size.width/i.aspectRatio)),u+i.size.height>=i.parentData.height&&(i.size.height=i.parentData.height-u,o&&(i.size.width=i.size.height*i.aspectRatio))},stop:function(){var t=e(this).data("resizable"),i=t.options,s=(t.position,t.containerOffset),a=t.containerPosition,n=t.containerElement,o=e(t.helper),r=o.offset(),h=o.outerWidth()-t.sizeDiff.width,l=o.outerHeight()-t.sizeDiff.height;t._helper&&!i.animate&&/relative/.test(n.css("position"))&&e(this).css({left:r.left-a.left-s.left,width:h,height:l}),t._helper&&!i.animate&&/static/.test(n.css("position"))&&e(this).css({left:r.left-a.left-s.left,width:h,height:l})}}),e.ui.plugin.add("resizable","ghost",{start:function(){var t=e(this).data("resizable"),i=t.options,s=t.size;t.ghost=t.originalElement.clone(),t.ghost.css({opacity:.25,display:"block",position:"relative",height:s.height,width:s.width,margin:0,left:0,top:0}).addClass("ui-resizable-ghost").addClass("string"==typeof i.ghost?i.ghost:""),t.ghost.appendTo(t.helper)},resize:function(){var t=e(this).data("resizable");t.options,t.ghost&&t.ghost.css({position:"relative",height:t.size.height,width:t.size.width})},stop:function(){var t=e(this).data("resizable");t.options,t.ghost&&t.helper&&t.helper.get(0).removeChild(t.ghost.get(0))}}),e.ui.plugin.add("resizable","grid",{resize:function(t){var i=e(this).data("resizable"),s=i.options,a=i.size,n=i.originalSize,o=i.originalPosition,r=i.axis;s._aspectRatio||t.shiftKey,s.grid="number"==typeof s.grid?[s.grid,s.grid]:s.grid;var h=Math.round((a.width-n.width)/(s.grid[0]||1))*(s.grid[0]||1),l=Math.round((a.height-n.height)/(s.grid[1]||1))*(s.grid[1]||1);/^(se|s|e)$/.test(r)?(i.size.width=n.width+h,i.size.height=n.height+l):/^(ne)$/.test(r)?(i.size.width=n.width+h,i.size.height=n.height+l,i.position.top=o.top-l):/^(sw)$/.test(r)?(i.size.width=n.width+h,i.size.height=n.height+l,i.position.left=o.left-h):(i.size.width=n.width+h,i.size.height=n.height+l,i.position.top=o.top-l,i.position.left=o.left-h)}});var t=function(e){return parseInt(e,10)||0},i=function(e){return!isNaN(parseInt(e,10))}})(jQuery);(function(e){e.widget("ui.selectable",e.ui.mouse,{version:"1.9.2",options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch"},_create:function(){var t=this;this.element.addClass("ui-selectable"),this.dragged=!1;var i;this.refresh=function(){i=e(t.options.filter,t.element[0]),i.addClass("ui-selectee"),i.each(function(){var t=e(this),i=t.offset();e.data(this,"selectable-item",{element:this,$element:t,left:i.left,top:i.top,right:i.left+t.outerWidth(),bottom:i.top+t.outerHeight(),startselected:!1,selected:t.hasClass("ui-selected"),selecting:t.hasClass("ui-selecting"),unselecting:t.hasClass("ui-unselecting")})})},this.refresh(),this.selectees=i.addClass("ui-selectee"),this._mouseInit(),this.helper=e("<div class='ui-selectable-helper'></div>")},_destroy:function(){this.selectees.removeClass("ui-selectee").removeData("selectable-item"),this.element.removeClass("ui-selectable ui-selectable-disabled"),this._mouseDestroy()},_mouseStart:function(t){var i=this;if(this.opos=[t.pageX,t.pageY],!this.options.disabled){var s=this.options;this.selectees=e(s.filter,this.element[0]),this._trigger("start",t),e(s.appendTo).append(this.helper),this.helper.css({left:t.clientX,top:t.clientY,width:0,height:0}),s.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var s=e.data(this,"selectable-item");s.startselected=!0,t.metaKey||t.ctrlKey||(s.$element.removeClass("ui-selected"),s.selected=!1,s.$element.addClass("ui-unselecting"),s.unselecting=!0,i._trigger("unselecting",t,{unselecting:s.element}))}),e(t.target).parents().andSelf().each(function(){var s=e.data(this,"selectable-item");if(s){var a=!t.metaKey&&!t.ctrlKey||!s.$element.hasClass("ui-selected");return s.$element.removeClass(a?"ui-unselecting":"ui-selected").addClass(a?"ui-selecting":"ui-unselecting"),s.unselecting=!a,s.selecting=a,s.selected=a,a?i._trigger("selecting",t,{selecting:s.element}):i._trigger("unselecting",t,{unselecting:s.element}),!1}})}},_mouseDrag:function(t){var i=this;if(this.dragged=!0,!this.options.disabled){var s=this.options,a=this.opos[0],n=this.opos[1],o=t.pageX,r=t.pageY;if(a>o){var h=o;o=a,a=h}if(n>r){var h=r;r=n,n=h}return this.helper.css({left:a,top:n,width:o-a,height:r-n}),this.selectees.each(function(){var h=e.data(this,"selectable-item");if(h&&h.element!=i.element[0]){var l=!1;"touch"==s.tolerance?l=!(h.left>o||a>h.right||h.top>r||n>h.bottom):"fit"==s.tolerance&&(l=h.left>a&&o>h.right&&h.top>n&&r>h.bottom),l?(h.selected&&(h.$element.removeClass("ui-selected"),h.selected=!1),h.unselecting&&(h.$element.removeClass("ui-unselecting"),h.unselecting=!1),h.selecting||(h.$element.addClass("ui-selecting"),h.selecting=!0,i._trigger("selecting",t,{selecting:h.element}))):(h.selecting&&((t.metaKey||t.ctrlKey)&&h.startselected?(h.$element.removeClass("ui-selecting"),h.selecting=!1,h.$element.addClass("ui-selected"),h.selected=!0):(h.$element.removeClass("ui-selecting"),h.selecting=!1,h.startselected&&(h.$element.addClass("ui-unselecting"),h.unselecting=!0),i._trigger("unselecting",t,{unselecting:h.element}))),h.selected&&(t.metaKey||t.ctrlKey||h.startselected||(h.$element.removeClass("ui-selected"),h.selected=!1,h.$element.addClass("ui-unselecting"),h.unselecting=!0,i._trigger("unselecting",t,{unselecting:h.element}))))}}),!1}},_mouseStop:function(t){var i=this;return this.dragged=!1,this.options,e(".ui-unselecting",this.element[0]).each(function(){var s=e.data(this,"selectable-item");s.$element.removeClass("ui-unselecting"),s.unselecting=!1,s.startselected=!1,i._trigger("unselected",t,{unselected:s.element})}),e(".ui-selecting",this.element[0]).each(function(){var s=e.data(this,"selectable-item");s.$element.removeClass("ui-selecting").addClass("ui-selected"),s.selecting=!1,s.selected=!0,s.startselected=!0,i._trigger("selected",t,{selected:s.element})}),this._trigger("stop",t),this.helper.remove(),!1}})})(jQuery);(function(e){e.widget("ui.sortable",e.ui.mouse,{version:"1.9.2",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3},_create:function(){var e=this.options;this.containerCache={},this.element.addClass("ui-sortable"),this.refresh(),this.floating=this.items.length?"x"===e.axis||/left|right/.test(this.items[0].item.css("float"))||/inline|table-cell/.test(this.items[0].item.css("display")):!1,this.offset=this.element.offset(),this._mouseInit(),this.ready=!0},_destroy:function(){this.element.removeClass("ui-sortable ui-sortable-disabled"),this._mouseDestroy();for(var e=this.items.length-1;e>=0;e--)this.items[e].item.removeData(this.widgetName+"-item");return this},_setOption:function(t,i){"disabled"===t?(this.options[t]=i,this.widget().toggleClass("ui-sortable-disabled",!!i)):e.Widget.prototype._setOption.apply(this,arguments)},_mouseCapture:function(t,i){var s=this;if(this.reverting)return!1;if(this.options.disabled||"static"==this.options.type)return!1;this._refreshItems(t);var a=null;if(e(t.target).parents().each(function(){return e.data(this,s.widgetName+"-item")==s?(a=e(this),!1):undefined}),e.data(t.target,s.widgetName+"-item")==s&&(a=e(t.target)),!a)return!1;if(this.options.handle&&!i){var n=!1;if(e(this.options.handle,a).find("*").andSelf().each(function(){this==t.target&&(n=!0)}),!n)return!1}return this.currentItem=a,this._removeCurrentsFromItems(),!0},_mouseStart:function(t,i,s){var a=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(t),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},e.extend(this.offset,{click:{left:t.pageX-this.offset.left,top:t.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(t),this.originalPageX=t.pageX,this.originalPageY=t.pageY,a.cursorAt&&this._adjustOffsetFromHelper(a.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!=this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),a.containment&&this._setContainment(),a.cursor&&(e("body").css("cursor")&&(this._storedCursor=e("body").css("cursor")),e("body").css("cursor",a.cursor)),a.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",a.opacity)),a.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",a.zIndex)),this.scrollParent[0]!=document&&"HTML"!=this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",t,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(var n=this.containers.length-1;n>=0;n--)this.containers[n]._trigger("activate",t,this._uiHash(this));return e.ui.ddmanager&&(e.ui.ddmanager.current=this),e.ui.ddmanager&&!a.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this.dragging=!0,this.helper.addClass("ui-sortable-helper"),this._mouseDrag(t),!0},_mouseDrag:function(t){if(this.position=this._generatePosition(t),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll){var i=this.options,s=!1;this.scrollParent[0]!=document&&"HTML"!=this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-t.pageY<i.scrollSensitivity?this.scrollParent[0].scrollTop=s=this.scrollParent[0].scrollTop+i.scrollSpeed:t.pageY-this.overflowOffset.top<i.scrollSensitivity&&(this.scrollParent[0].scrollTop=s=this.scrollParent[0].scrollTop-i.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-t.pageX<i.scrollSensitivity?this.scrollParent[0].scrollLeft=s=this.scrollParent[0].scrollLeft+i.scrollSpeed:t.pageX-this.overflowOffset.left<i.scrollSensitivity&&(this.scrollParent[0].scrollLeft=s=this.scrollParent[0].scrollLeft-i.scrollSpeed)):(t.pageY-e(document).scrollTop()<i.scrollSensitivity?s=e(document).scrollTop(e(document).scrollTop()-i.scrollSpeed):e(window).height()-(t.pageY-e(document).scrollTop())<i.scrollSensitivity&&(s=e(document).scrollTop(e(document).scrollTop()+i.scrollSpeed)),t.pageX-e(document).scrollLeft()<i.scrollSensitivity?s=e(document).scrollLeft(e(document).scrollLeft()-i.scrollSpeed):e(window).width()-(t.pageX-e(document).scrollLeft())<i.scrollSensitivity&&(s=e(document).scrollLeft(e(document).scrollLeft()+i.scrollSpeed))),s!==!1&&e.ui.ddmanager&&!i.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t)}this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"==this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"==this.options.axis||(this.helper[0].style.top=this.position.top+"px");for(var a=this.items.length-1;a>=0;a--){var n=this.items[a],o=n.item[0],r=this._intersectsWithPointer(n);if(r&&n.instance===this.currentContainer&&o!=this.currentItem[0]&&this.placeholder[1==r?"next":"prev"]()[0]!=o&&!e.contains(this.placeholder[0],o)&&("semi-dynamic"==this.options.type?!e.contains(this.element[0],o):!0)){if(this.direction=1==r?"down":"up","pointer"!=this.options.tolerance&&!this._intersectsWithSides(n))break;this._rearrange(t,n),this._trigger("change",t,this._uiHash());break}}return this._contactContainers(t),e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),this._trigger("sort",t,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(t,i){if(t){if(e.ui.ddmanager&&!this.options.dropBehaviour&&e.ui.ddmanager.drop(this,t),this.options.revert){var s=this,a=this.placeholder.offset();this.reverting=!0,e(this.helper).animate({left:a.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]==document.body?0:this.offsetParent[0].scrollLeft),top:a.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]==document.body?0:this.offsetParent[0].scrollTop)},parseInt(this.options.revert,10)||500,function(){s._clear(t)})}else this._clear(t,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp({target:null}),"original"==this.options.helper?this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"):this.currentItem.show();for(var t=this.containers.length-1;t>=0;t--)this.containers[t]._trigger("deactivate",null,this._uiHash(this)),this.containers[t].containerCache.over&&(this.containers[t]._trigger("out",null,this._uiHash(this)),this.containers[t].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!=this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),e.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?e(this.domPosition.prev).after(this.currentItem):e(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(t){var i=this._getItemsAsjQuery(t&&t.connected),s=[];return t=t||{},e(i).each(function(){var i=(e(t.item||this).attr(t.attribute||"id")||"").match(t.expression||/(.+)[-=_](.+)/);i&&s.push((t.key||i[1]+"[]")+"="+(t.key&&t.expression?i[1]:i[2]))}),!s.length&&t.key&&s.push(t.key+"="),s.join("&")},toArray:function(t){var i=this._getItemsAsjQuery(t&&t.connected),s=[];return t=t||{},i.each(function(){s.push(e(t.item||this).attr(t.attribute||"id")||"")}),s},_intersectsWith:function(e){var t=this.positionAbs.left,i=t+this.helperProportions.width,s=this.positionAbs.top,a=s+this.helperProportions.height,n=e.left,o=n+e.width,r=e.top,h=r+e.height,l=this.offset.click.top,u=this.offset.click.left,d=s+l>r&&h>s+l&&t+u>n&&o>t+u;return"pointer"==this.options.tolerance||this.options.forcePointerForContainers||"pointer"!=this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>e[this.floating?"width":"height"]?d:t+this.helperProportions.width/2>n&&o>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>r&&h>a-this.helperProportions.height/2},_intersectsWithPointer:function(t){var i="x"===this.options.axis||e.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,t.top,t.height),s="y"===this.options.axis||e.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,t.left,t.width),a=i&&s,n=this._getDragVerticalDirection(),o=this._getDragHorizontalDirection();return a?this.floating?o&&"right"==o||"down"==n?2:1:n&&("down"==n?2:1):!1},_intersectsWithSides:function(t){var i=e.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,t.top+t.height/2,t.height),s=e.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,t.left+t.width/2,t.width),a=this._getDragVerticalDirection(),n=this._getDragHorizontalDirection();return this.floating&&n?"right"==n&&s||"left"==n&&!s:a&&("down"==a&&i||"up"==a&&!i)},_getDragVerticalDirection:function(){var e=this.positionAbs.top-this.lastPositionAbs.top;return 0!=e&&(e>0?"down":"up")},_getDragHorizontalDirection:function(){var e=this.positionAbs.left-this.lastPositionAbs.left;return 0!=e&&(e>0?"right":"left")},refresh:function(e){return this._refreshItems(e),this.refreshPositions(),this},_connectWith:function(){var e=this.options;return e.connectWith.constructor==String?[e.connectWith]:e.connectWith},_getItemsAsjQuery:function(t){var i=[],s=[],a=this._connectWith();if(a&&t)for(var n=a.length-1;n>=0;n--)for(var o=e(a[n]),r=o.length-1;r>=0;r--){var h=e.data(o[r],this.widgetName);h&&h!=this&&!h.options.disabled&&s.push([e.isFunction(h.options.items)?h.options.items.call(h.element):e(h.options.items,h.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),h])}s.push([e.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):e(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]);for(var n=s.length-1;n>=0;n--)s[n][0].each(function(){i.push(this)});return e(i)},_removeCurrentsFromItems:function(){var t=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=e.grep(this.items,function(e){for(var i=0;t.length>i;i++)if(t[i]==e.item[0])return!1;return!0})},_refreshItems:function(t){this.items=[],this.containers=[this];var i=this.items,s=[[e.isFunction(this.options.items)?this.options.items.call(this.element[0],t,{item:this.currentItem}):e(this.options.items,this.element),this]],a=this._connectWith();if(a&&this.ready)for(var n=a.length-1;n>=0;n--)for(var o=e(a[n]),r=o.length-1;r>=0;r--){var h=e.data(o[r],this.widgetName);h&&h!=this&&!h.options.disabled&&(s.push([e.isFunction(h.options.items)?h.options.items.call(h.element[0],t,{item:this.currentItem}):e(h.options.items,h.element),h]),this.containers.push(h))}for(var n=s.length-1;n>=0;n--)for(var l=s[n][1],u=s[n][0],r=0,d=u.length;d>r;r++){var c=e(u[r]);c.data(this.widgetName+"-item",l),i.push({item:c,instance:l,width:0,height:0,left:0,top:0})}},refreshPositions:function(t){this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());for(var i=this.items.length-1;i>=0;i--){var s=this.items[i];if(s.instance==this.currentContainer||!this.currentContainer||s.item[0]==this.currentItem[0]){var a=this.options.toleranceElement?e(this.options.toleranceElement,s.item):s.item;t||(s.width=a.outerWidth(),s.height=a.outerHeight());var n=a.offset();s.left=n.left,s.top=n.top}}if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(var i=this.containers.length-1;i>=0;i--){var n=this.containers[i].element.offset();this.containers[i].containerCache.left=n.left,this.containers[i].containerCache.top=n.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight()}return this},_createPlaceholder:function(t){t=t||this;var i=t.options;if(!i.placeholder||i.placeholder.constructor==String){var s=i.placeholder;i.placeholder={element:function(){var i=e(document.createElement(t.currentItem[0].nodeName)).addClass(s||t.currentItem[0].className+" ui-sortable-placeholder").removeClass("ui-sortable-helper")[0];return s||(i.style.visibility="hidden"),i},update:function(e,a){(!s||i.forcePlaceholderSize)&&(a.height()||a.height(t.currentItem.innerHeight()-parseInt(t.currentItem.css("paddingTop")||0,10)-parseInt(t.currentItem.css("paddingBottom")||0,10)),a.width()||a.width(t.currentItem.innerWidth()-parseInt(t.currentItem.css("paddingLeft")||0,10)-parseInt(t.currentItem.css("paddingRight")||0,10)))}}}t.placeholder=e(i.placeholder.element.call(t.element,t.currentItem)),t.currentItem.after(t.placeholder),i.placeholder.update(t,t.placeholder)},_contactContainers:function(t){for(var i=null,s=null,a=this.containers.length-1;a>=0;a--)if(!e.contains(this.currentItem[0],this.containers[a].element[0]))if(this._intersectsWith(this.containers[a].containerCache)){if(i&&e.contains(this.containers[a].element[0],i.element[0]))continue;i=this.containers[a],s=a}else this.containers[a].containerCache.over&&(this.containers[a]._trigger("out",t,this._uiHash(this)),this.containers[a].containerCache.over=0);if(i)if(1===this.containers.length)this.containers[s]._trigger("over",t,this._uiHash(this)),this.containers[s].containerCache.over=1;else{for(var n=1e4,o=null,r=this.containers[s].floating?"left":"top",h=this.containers[s].floating?"width":"height",l=this.positionAbs[r]+this.offset.click[r],u=this.items.length-1;u>=0;u--)if(e.contains(this.containers[s].element[0],this.items[u].item[0])&&this.items[u].item[0]!=this.currentItem[0]){var d=this.items[u].item.offset()[r],c=!1;Math.abs(d-l)>Math.abs(d+this.items[u][h]-l)&&(c=!0,d+=this.items[u][h]),n>Math.abs(d-l)&&(n=Math.abs(d-l),o=this.items[u],this.direction=c?"up":"down")}if(!o&&!this.options.dropOnEmpty)return;this.currentContainer=this.containers[s],o?this._rearrange(t,o,null,!0):this._rearrange(t,null,this.containers[s].element,!0),this._trigger("change",t,this._uiHash()),this.containers[s]._trigger("change",t,this._uiHash(this)),this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[s]._trigger("over",t,this._uiHash(this)),this.containers[s].containerCache.over=1}},_createHelper:function(t){var i=this.options,s=e.isFunction(i.helper)?e(i.helper.apply(this.element[0],[t,this.currentItem])):"clone"==i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||e("parent"!=i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]==this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(""==s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(""==s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var t=this.offsetParent.offset();return"absolute"==this.cssPosition&&this.scrollParent[0]!=document&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&"html"==this.offsetParent[0].tagName.toLowerCase()&&e.ui.ie)&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"==this.cssPosition){var e=this.currentItem.position();return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:e.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t=this.options;if("parent"==t.containment&&(t.containment=this.helper[0].parentNode),("document"==t.containment||"window"==t.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,e("document"==t.containment?document:window).width()-this.helperProportions.width-this.margins.left,(e("document"==t.containment?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),!/^(document|window|parent)$/.test(t.containment)){var i=e(t.containment)[0],s=e(t.containment).offset(),a="hidden"!=e(i).css("overflow");this.containment=[s.left+(parseInt(e(i).css("borderLeftWidth"),10)||0)+(parseInt(e(i).css("paddingLeft"),10)||0)-this.margins.left,s.top+(parseInt(e(i).css("borderTopWidth"),10)||0)+(parseInt(e(i).css("paddingTop"),10)||0)-this.margins.top,s.left+(a?Math.max(i.scrollWidth,i.offsetWidth):i.offsetWidth)-(parseInt(e(i).css("borderLeftWidth"),10)||0)-(parseInt(e(i).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,s.top+(a?Math.max(i.scrollHeight,i.offsetHeight):i.offsetHeight)-(parseInt(e(i).css("borderTopWidth"),10)||0)-(parseInt(e(i).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top]}},_convertPositionTo:function(t,i){i||(i=this.position);var s="absolute"==t?1:-1,a=(this.options,"absolute"!=this.cssPosition||this.scrollParent[0]!=document&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent),n=/(html|body)/i.test(a[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"==this.cssPosition?-this.scrollParent.scrollTop():n?0:a.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"==this.cssPosition?-this.scrollParent.scrollLeft():n?0:a.scrollLeft())*s}},_generatePosition:function(t){var i=this.options,s="absolute"!=this.cssPosition||this.scrollParent[0]!=document&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,a=/(html|body)/i.test(s[0].tagName);"relative"!=this.cssPosition||this.scrollParent[0]!=document&&this.scrollParent[0]!=this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset());var n=t.pageX,o=t.pageY;if(this.originalPosition&&(this.containment&&(t.pageX-this.offset.click.left<this.containment[0]&&(n=this.containment[0]+this.offset.click.left),t.pageY-this.offset.click.top<this.containment[1]&&(o=this.containment[1]+this.offset.click.top),t.pageX-this.offset.click.left>this.containment[2]&&(n=this.containment[2]+this.offset.click.left),t.pageY-this.offset.click.top>this.containment[3]&&(o=this.containment[3]+this.offset.click.top)),i.grid)){var r=this.originalPageY+Math.round((o-this.originalPageY)/i.grid[1])*i.grid[1];o=this.containment?r-this.offset.click.top<this.containment[1]||r-this.offset.click.top>this.containment[3]?r-this.offset.click.top<this.containment[1]?r+i.grid[1]:r-i.grid[1]:r:r;var h=this.originalPageX+Math.round((n-this.originalPageX)/i.grid[0])*i.grid[0];n=this.containment?h-this.offset.click.left<this.containment[0]||h-this.offset.click.left>this.containment[2]?h-this.offset.click.left<this.containment[0]?h+i.grid[0]:h-i.grid[0]:h:h}return{top:o-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"==this.cssPosition?-this.scrollParent.scrollTop():a?0:s.scrollTop()),left:n-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"==this.cssPosition?-this.scrollParent.scrollLeft():a?0:s.scrollLeft())}},_rearrange:function(e,t,i,s){i?i[0].appendChild(this.placeholder[0]):t.item[0].parentNode.insertBefore(this.placeholder[0],"down"==this.direction?t.item[0]:t.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var a=this.counter;this._delay(function(){a==this.counter&&this.refreshPositions(!s)})},_clear:function(t,i){this.reverting=!1;var s=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]==this.currentItem[0]){for(var a in this._storedCSS)("auto"==this._storedCSS[a]||"static"==this._storedCSS[a])&&(this._storedCSS[a]="");this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")}else this.currentItem.show();this.fromOutside&&!i&&s.push(function(e){this._trigger("receive",e,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev==this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent==this.currentItem.parent()[0]||i||s.push(function(e){this._trigger("update",e,this._uiHash())}),this!==this.currentContainer&&(i||(s.push(function(e){this._trigger("remove",e,this._uiHash())}),s.push(function(e){return function(t){e._trigger("receive",t,this._uiHash(this))}}.call(this,this.currentContainer)),s.push(function(e){return function(t){e._trigger("update",t,this._uiHash(this))}}.call(this,this.currentContainer))));for(var a=this.containers.length-1;a>=0;a--)i||s.push(function(e){return function(t){e._trigger("deactivate",t,this._uiHash(this))}}.call(this,this.containers[a])),this.containers[a].containerCache.over&&(s.push(function(e){return function(t){e._trigger("out",t,this._uiHash(this))}}.call(this,this.containers[a])),this.containers[a].containerCache.over=0);if(this._storedCursor&&e("body").css("cursor",this._storedCursor),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"==this._storedZIndex?"":this._storedZIndex),this.dragging=!1,this.cancelHelperRemoval){if(!i){this._trigger("beforeStop",t,this._uiHash());for(var a=0;s.length>a;a++)s[a].call(this,t);this._trigger("stop",t,this._uiHash())}return this.fromOutside=!1,!1}if(i||this._trigger("beforeStop",t,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.helper[0]!=this.currentItem[0]&&this.helper.remove(),this.helper=null,!i){for(var a=0;s.length>a;a++)s[a].call(this,t);this._trigger("stop",t,this._uiHash())}return this.fromOutside=!1,!0},_trigger:function(){e.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(t){var i=t||this;return{helper:i.helper,placeholder:i.placeholder||e([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:t?t.element:null}}})})(jQuery);/*!
* Bootstrap.js by @fat & @mdo
* Copyright 2012 Twitter, Inc.
* http://www.apache.org/licenses/LICENSE-2.0.txt
*/
!function(e){"use strict";e(function(){e.support.transition=function(){var e=function(){var e=document.createElement("bootstrap"),t={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"},n;for(n in t)if(e.style[n]!==undefined)return t[n]}();return e&&{end:e}}()})}(window.jQuery),!function(e){"use strict";var t='[data-dismiss="alert"]',n=function(n){e(n).on("click",t,this.close)};n.prototype.close=function(t){function s(){i.trigger("closed").remove()}var n=e(this),r=n.attr("data-target"),i;r||(r=n.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,"")),i=e(r),t&&t.preventDefault(),i.length||(i=n.hasClass("alert")?n:n.parent()),i.trigger(t=e.Event("close"));if(t.isDefaultPrevented())return;i.removeClass("in"),e.support.transition&&i.hasClass("fade")?i.on(e.support.transition.end,s):s()};var r=e.fn.alert;e.fn.alert=function(t){return this.each(function(){var r=e(this),i=r.data("alert");i||r.data("alert",i=new n(this)),typeof t=="string"&&i[t].call(r)})},e.fn.alert.Constructor=n,e.fn.alert.noConflict=function(){return e.fn.alert=r,this},e(document).on("click.alert.data-api",t,n.prototype.close)}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.button.defaults,n)};t.prototype.setState=function(e){var t="disabled",n=this.$element,r=n.data(),i=n.is("input")?"val":"html";e+="Text",r.resetText||n.data("resetText",n[i]()),n[i](r[e]||this.options[e]),setTimeout(function(){e=="loadingText"?n.addClass(t).attr(t,t):n.removeClass(t).removeAttr(t)},0)},t.prototype.toggle=function(){var e=this.$element.closest('[data-toggle="buttons-radio"]');e&&e.find(".active").removeClass("active"),this.$element.toggleClass("active")};var n=e.fn.button;e.fn.button=function(n){return this.each(function(){var r=e(this),i=r.data("button"),s=typeof n=="object"&&n;i||r.data("button",i=new t(this,s)),n=="toggle"?i.toggle():n&&i.setState(n)})},e.fn.button.defaults={loadingText:"loading..."},e.fn.button.Constructor=t,e.fn.button.noConflict=function(){return e.fn.button=n,this},e(document).on("click.button.data-api","[data-toggle^=button]",function(t){var n=e(t.target);n.hasClass("btn")||(n=n.closest(".btn")),n.button("toggle")})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.$indicators=this.$element.find(".carousel-indicators"),this.options=n,this.options.pause=="hover"&&this.$element.on("mouseenter",e.proxy(this.pause,this)).on("mouseleave",e.proxy(this.cycle,this))};t.prototype={cycle:function(t){return t||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(e.proxy(this.next,this),this.options.interval)),this},getActiveIndex:function(){return this.$active=this.$element.find(".item.active"),this.$items=this.$active.parent().children(),this.$items.index(this.$active)},to:function(t){var n=this.getActiveIndex(),r=this;if(t>this.$items.length-1||t<0)return;return this.sliding?this.$element.one("slid",function(){r.to(t)}):n==t?this.pause().cycle():this.slide(t>n?"next":"prev",e(this.$items[t]))},pause:function(t){return t||(this.paused=!0),this.$element.find(".next, .prev").length&&e.support.transition.end&&(this.$element.trigger(e.support.transition.end),this.cycle(!0)),clearInterval(this.interval),this.interval=null,this},next:function(){if(this.sliding)return;return this.slide("next")},prev:function(){if(this.sliding)return;return this.slide("prev")},slide:function(t,n){var r=this.$element.find(".item.active"),i=n||r[t](),s=this.interval,o=t=="next"?"left":"right",u=t=="next"?"first":"last",a=this,f;this.sliding=!0,s&&this.pause(),i=i.length?i:this.$element.find(".item")[u](),f=e.Event("slide",{relatedTarget:i[0],direction:o});if(i.hasClass("active"))return;this.$indicators.length&&(this.$indicators.find(".active").removeClass("active"),this.$element.one("slid",function(){var t=e(a.$indicators.children()[a.getActiveIndex()]);t&&t.addClass("active")}));if(e.support.transition&&this.$element.hasClass("slide")){this.$element.trigger(f);if(f.isDefaultPrevented())return;i.addClass(t),i[0].offsetWidth,r.addClass(o),i.addClass(o),this.$element.one(e.support.transition.end,function(){i.removeClass([t,o].join(" ")).addClass("active"),r.removeClass(["active",o].join(" ")),a.sliding=!1,setTimeout(function(){a.$element.trigger("slid")},0)})}else{this.$element.trigger(f);if(f.isDefaultPrevented())return;r.removeClass("active"),i.addClass("active"),this.sliding=!1,this.$element.trigger("slid")}return s&&this.cycle(),this}};var n=e.fn.carousel;e.fn.carousel=function(n){return this.each(function(){var r=e(this),i=r.data("carousel"),s=e.extend({},e.fn.carousel.defaults,typeof n=="object"&&n),o=typeof n=="string"?n:s.slide;i||r.data("carousel",i=new t(this,s)),typeof n=="number"?i.to(n):o?i[o]():s.interval&&i.pause().cycle()})},e.fn.carousel.defaults={interval:5e3,pause:"hover"},e.fn.carousel.Constructor=t,e.fn.carousel.noConflict=function(){return e.fn.carousel=n,this},e(document).on("click.carousel.data-api","[data-slide], [data-slide-to]",function(t){var n=e(this),r,i=e(n.attr("data-target")||(r=n.attr("href"))&&r.replace(/.*(?=#[^\s]+$)/,"")),s=e.extend({},i.data(),n.data()),o;i.carousel(s),(o=n.attr("data-slide-to"))&&i.data("carousel").pause().to(o).cycle(),t.preventDefault()})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.collapse.defaults,n),this.options.parent&&(this.$parent=e(this.options.parent)),this.options.toggle&&this.toggle()};t.prototype={constructor:t,dimension:function(){var e=this.$element.hasClass("width");return e?"width":"height"},show:function(){var t,n,r,i;if(this.transitioning||this.$element.hasClass("in"))return;t=this.dimension(),n=e.camelCase(["scroll",t].join("-")),r=this.$parent&&this.$parent.find("> .accordion-group > .in");if(r&&r.length){i=r.data("collapse");if(i&&i.transitioning)return;r.collapse("hide"),i||r.data("collapse",null)}this.$element[t](0),this.transition("addClass",e.Event("show"),"shown"),e.support.transition&&this.$element[t](this.$element[0][n])},hide:function(){var t;if(this.transitioning||!this.$element.hasClass("in"))return;t=this.dimension(),this.reset(this.$element[t]()),this.transition("removeClass",e.Event("hide"),"hidden"),this.$element[t](0)},reset:function(e){var t=this.dimension();return this.$element.removeClass("collapse")[t](e||"auto")[0].offsetWidth,this.$element[e!==null?"addClass":"removeClass"]("collapse"),this},transition:function(t,n,r){var i=this,s=function(){n.type=="show"&&i.reset(),i.transitioning=0,i.$element.trigger(r)};this.$element.trigger(n);if(n.isDefaultPrevented())return;this.transitioning=1,this.$element[t]("in"),e.support.transition&&this.$element.hasClass("collapse")?this.$element.one(e.support.transition.end,s):s()},toggle:function(){this[this.$element.hasClass("in")?"hide":"show"]()}};var n=e.fn.collapse;e.fn.collapse=function(n){return this.each(function(){var r=e(this),i=r.data("collapse"),s=e.extend({},e.fn.collapse.defaults,r.data(),typeof n=="object"&&n);i||r.data("collapse",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.collapse.defaults={toggle:!0},e.fn.collapse.Constructor=t,e.fn.collapse.noConflict=function(){return e.fn.collapse=n,this},e(document).on("click.collapse.data-api","[data-toggle=collapse]",function(t){var n=e(this),r,i=n.attr("data-target")||t.preventDefault()||(r=n.attr("href"))&&r.replace(/.*(?=#[^\s]+$)/,""),s=e(i).data("collapse")?"toggle":n.data();n[e(i).hasClass("in")?"addClass":"removeClass"]("collapsed"),e(i).collapse(s)})}(window.jQuery),!function(e){"use strict";function r(){e(t).each(function(){i(e(this)).removeClass("open")})}function i(t){var n=t.attr("data-target"),r;n||(n=t.attr("href"),n=n&&/#/.test(n)&&n.replace(/.*(?=#[^\s]*$)/,"")),r=n&&e(n);if(!r||!r.length)r=t.parent();return r}var t="[data-toggle=dropdown]",n=function(t){var n=e(t).on("click.dropdown.data-api",this.toggle);e("html").on("click.dropdown.data-api",function(){n.parent().removeClass("open")})};n.prototype={constructor:n,toggle:function(t){var n=e(this),s,o;if(n.is(".disabled, :disabled"))return;return s=i(n),o=s.hasClass("open"),r(),o||s.toggleClass("open"),n.focus(),!1},keydown:function(n){var r,s,o,u,a,f;if(!/(38|40|27)/.test(n.keyCode))return;r=e(this),n.preventDefault(),n.stopPropagation();if(r.is(".disabled, :disabled"))return;u=i(r),a=u.hasClass("open");if(!a||a&&n.keyCode==27)return n.which==27&&u.find(t).focus(),r.click();s=e("[role=menu] li:not(.divider):visible a",u);if(!s.length)return;f=s.index(s.filter(":focus")),n.keyCode==38&&f>0&&f--,n.keyCode==40&&f<s.length-1&&f++,~f||(f=0),s.eq(f).focus()}};var s=e.fn.dropdown;e.fn.dropdown=function(t){return this.each(function(){var r=e(this),i=r.data("dropdown");i||r.data("dropdown",i=new n(this)),typeof t=="string"&&i[t].call(r)})},e.fn.dropdown.Constructor=n,e.fn.dropdown.noConflict=function(){return e.fn.dropdown=s,this},e(document).on("click.dropdown.data-api",r).on("click.dropdown.data-api",".dropdown form",function(e){e.stopPropagation()}).on("click.dropdown-menu",function(e){e.stopPropagation()}).on("click.dropdown.data-api",t,n.prototype.toggle).on("keydown.dropdown.data-api",t+", [role=menu]",n.prototype.keydown)}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.options=n,this.$element=e(t).delegate('[data-dismiss="modal"]',"click.dismiss.modal",e.proxy(this.hide,this)),this.options.remote&&this.$element.find(".modal-body").load(this.options.remote)};t.prototype={constructor:t,toggle:function(){return this[this.isShown?"hide":"show"]()},show:function(){var t=this,n=e.Event("show");this.$element.trigger(n);if(this.isShown||n.isDefaultPrevented())return;this.isShown=!0,this.escape(),this.backdrop(function(){var n=e.support.transition&&t.$element.hasClass("fade");t.$element.parent().length||t.$element.appendTo(document.body),t.$element.show(),n&&t.$element[0].offsetWidth,t.$element.addClass("in").attr("aria-hidden",!1),t.enforceFocus(),n?t.$element.one(e.support.transition.end,function(){t.$element.focus().trigger("shown")}):t.$element.focus().trigger("shown")})},hide:function(t){t&&t.preventDefault();var n=this;t=e.Event("hide"),this.$element.trigger(t);if(!this.isShown||t.isDefaultPrevented())return;this.isShown=!1,this.escape(),e(document).off("focusin.modal"),this.$element.removeClass("in").attr("aria-hidden",!0),e.support.transition&&this.$element.hasClass("fade")?this.hideWithTransition():this.hideModal()},enforceFocus:function(){var t=this;e(document).on("focusin.modal",function(e){t.$element[0]!==e.target&&!t.$element.has(e.target).length&&t.$element.focus()})},escape:function(){var e=this;this.isShown&&this.options.keyboard?this.$element.on("keyup.dismiss.modal",function(t){t.which==27&&e.hide()}):this.isShown||this.$element.off("keyup.dismiss.modal")},hideWithTransition:function(){var t=this,n=setTimeout(function(){t.$element.off(e.support.transition.end),t.hideModal()},500);this.$element.one(e.support.transition.end,function(){clearTimeout(n),t.hideModal()})},hideModal:function(){var e=this;this.$element.hide(),this.backdrop(function(){e.removeBackdrop(),e.$element.trigger("hidden")})},removeBackdrop:function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},backdrop:function(t){var n=this,r=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var i=e.support.transition&&r;this.$backdrop=e('<div class="modal-backdrop '+r+'" />').appendTo(document.body),this.$backdrop.click(this.options.backdrop=="static"?e.proxy(this.$element[0].focus,this.$element[0]):e.proxy(this.hide,this)),i&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in");if(!t)return;i?this.$backdrop.one(e.support.transition.end,t):t()}else!this.isShown&&this.$backdrop?(this.$backdrop.removeClass("in"),e.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one(e.support.transition.end,t):t()):t&&t()}};var n=e.fn.modal;e.fn.modal=function(n){return this.each(function(){var r=e(this),i=r.data("modal"),s=e.extend({},e.fn.modal.defaults,r.data(),typeof n=="object"&&n);i||r.data("modal",i=new t(this,s)),typeof n=="string"?i[n]():s.show&&i.show()})},e.fn.modal.defaults={backdrop:!0,keyboard:!0,show:!0},e.fn.modal.Constructor=t,e.fn.modal.noConflict=function(){return e.fn.modal=n,this},e(document).on("click.modal.data-api",'[data-toggle="modal"]',function(t){var n=e(this),r=n.attr("href"),i=e(n.attr("data-target")||r&&r.replace(/.*(?=#[^\s]+$)/,"")),s=i.data("modal")?"toggle":e.extend({remote:!/#/.test(r)&&r},i.data(),n.data());t.preventDefault(),i.modal(s).one("hide",function(){n.focus()})})}(window.jQuery),!function(e){"use strict";var t=function(e,t){this.init("tooltip",e,t)};t.prototype={constructor:t,init:function(t,n,r){var i,s,o,u,a;this.type=t,this.$element=e(n),this.options=this.getOptions(r),this.enabled=!0,o=this.options.trigger.split(" ");for(a=o.length;a--;)u=o[a],u=="click"?this.$element.on("click."+this.type,this.options.selector,e.proxy(this.toggle,this)):u!="manual"&&(i=u=="hover"?"mouseenter":"focus",s=u=="hover"?"mouseleave":"blur",this.$element.on(i+"."+this.type,this.options.selector,e.proxy(this.enter,this)),this.$element.on(s+"."+this.type,this.options.selector,e.proxy(this.leave,this)));this.options.selector?this._options=e.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},getOptions:function(t){return t=e.extend({},e.fn[this.type].defaults,this.$element.data(),t),t.delay&&typeof t.delay=="number"&&(t.delay={show:t.delay,hide:t.delay}),t},enter:function(t){var n=e.fn[this.type].defaults,r={},i;this._options&&e.each(this._options,function(e,t){n[e]!=t&&(r[e]=t)},this),i=e(t.currentTarget)[this.type](r).data(this.type);if(!i.options.delay||!i.options.delay.show)return i.show();clearTimeout(this.timeout),i.hoverState="in",this.timeout=setTimeout(function(){i.hoverState=="in"&&i.show()},i.options.delay.show)},leave:function(t){var n=e(t.currentTarget)[this.type](this._options).data(this.type);this.timeout&&clearTimeout(this.timeout);if(!n.options.delay||!n.options.delay.hide)return n.hide();n.hoverState="out",this.timeout=setTimeout(function(){n.hoverState=="out"&&n.hide()},n.options.delay.hide)},show:function(){var t,n,r,i,s,o,u=e.Event("show");if(this.hasContent()&&this.enabled){this.$element.trigger(u);if(u.isDefaultPrevented())return;t=this.tip(),this.setContent(),this.options.animation&&t.addClass("fade"),s=typeof this.options.placement=="function"?this.options.placement.call(this,t[0],this.$element[0]):this.options.placement,t.detach().css({top:0,left:0,display:"block"}),this.options.container?t.appendTo(this.options.container):t.insertAfter(this.$element),n=this.getPosition(),r=t[0].offsetWidth,i=t[0].offsetHeight;switch(s){case"bottom":o={top:n.top+n.height,left:n.left+n.width/2-r/2};break;case"top":o={top:n.top-i,left:n.left+n.width/2-r/2};break;case"left":o={top:n.top+n.height/2-i/2,left:n.left-r};break;case"right":o={top:n.top+n.height/2-i/2,left:n.left+n.width}}this.applyPlacement(o,s),this.$element.trigger("shown")}},applyPlacement:function(e,t){var n=this.tip(),r=n[0].offsetWidth,i=n[0].offsetHeight,s,o,u,a;n.offset(e).addClass(t).addClass("in"),s=n[0].offsetWidth,o=n[0].offsetHeight,t=="top"&&o!=i&&(e.top=e.top+i-o,a=!0),t=="bottom"||t=="top"?(u=0,e.left<0&&(u=e.left*-2,e.left=0,n.offset(e),s=n[0].offsetWidth,o=n[0].offsetHeight),this.replaceArrow(u-r+s,s,"left")):this.replaceArrow(o-i,o,"top"),a&&n.offset(e)},replaceArrow:function(e,t,n){this.arrow().css(n,e?50*(1-e/t)+"%":"")},setContent:function(){var e=this.tip(),t=this.getTitle();e.find(".tooltip-inner")[this.options.html?"html":"text"](t),e.removeClass("fade in top bottom left right")},hide:function(){function i(){var t=setTimeout(function(){n.off(e.support.transition.end).detach()},500);n.one(e.support.transition.end,function(){clearTimeout(t),n.detach()})}var t=this,n=this.tip(),r=e.Event("hide");this.$element.trigger(r);if(r.isDefaultPrevented())return;return n.removeClass("in"),e.support.transition&&this.$tip.hasClass("fade")?i():n.detach(),this.$element.trigger("hidden"),this},fixTitle:function(){var e=this.$element;(e.attr("title")||typeof e.attr("data-original-title")!="string")&&e.attr("data-original-title",e.attr("title")||"").attr("title","")},hasContent:function(){return this.getTitle()},getPosition:function(){var t=this.$element[0];return e.extend({},typeof t.getBoundingClientRect=="function"?t.getBoundingClientRect():{width:t.offsetWidth,height:t.offsetHeight},this.$element.offset())},getTitle:function(){var e,t=this.$element,n=this.options;return e=t.attr("data-original-title")||(typeof n.title=="function"?n.title.call(t[0]):n.title),e},tip:function(){return this.$tip=this.$tip||e(this.options.template)},arrow:function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},validate:function(){this.$element[0].parentNode||(this.hide(),this.$element=null,this.options=null)},enable:function(){this.enabled=!0},disable:function(){this.enabled=!1},toggleEnabled:function(){this.enabled=!this.enabled},toggle:function(t){var n=t?e(t.currentTarget)[this.type](this._options).data(this.type):this;n.tip().hasClass("in")?n.hide():n.show()},destroy:function(){this.hide().$element.off("."+this.type).removeData(this.type)}};var n=e.fn.tooltip;e.fn.tooltip=function(n){return this.each(function(){var r=e(this),i=r.data("tooltip"),s=typeof n=="object"&&n;i||r.data("tooltip",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.tooltip.Constructor=t,e.fn.tooltip.defaults={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1},e.fn.tooltip.noConflict=function(){return e.fn.tooltip=n,this}}(window.jQuery),!function(e){"use strict";var t=function(e,t){this.init("popover",e,t)};t.prototype=e.extend({},e.fn.tooltip.Constructor.prototype,{constructor:t,setContent:function(){var e=this.tip(),t=this.getTitle(),n=this.getContent();e.find(".popover-title")[this.options.html?"html":"text"](t),e.find(".popover-content")[this.options.html?"html":"text"](n),e.removeClass("fade top bottom left right in")},hasContent:function(){return this.getTitle()||this.getContent()},getContent:function(){var e,t=this.$element,n=this.options;return e=(typeof n.content=="function"?n.content.call(t[0]):n.content)||t.attr("data-content"),e},tip:function(){return this.$tip||(this.$tip=e(this.options.template)),this.$tip},destroy:function(){this.hide().$element.off("."+this.type).removeData(this.type)}});var n=e.fn.popover;e.fn.popover=function(n){return this.each(function(){var r=e(this),i=r.data("popover"),s=typeof n=="object"&&n;i||r.data("popover",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.popover.Constructor=t,e.fn.popover.defaults=e.extend({},e.fn.tooltip.defaults,{placement:"right",trigger:"click",content:"",template:'<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),e.fn.popover.noConflict=function(){return e.fn.popover=n,this}}(window.jQuery),!function(e){"use strict";function t(t,n){var r=e.proxy(this.process,this),i=e(t).is("body")?e(window):e(t),s;this.options=e.extend({},e.fn.scrollspy.defaults,n),this.$scrollElement=i.on("scroll.scroll-spy.data-api",r),this.selector=(this.options.target||(s=e(t).attr("href"))&&s.replace(/.*(?=#[^\s]+$)/,"")||"")+" .nav li > a",this.$body=e("body"),this.refresh(),this.process()}t.prototype={constructor:t,refresh:function(){var t=this,n;this.offsets=e([]),this.targets=e([]),n=this.$body.find(this.selector).map(function(){var n=e(this),r=n.data("target")||n.attr("href"),i=/^#\w/.test(r)&&e(r);return i&&i.length&&[[i.position().top+(!e.isWindow(t.$scrollElement.get(0))&&t.$scrollElement.scrollTop()),r]]||null}).sort(function(e,t){return e[0]-t[0]}).each(function(){t.offsets.push(this[0]),t.targets.push(this[1])})},process:function(){var e=this.$scrollElement.scrollTop()+this.options.offset,t=this.$scrollElement[0].scrollHeight||this.$body[0].scrollHeight,n=t-this.$scrollElement.height(),r=this.offsets,i=this.targets,s=this.activeTarget,o;if(e>=n)return s!=(o=i.last()[0])&&this.activate(o);for(o=r.length;o--;)s!=i[o]&&e>=r[o]&&(!r[o+1]||e<=r[o+1])&&this.activate(i[o])},activate:function(t){var n,r;this.activeTarget=t,e(this.selector).parent(".active").removeClass("active"),r=this.selector+'[data-target="'+t+'"],'+this.selector+'[href="'+t+'"]',n=e(r).parent("li").addClass("active"),n.parent(".dropdown-menu").length&&(n=n.closest("li.dropdown").addClass("active")),n.trigger("activate")}};var n=e.fn.scrollspy;e.fn.scrollspy=function(n){return this.each(function(){var r=e(this),i=r.data("scrollspy"),s=typeof n=="object"&&n;i||r.data("scrollspy",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.scrollspy.Constructor=t,e.fn.scrollspy.defaults={offset:10},e.fn.scrollspy.noConflict=function(){return e.fn.scrollspy=n,this},e(window).on("load",function(){e('[data-spy="scroll"]').each(function(){var t=e(this);t.scrollspy(t.data())})})}(window.jQuery),!function(e){"use strict";var t=function(t){this.element=e(t)};t.prototype={constructor:t,show:function(){var t=this.element,n=t.closest("ul:not(.dropdown-menu)"),r=t.attr("data-target"),i,s,o;r||(r=t.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,""));if(t.parent("li").hasClass("active"))return;i=n.find(".active:last a")[0],o=e.Event("show",{relatedTarget:i}),t.trigger(o);if(o.isDefaultPrevented())return;s=e(r),this.activate(t.parent("li"),n),this.activate(s,s.parent(),function(){t.trigger({type:"shown",relatedTarget:i})})},activate:function(t,n,r){function o(){i.removeClass("active").find("> .dropdown-menu > .active").removeClass("active"),t.addClass("active"),s?(t[0].offsetWidth,t.addClass("in")):t.removeClass("fade"),t.parent(".dropdown-menu")&&t.closest("li.dropdown").addClass("active"),r&&r()}var i=n.find("> .active"),s=r&&e.support.transition&&i.hasClass("fade");s?i.one(e.support.transition.end,o):o(),i.removeClass("in")}};var n=e.fn.tab;e.fn.tab=function(n){return this.each(function(){var r=e(this),i=r.data("tab");i||r.data("tab",i=new t(this)),typeof n=="string"&&i[n]()})},e.fn.tab.Constructor=t,e.fn.tab.noConflict=function(){return e.fn.tab=n,this},e(document).on("click.tab.data-api",'[data-toggle="tab"], [data-toggle="pill"]',function(t){t.preventDefault(),e(this).tab("show")})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.typeahead.defaults,n),this.matcher=this.options.matcher||this.matcher,this.sorter=this.options.sorter||this.sorter,this.highlighter=this.options.highlighter||this.highlighter,this.updater=this.options.updater||this.updater,this.source=this.options.source,this.$menu=e(this.options.menu),this.shown=!1,this.listen()};t.prototype={constructor:t,select:function(){var e=this.$menu.find(".active").attr("data-value");return this.$element.val(this.updater(e)).change(),this.hide()},updater:function(e){return e},show:function(){var t=e.extend({},this.$element.position(),{height:this.$element[0].offsetHeight});return this.$menu.insertAfter(this.$element).css({top:t.top+t.height,left:t.left}).show(),this.shown=!0,this},hide:function(){return this.$menu.hide(),this.shown=!1,this},lookup:function(t){var n;return this.query=this.$element.val(),!this.query||this.query.length<this.options.minLength?this.shown?this.hide():this:(n=e.isFunction(this.source)?this.source(this.query,e.proxy(this.process,this)):this.source,n?this.process(n):this)},process:function(t){var n=this;return t=e.grep(t,function(e){return n.matcher(e)}),t=this.sorter(t),t.length?this.render(t.slice(0,this.options.items)).show():this.shown?this.hide():this},matcher:function(e){return~e.toLowerCase().indexOf(this.query.toLowerCase())},sorter:function(e){var t=[],n=[],r=[],i;while(i=e.shift())i.toLowerCase().indexOf(this.query.toLowerCase())?~i.indexOf(this.query)?n.push(i):r.push(i):t.push(i);return t.concat(n,r)},highlighter:function(e){var t=this.query.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&");return e.replace(new RegExp("("+t+")","ig"),function(e,t){return"<strong>"+t+"</strong>"})},render:function(t){var n=this;return t=e(t).map(function(t,r){return t=e(n.options.item).attr("data-value",r),t.find("a").html(n.highlighter(r)),t[0]}),t.first().addClass("active"),this.$menu.html(t),this},next:function(t){var n=this.$menu.find(".active").removeClass("active"),r=n.next();r.length||(r=e(this.$menu.find("li")[0])),r.addClass("active")},prev:function(e){var t=this.$menu.find(".active").removeClass("active"),n=t.prev();n.length||(n=this.$menu.find("li").last()),n.addClass("active")},listen:function(){this.$element.on("focus",e.proxy(this.focus,this)).on("blur",e.proxy(this.blur,this)).on("keypress",e.proxy(this.keypress,this)).on("keyup",e.proxy(this.keyup,this)),this.eventSupported("keydown")&&this.$element.on("keydown",e.proxy(this.keydown,this)),this.$menu.on("click",e.proxy(this.click,this)).on("mouseenter","li",e.proxy(this.mouseenter,this)).on("mouseleave","li",e.proxy(this.mouseleave,this))},eventSupported:function(e){var t=e in this.$element;return t||(this.$element.setAttribute(e,"return;"),t=typeof this.$element[e]=="function"),t},move:function(e){if(!this.shown)return;switch(e.keyCode){case 9:case 13:case 27:e.preventDefault();break;case 38:e.preventDefault(),this.prev();break;case 40:e.preventDefault(),this.next()}e.stopPropagation()},keydown:function(t){this.suppressKeyPressRepeat=~e.inArray(t.keyCode,[40,38,9,13,27]),this.move(t)},keypress:function(e){if(this.suppressKeyPressRepeat)return;this.move(e)},keyup:function(e){switch(e.keyCode){case 40:case 38:case 16:case 17:case 18:break;case 9:case 13:if(!this.shown)return;this.select();break;case 27:if(!this.shown)return;this.hide();break;default:this.lookup()}e.stopPropagation(),e.preventDefault()},focus:function(e){this.focused=!0},blur:function(e){this.focused=!1,!this.mousedover&&this.shown&&this.hide()},click:function(e){e.stopPropagation(),e.preventDefault(),this.select(),this.$element.focus()},mouseenter:function(t){this.mousedover=!0,this.$menu.find(".active").removeClass("active"),e(t.currentTarget).addClass("active")},mouseleave:function(e){this.mousedover=!1,!this.focused&&this.shown&&this.hide()}};var n=e.fn.typeahead;e.fn.typeahead=function(n){return this.each(function(){var r=e(this),i=r.data("typeahead"),s=typeof n=="object"&&n;i||r.data("typeahead",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.typeahead.defaults={source:[],items:8,menu:'<ul class="typeahead dropdown-menu"></ul>',item:'<li><a href="#"></a></li>',minLength:1},e.fn.typeahead.Constructor=t,e.fn.typeahead.noConflict=function(){return e.fn.typeahead=n,this},e(document).on("focus.typeahead.data-api",'[data-provide="typeahead"]',function(t){var n=e(this);if(n.data("typeahead"))return;n.typeahead(n.data())})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.options=e.extend({},e.fn.affix.defaults,n),this.$window=e(window).on("scroll.affix.data-api",e.proxy(this.checkPosition,this)).on("click.affix.data-api",e.proxy(function(){setTimeout(e.proxy(this.checkPosition,this),1)},this)),this.$element=e(t),this.checkPosition()};t.prototype.checkPosition=function(){if(!this.$element.is(":visible"))return;var t=e(document).height(),n=this.$window.scrollTop(),r=this.$element.offset(),i=this.options.offset,s=i.bottom,o=i.top,u="affix affix-top affix-bottom",a;typeof i!="object"&&(s=o=i),typeof o=="function"&&(o=i.top()),typeof s=="function"&&(s=i.bottom()),a=this.unpin!=null&&n+this.unpin<=r.top?!1:s!=null&&r.top+this.$element.height()>=t-s?"bottom":o!=null&&n<=o?"top":!1;if(this.affixed===a)return;this.affixed=a,this.unpin=a=="bottom"?r.top-n:null,this.$element.removeClass(u).addClass("affix"+(a?"-"+a:""))};var n=e.fn.affix;e.fn.affix=function(n){return this.each(function(){var r=e(this),i=r.data("affix"),s=typeof n=="object"&&n;i||r.data("affix",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.affix.Constructor=t,e.fn.affix.defaults={offset:0},e.fn.affix.noConflict=function(){return e.fn.affix=n,this},e(window).on("load",function(){e('[data-spy="affix"]').each(function(){var t=e(this),n=t.data();n.offset=n.offset||{},n.offsetBottom&&(n.offset.bottom=n.offsetBottom),n.offsetTop&&(n.offset.top=n.offsetTop),t.affix(n)})})}(window.jQuery);/*! 
 * jquery.event.drag - v 2.2
 * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com
 * Open Source MIT License - http://threedubmedia.com/code/license
 */
// Created: 2008-06-04 
// Updated: 2012-05-21
// REQUIRES: jquery 1.7.x

;(function( $ ){

// add the jquery instance method
$.fn.drag = function( str, arg, opts ){
	// figure out the event type
	var type = typeof str == "string" ? str : "",
	// figure out the event handler...
	fn = $.isFunction( str ) ? str : $.isFunction( arg ) ? arg : null;
	// fix the event type
	if ( type.indexOf("drag") !== 0 ) 
		type = "drag"+ type;
	// were options passed
	opts = ( str == fn ? arg : opts ) || {};
	// trigger or bind event handler
	return fn ? this.bind( type, opts, fn ) : this.trigger( type );
};

// local refs (increase compression)
var $event = $.event, 
$special = $event.special,
// configure the drag special event 
drag = $special.drag = {
	
	// these are the default settings
	defaults: {
		which: 1, // mouse button pressed to start drag sequence
		distance: 0, // distance dragged before dragstart
		not: ':input', // selector to suppress dragging on target elements
		handle: null, // selector to match handle target elements
		relative: false, // true to use "position", false to use "offset"
		drop: true, // false to suppress drop events, true or selector to allow
		click: false // false to suppress click events after dragend (no proxy)
	},
	
	// the key name for stored drag data
	datakey: "dragdata",
	
	// prevent bubbling for better performance
	noBubble: true,
	
	// count bound related events
	add: function( obj ){ 
		// read the interaction data
		var data = $.data( this, drag.datakey ),
		// read any passed options 
		opts = obj.data || {};
		// count another realted event
		data.related += 1;
		// extend data options bound with this event
		// don't iterate "opts" in case it is a node 
		$.each( drag.defaults, function( key, def ){
			if ( opts[ key ] !== undefined )
				data[ key ] = opts[ key ];
		});
	},
	
	// forget unbound related events
	remove: function(){
		$.data( this, drag.datakey ).related -= 1;
	},
	
	// configure interaction, capture settings
	setup: function(){
		// check for related events
		if ( $.data( this, drag.datakey ) ) 
			return;
		// initialize the drag data with copied defaults
		var data = $.extend({ related:0 }, drag.defaults );
		// store the interaction data
		$.data( this, drag.datakey, data );
		// bind the mousedown event, which starts drag interactions
		$event.add( this, "touchstart mousedown", drag.init, data );
		// prevent image dragging in IE...
		if ( this.attachEvent ) 
			this.attachEvent("ondragstart", drag.dontstart ); 
	},
	
	// destroy configured interaction
	teardown: function(){
		var data = $.data( this, drag.datakey ) || {};
		// check for related events
		if ( data.related ) 
			return;
		// remove the stored data
		$.removeData( this, drag.datakey );
		// remove the mousedown event
		$event.remove( this, "touchstart mousedown", drag.init );
		// enable text selection
		drag.textselect( true ); 
		// un-prevent image dragging in IE...
		if ( this.detachEvent ) 
			this.detachEvent("ondragstart", drag.dontstart ); 
	},
		
	// initialize the interaction
	init: function( event ){ 
		// sorry, only one touch at a time
		if ( drag.touched ) 
			return;
		// the drag/drop interaction data
		var dd = event.data, results;
		// check the which directive
		if ( event.which != 0 && dd.which > 0 && event.which != dd.which ) 
			return; 
		// check for suppressed selector
		if ( $( event.target ).is( dd.not ) ) 
			return;
		// check for handle selector
		if ( dd.handle && !$( event.target ).closest( dd.handle, event.currentTarget ).length ) 
			return;

		drag.touched = event.type == 'touchstart' ? this : null;
		dd.propagates = 1;
		dd.mousedown = this;
		dd.interactions = [ drag.interaction( this, dd ) ];
		dd.target = event.target;
		dd.pageX = event.pageX;
		dd.pageY = event.pageY;
		dd.dragging = null;
		// handle draginit event... 
		results = drag.hijack( event, "draginit", dd );
		// early cancel
		if ( !dd.propagates )
			return;
		// flatten the result set
		results = drag.flatten( results );
		// insert new interaction elements
		if ( results && results.length ){
			dd.interactions = [];
			$.each( results, function(){
				dd.interactions.push( drag.interaction( this, dd ) );
			});
		}
		// remember how many interactions are propagating
		dd.propagates = dd.interactions.length;
		// locate and init the drop targets
		if ( dd.drop !== false && $special.drop ) 
			$special.drop.handler( event, dd );
		// disable text selection
		drag.textselect( false ); 
		// bind additional events...
		if ( drag.touched )
			$event.add( drag.touched, "touchmove touchend", drag.handler, dd );
		else 
			$event.add( document, "mousemove mouseup", drag.handler, dd );
		// helps prevent text selection or scrolling
		if ( !drag.touched || dd.live )
			return false;
	},	
	
	// returns an interaction object
	interaction: function( elem, dd ){
		var offset = $( elem )[ dd.relative ? "position" : "offset" ]() || { top:0, left:0 };
		return {
			drag: elem, 
			callback: new drag.callback(), 
			droppable: [],
			offset: offset
		};
	},
	
	// handle drag-releatd DOM events
	handler: function( event ){ 
		// read the data before hijacking anything
		var dd = event.data;	
		// handle various events
		switch ( event.type ){
			// mousemove, check distance, start dragging
			case !dd.dragging && 'touchmove': 
				event.preventDefault();
			case !dd.dragging && 'mousemove':
				//  drag tolerance, x� + y� = distance�
				if ( Math.pow(  event.pageX-dd.pageX, 2 ) + Math.pow(  event.pageY-dd.pageY, 2 ) < Math.pow( dd.distance, 2 ) ) 
					break; // distance tolerance not reached
				event.target = dd.target; // force target from "mousedown" event (fix distance issue)
				drag.hijack( event, "dragstart", dd ); // trigger "dragstart"
				if ( dd.propagates ) // "dragstart" not rejected
					dd.dragging = true; // activate interaction
			// mousemove, dragging
			case 'touchmove':
				event.preventDefault();
			case 'mousemove':
				if ( dd.dragging ){
					// trigger "drag"		
					drag.hijack( event, "drag", dd );
					if ( dd.propagates ){
						// manage drop events
						if ( dd.drop !== false && $special.drop )
							$special.drop.handler( event, dd ); // "dropstart", "dropend"							
						break; // "drag" not rejected, stop		
					}
					event.type = "mouseup"; // helps "drop" handler behave
				}
			// mouseup, stop dragging
			case 'touchend': 
			case 'mouseup': 
			default:
				if ( drag.touched )
					$event.remove( drag.touched, "touchmove touchend", drag.handler ); // remove touch events
				else 
					$event.remove( document, "mousemove mouseup", drag.handler ); // remove page events	
				if ( dd.dragging ){
					if ( dd.drop !== false && $special.drop )
						$special.drop.handler( event, dd ); // "drop"
					drag.hijack( event, "dragend", dd ); // trigger "dragend"	
				}
				drag.textselect( true ); // enable text selection
				// if suppressing click events...
				if ( dd.click === false && dd.dragging )
					$.data( dd.mousedown, "suppress.click", new Date().getTime() + 5 );
				dd.dragging = drag.touched = false; // deactivate element	
				break;
		}
	},
		
	// re-use event object for custom events
	hijack: function( event, type, dd, x, elem ){
		// not configured
		if ( !dd ) 
			return;
		// remember the original event and type
		var orig = { event:event.originalEvent, type:event.type },
		// is the event drag related or drog related?
		mode = type.indexOf("drop") ? "drag" : "drop",
		// iteration vars
		result, i = x || 0, ia, $elems, callback,
		len = !isNaN( x ) ? x : dd.interactions.length;
		// modify the event type
		event.type = type;
		// remove the original event
		event.originalEvent = null;
		// initialize the results
		dd.results = [];
		// handle each interacted element
		do if ( ia = dd.interactions[ i ] ){
			// validate the interaction
			if ( type !== "dragend" && ia.cancelled )
				continue;
			// set the dragdrop properties on the event object
			callback = drag.properties( event, dd, ia );
			// prepare for more results
			ia.results = [];
			// handle each element
			$( elem || ia[ mode ] || dd.droppable ).each(function( p, subject ){
				// identify drag or drop targets individually
				callback.target = subject;
				// force propagtion of the custom event
				event.isPropagationStopped = function(){ return false; };
				// handle the event	
				result = subject ? $event.dispatch.call( subject, event, callback ) : null;
				// stop the drag interaction for this element
				if ( result === false ){
					if ( mode == "drag" ){
						ia.cancelled = true;
						dd.propagates -= 1;
					}
					if ( type == "drop" ){
						ia[ mode ][p] = null;
					}
				}
				// assign any dropinit elements
				else if ( type == "dropinit" )
					ia.droppable.push( drag.element( result ) || subject );
				// accept a returned proxy element 
				if ( type == "dragstart" )
					ia.proxy = $( drag.element( result ) || ia.drag )[0];
				// remember this result	
				ia.results.push( result );
				// forget the event result, for recycling
				delete event.result;
				// break on cancelled handler
				if ( type !== "dropinit" )
					return result;
			});	
			// flatten the results	
			dd.results[ i ] = drag.flatten( ia.results );	
			// accept a set of valid drop targets
			if ( type == "dropinit" )
				ia.droppable = drag.flatten( ia.droppable );
			// locate drop targets
			if ( type == "dragstart" && !ia.cancelled )
				callback.update(); 
		}
		while ( ++i < len )
		// restore the original event & type
		event.type = orig.type;
		event.originalEvent = orig.event;
		// return all handler results
		return drag.flatten( dd.results );
	},
		
	// extend the callback object with drag/drop properties...
	properties: function( event, dd, ia ){		
		var obj = ia.callback;
		// elements
		obj.drag = ia.drag;
		obj.proxy = ia.proxy || ia.drag;
		// starting mouse position
		obj.startX = dd.pageX;
		obj.startY = dd.pageY;
		// current distance dragged
		obj.deltaX = event.pageX - dd.pageX;
		obj.deltaY = event.pageY - dd.pageY;
		// original element position
		obj.originalX = ia.offset.left;
		obj.originalY = ia.offset.top;
		// adjusted element position
		obj.offsetX = obj.originalX + obj.deltaX; 
		obj.offsetY = obj.originalY + obj.deltaY;
		// assign the drop targets information
		obj.drop = drag.flatten( ( ia.drop || [] ).slice() );
		obj.available = drag.flatten( ( ia.droppable || [] ).slice() );
		return obj;	
	},
	
	// determine is the argument is an element or jquery instance
	element: function( arg ){
		if ( arg && ( arg.jquery || arg.nodeType == 1 ) )
			return arg;
	},
	
	// flatten nested jquery objects and arrays into a single dimension array
	flatten: function( arr ){
		return $.map( arr, function( member ){
			return member && member.jquery ? $.makeArray( member ) : 
				member && member.length ? drag.flatten( member ) : member;
		});
	},
	
	// toggles text selection attributes ON (true) or OFF (false)
	textselect: function( bool ){ 
		$( document )[ bool ? "unbind" : "bind" ]("selectstart", drag.dontstart )
			.css("MozUserSelect", bool ? "" : "none" );
		// .attr("unselectable", bool ? "off" : "on" )
		document.unselectable = bool ? "off" : "on"; 
	},
	
	// suppress "selectstart" and "ondragstart" events
	dontstart: function(){ 
		return false; 
	},
	
	// a callback instance contructor
	callback: function(){}
	
};

// callback methods
drag.callback.prototype = {
	update: function(){
		if ( $special.drop && this.available.length )
			$.each( this.available, function( i ){
				$special.drop.locate( this, i );
			});
	}
};

// patch $.event.$dispatch to allow suppressing clicks
var $dispatch = $event.dispatch;
$event.dispatch = function( event ){
	if ( $.data( this, "suppress."+ event.type ) - new Date().getTime() > 0 ){
		$.removeData( this, "suppress."+ event.type );
		return;
	}
	return $dispatch.apply( this, arguments );
};

// event fix hooks for touch events...
var touchHooks = 
$event.fixHooks.touchstart = 
$event.fixHooks.touchmove = 
$event.fixHooks.touchend =
$event.fixHooks.touchcancel = {
	props: "clientX clientY pageX pageY screenX screenY".split( " " ),
	filter: function( event, orig ) {
		if ( orig ){
			var touched = ( orig.touches && orig.touches[0] )
				|| ( orig.changedTouches && orig.changedTouches[0] )
				|| null; 
			// iOS webkit: touchstart, touchmove, touchend
			if ( touched ) 
				$.each( touchHooks.props, function( i, prop ){
					event[ prop ] = touched[ prop ];
				});
		}
		return event;
	}
};

// share the same special event configuration with related events...
$special.draginit = $special.dragstart = $special.dragend = drag;

})( jQuery );(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.io = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){

module.exports =  _dereq_('./lib/');

},{"./lib/":2}],2:[function(_dereq_,module,exports){

module.exports = _dereq_('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = _dereq_('engine.io-parser');

},{"./socket":3,"engine.io-parser":19}],3:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = _dereq_('./transports');
var Emitter = _dereq_('component-emitter');
var debug = _dereq_('debug')('engine.io-client:socket');
var index = _dereq_('indexof');
var parser = _dereq_('engine.io-parser');
var parseuri = _dereq_('parseuri');
var parsejson = _dereq_('parsejson');
var parseqs = _dereq_('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;

  // other options for Node.js client
  var freeGlobal = typeof global == 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }
  }

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = _dereq_('./transport');
Socket.transports = _dereq_('./transports');
Socket.parser = _dereq_('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized,
    perMessageDeflate: this.perMessageDeflate,
    extraHeaders: this.extraHeaders
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function(){
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if('function' == typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' == typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' == this.readyState || 'closed' == this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close() {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose() {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade() {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./transport":4,"./transports":5,"component-emitter":15,"debug":17,"engine.io-parser":19,"indexof":23,"parsejson":26,"parseqs":27,"parseuri":28}],4:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var parser = _dereq_('engine.io-parser');
var Emitter = _dereq_('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":15,"engine.io-parser":19}],5:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
var XHR = _dereq_('./polling-xhr');
var JSONP = _dereq_('./polling-jsonp');
var websocket = _dereq_('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./polling-jsonp":6,"./polling-xhr":7,"./websocket":9,"xmlhttprequest-ssl":10}],6:[function(_dereq_,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = _dereq_('./polling');
var inherit = _dereq_('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  }
  else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./polling":8,"component-inherit":16}],7:[function(_dereq_,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
var Polling = _dereq_('./polling');
var Emitter = _dereq_('component-emitter');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  } else {
    this.extraHeaders = opts.extraHeaders;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        try {
          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
        } catch (e) {
          var ui8Arr = new Uint8Array(this.xhr.response);
          var dataArray = [];
          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
            dataArray.push(ui8Arr[idx]);
          }

          data = String.fromCharCode.apply(null, dataArray);
        }
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./polling":8,"component-emitter":15,"component-inherit":16,"debug":17,"xmlhttprequest-ssl":10}],8:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parseqs = _dereq_('parseqs');
var parser = _dereq_('engine.io-parser');
var inherit = _dereq_('component-inherit');
var yeast = _dereq_('yeast');
var debug = _dereq_('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

},{"../transport":4,"component-inherit":16,"debug":17,"engine.io-parser":19,"parseqs":27,"xmlhttprequest-ssl":10,"yeast":30}],9:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parser = _dereq_('engine.io-parser');
var parseqs = _dereq_('parseqs');
var inherit = _dereq_('component-inherit');
var yeast = _dereq_('yeast');
var debug = _dereq_('debug')('engine.io-client:websocket');
var BrowserWebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocket = BrowserWebSocket;
if (!WebSocket && typeof window === 'undefined') {
  try {
    WebSocket = _dereq_('ws');
  } catch (e) { }
}

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }

  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'buffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function(packet) {
      parser.encodePacket(packet, self.supportsBinary, function(data) {
        if (!BrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        //Sometimes the websocket has already been closed but the browser didn't
        //have a chance of informing us about it yet, in that case send will
        //throw an error
        try {
          if (BrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e){
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done(){
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function(){
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"../transport":4,"component-inherit":16,"debug":17,"engine.io-parser":19,"parseqs":27,"ws":undefined,"yeast":30}],10:[function(_dereq_,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = _dereq_('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":22}],11:[function(_dereq_,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],12:[function(_dereq_,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],13:[function(_dereq_,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],14:[function(_dereq_,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],15:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],16:[function(_dereq_,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],17:[function(_dereq_,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = _dereq_('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":18}],18:[function(_dereq_,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = _dereq_('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":25}],19:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = _dereq_('./keys');
var hasBinary = _dereq_('has-binary');
var sliceBuffer = _dereq_('arraybuffer.slice');
var base64encoder = _dereq_('base64-arraybuffer');
var after = _dereq_('after');
var utf8 = _dereq_('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = _dereq_('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof global.Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./keys":20,"after":11,"arraybuffer.slice":12,"base64-arraybuffer":13,"blob":14,"has-binary":21,"utf8":29}],20:[function(_dereq_,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],21:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"isarray":24}],22:[function(_dereq_,module,exports){

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{}],23:[function(_dereq_,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],24:[function(_dereq_,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],25:[function(_dereq_,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],26:[function(_dereq_,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],27:[function(_dereq_,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],28:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],29:[function(_dereq_,module,exports){
(function (global){
/*! https://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],30:[function(_dereq_,module,exports){
'use strict';

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

},{}],31:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_('./url');
var parser = _dereq_('socket.io-parser');
var Manager = _dereq_('./manager');
var debug = _dereq_('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = _dereq_('./manager');
exports.Socket = _dereq_('./socket');

},{"./manager":32,"./socket":34,"./url":35,"debug":39,"socket.io-parser":47}],32:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var eio = _dereq_('engine.io-client');
var Socket = _dereq_('./socket');
var Emitter = _dereq_('component-emitter');
var parser = _dereq_('socket.io-parser');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var debug = _dereq_('debug')('socket.io-client:manager');
var indexOf = _dereq_('indexof');
var Backoff = _dereq_('backo2');

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.engine.id;
    }
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function(){
  this.lastPing = new Date;
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function(){
  this.emitAll('pong', new Date - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function(){
      socket.id = self.engine.id;
    });

    if (this.autoConnect) {
      // manually call here since connecting evnet is fired before listening
      onConnecting();
    }
  }

  function onConnecting() {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  debug('cleanup');

  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' == this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":33,"./socket":34,"backo2":36,"component-bind":37,"component-emitter":38,"debug":39,"engine.io-client":1,"indexof":42,"socket.io-parser":47}],33:[function(_dereq_,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],34:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var parser = _dereq_('socket.io-parser');
var Emitter = _dereq_('component-emitter');
var toArray = _dereq_('to-array');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var debug = _dereq_('debug')('socket.io-client:socket');
var hasBin = _dereq_('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  delete this.flags;

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  var ack = this.acks[packet.id];
  if ('function' == typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function(compress){
  this.flags = this.flags || {};
  this.flags.compress = compress;
  return this;
};

},{"./on":33,"component-bind":37,"component-emitter":38,"debug":39,"has-binary":41,"socket.io-parser":47,"to-array":51}],35:[function(_dereq_,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = _dereq_('parseuri');
var debug = _dereq_('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('/' == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"debug":39,"parseuri":45}],36:[function(_dereq_,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],37:[function(_dereq_,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],38:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],39:[function(_dereq_,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./debug":40,"dup":17}],40:[function(_dereq_,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18,"ms":44}],41:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      // see: https://github.com/Automattic/has-binary/pull/4
      if (obj.toJSON && 'function' == typeof obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"isarray":43}],42:[function(_dereq_,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],43:[function(_dereq_,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],44:[function(_dereq_,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],45:[function(_dereq_,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],46:[function(_dereq_,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = _dereq_('isarray');
var isBuf = _dereq_('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./is-buffer":48,"isarray":43}],47:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var debug = _dereq_('debug')('socket.io-parser');
var json = _dereq_('json3');
var isArray = _dereq_('isarray');
var Emitter = _dereq_('component-emitter');
var binary = _dereq_('./binary');
var isBuf = _dereq_('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'BINARY_EVENT',
  'ACK',
  'BINARY_ACK',
  'ERROR'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":46,"./is-buffer":48,"component-emitter":49,"debug":39,"isarray":43,"json3":50}],48:[function(_dereq_,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],49:[function(_dereq_,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15}],50:[function(_dereq_,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],51:[function(_dereq_,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}]},{},[31])(31)
});
/**
 * Created by Administrator on 2016/1/5.
 */
/*
* 调用此JS 请先引用socket.io.js,并将chat文件夹拷贝至你的工程内
* */

/*
 *参数说明：
 * xiaoBeiPath 聊聊首页chat.html的路径,如"../chat/cn/chat.html"
 * sessionId 用户认证后WEBSERVER分配的SESSIONID
 * */

/*
* 事件说明：
* "newMsg":
*          回调参数：1、e
*                   2、data  false/true false没有新消息，true有新消息
*
* 用法示例：
 var chat = $("#online_service").xiaoBeiChat({xiaobeiPath:"../chat/cn/chat.html",sessionId:"aaaaaaaaaaaa"})
 chat.bind("newMsg",function(e, data){
     if(data){
        console.log("您有新消息");
     }else{
        console.log("消息已经被收取");
     }
 })
 chat.bind("chatHeadImg",function(e, data){
     if(data){
         设置自己的头像
        $("#chatHeadImg").attr("src", data);
     }
 })
* */
;(function ($) {
    $.fn.xiaoBeiChat=function(option){
        var defaults = {
            xiaobeiPath: "",
            sessionId: "",
        }
        var chatWin;
        var chatQuerySocket;
        var options = $.extend(defaults, option);
        var chatUid;
        var me=this;

        $(this).bind("click", function () {
            if(!options.sessionId || options.sessionId==""){
                alert("ERROR:sessionId = "+ options.sessionId);
                return false;
            }
            chatWin = window.open(options.xiaobeiPath + "?" + "sessionid=" + options.sessionId, 'xiaobei');
        })
        $(window).bind('beforeunload',function(){
            if(chatWin){
                chatWin.onbeforeunload = null;
                chatWin.close();
                chatWin = undefined;
            }
        });

        //chatQuerySocket = io.connect('ws://172.27.8.185:3010');
        //chatQuerySocket = io.connect('ws://h3crd-wlan1.chinacloudapp.cn:3010');
        chatQuerySocket = io.connect("https://lvzhouchat.h3c.com",{secure:true});

        chatQuerySocket.on('connect', function(){
            console.log("connect_success");
            chatQuerySocket.emit('authentication', {chatid:options.sessionId,query:true}, function(a){
            });
        })
        chatQuerySocket.on('authenticated', function(info){
            console.log("authenticated_" + info);
            chatQuerySocket.emit("getselfinfo",{}, function(data){
                console.log("getselfinfo_"+JSON.stringify(data));
                chatUid = data["uid"];
                getSelfHeadImg();
            })
        })

        chatQuerySocket.on("queryNewMsg",function(data){
            console.log("queryNewMsg_"+JSON.stringify(data));
            $(me).trigger("newMsg", data["newMsg"]);
        })

        chatQuerySocket.on("photoChg",function(data){
            console.log("photoChg_"+JSON.stringify(data));
            if(data["result"]=="success"){
                if(chatUid == data["body"]["uid"]){
                    getSelfHeadImg(data);
                }
            }
        })

        function getSelfHeadImg(){
            chatQuerySocket.emit("userPhotoGet",{uid:chatUid},function(data){
                //console.log("userPhotoGet_"+JSON.stringify(data));
                if(data["result"]=="success" && data["body"]["photoid"] && data["body"]["image"]){
                    convertHeadImg(data["body"]["image"],function(img){
                        $(me).trigger("chatHeadImg", img);
                    })
                }else if(data["result"]=="failed") {
                    console.log("获取头像失败");
                }
            })
        }

        function readBlobAsDataURL(blob, callback) {
            var a = new FileReader();
            a.onload = function() {callback(a.result);};
            a.readAsDataURL(blob);
        }
        function convertHeadImg(img,cback) {
            var image = JSON.parse(img);
            //console.log(image);
            var arr = [];
            for (var i in image) {
                arr[i] = image[i];
            }
            if (arr.length > 0) {
                var ia = new Uint8Array(arr);
                myresizedImage = (new Blob([ia], {type: "image/png"}));
                readBlobAsDataURL(myresizedImage, function (dataurl) {
                    //console.log(dataurl);
                    cback(dataurl);
                });
            }
        }

        return this;
    }
})(jQuery);
if(!document.createElement("canvas").getContext){(function(){var ab=Math;var n=ab.round;var l=ab.sin;var A=ab.cos;var H=ab.abs;var N=ab.sqrt;var d=10;var f=d/2;var z=+navigator.userAgent.match(/MSIE ([\d.]+)?/)[1];function y(){return this.context_||(this.context_=new D(this))}var t=Array.prototype.slice;function g(j,m,p){var i=t.call(arguments,2);return function(){return j.apply(m,i.concat(t.call(arguments)))}}function af(i){return String(i).replace(/&/g,"&amp;").replace(/"/g,"&quot;")}function Y(m,j,i){if(!m.namespaces[j]){m.namespaces.add(j,i,"#default#VML")}}function R(j){Y(j,"g_vml_","urn:schemas-microsoft-com:vml");Y(j,"g_o_","urn:schemas-microsoft-com:office:office");if(!j.styleSheets.ex_canvas_){var i=j.createStyleSheet();i.owningElement.id="ex_canvas_";i.cssText="canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}"}}R(document);var e={init:function(i){var j=i||document;j.createElement("canvas");j.attachEvent("onreadystatechange",g(this.init_,this,j))},init_:function(p){var m=p.getElementsByTagName("canvas");for(var j=0;j<m.length;j++){this.initElement(m[j])}},initElement:function(j){if(!j.getContext){j.getContext=y;R(j.ownerDocument);j.innerHTML="";j.attachEvent("onpropertychange",x);j.attachEvent("onresize",W);var i=j.attributes;if(i.width&&i.width.specified){j.style.width=i.width.nodeValue+"px"}else{j.width=j.clientWidth}if(i.height&&i.height.specified){j.style.height=i.height.nodeValue+"px"}else{j.height=j.clientHeight}}return j}};function x(j){var i=j.srcElement;switch(j.propertyName){case"width":i.getContext().clearRect();i.style.width=i.attributes.width.nodeValue+"px";i.firstChild.style.width=i.clientWidth+"px";break;case"height":i.getContext().clearRect();i.style.height=i.attributes.height.nodeValue+"px";i.firstChild.style.height=i.clientHeight+"px";break}}function W(j){var i=j.srcElement;if(i.firstChild){i.firstChild.style.width=i.clientWidth+"px";i.firstChild.style.height=i.clientHeight+"px"}}e.init();var k=[];for(var ae=0;ae<16;ae++){for(var ad=0;ad<16;ad++){k[ae*16+ad]=ae.toString(16)+ad.toString(16)}}function B(){return[[1,0,0],[0,1,0],[0,0,1]]}function J(p,m){var j=B();for(var i=0;i<3;i++){for(var ah=0;ah<3;ah++){var Z=0;for(var ag=0;ag<3;ag++){Z+=p[i][ag]*m[ag][ah]}j[i][ah]=Z}}return j}function v(j,i){i.fillStyle=j.fillStyle;i.lineCap=j.lineCap;i.lineJoin=j.lineJoin;i.lineWidth=j.lineWidth;i.miterLimit=j.miterLimit;i.shadowBlur=j.shadowBlur;i.shadowColor=j.shadowColor;i.shadowOffsetX=j.shadowOffsetX;i.shadowOffsetY=j.shadowOffsetY;i.strokeStyle=j.strokeStyle;i.globalAlpha=j.globalAlpha;i.font=j.font;i.textAlign=j.textAlign;i.textBaseline=j.textBaseline;i.arcScaleX_=j.arcScaleX_;i.arcScaleY_=j.arcScaleY_;i.lineScale_=j.lineScale_}var b={aliceblue:"#F0F8FF",antiquewhite:"#FAEBD7",aquamarine:"#7FFFD4",azure:"#F0FFFF",beige:"#F5F5DC",bisque:"#FFE4C4",black:"#000000",blanchedalmond:"#FFEBCD",blueviolet:"#8A2BE2",brown:"#A52A2A",burlywood:"#DEB887",cadetblue:"#5F9EA0",chartreuse:"#7FFF00",chocolate:"#D2691E",coral:"#FF7F50",cornflowerblue:"#6495ED",cornsilk:"#FFF8DC",crimson:"#DC143C",cyan:"#00FFFF",darkblue:"#00008B",darkcyan:"#008B8B",darkgoldenrod:"#B8860B",darkgray:"#A9A9A9",darkgreen:"#006400",darkgrey:"#A9A9A9",darkkhaki:"#BDB76B",darkmagenta:"#8B008B",darkolivegreen:"#556B2F",darkorange:"#FF8C00",darkorchid:"#9932CC",darkred:"#8B0000",darksalmon:"#E9967A",darkseagreen:"#8FBC8F",darkslateblue:"#483D8B",darkslategray:"#2F4F4F",darkslategrey:"#2F4F4F",darkturquoise:"#00CED1",darkviolet:"#9400D3",deeppink:"#FF1493",deepskyblue:"#00BFFF",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1E90FF",firebrick:"#B22222",floralwhite:"#FFFAF0",forestgreen:"#228B22",gainsboro:"#DCDCDC",ghostwhite:"#F8F8FF",gold:"#FFD700",goldenrod:"#DAA520",grey:"#808080",greenyellow:"#ADFF2F",honeydew:"#F0FFF0",hotpink:"#FF69B4",indianred:"#CD5C5C",indigo:"#4B0082",ivory:"#FFFFF0",khaki:"#F0E68C",lavender:"#E6E6FA",lavenderblush:"#FFF0F5",lawngreen:"#7CFC00",lemonchiffon:"#FFFACD",lightblue:"#ADD8E6",lightcoral:"#F08080",lightcyan:"#E0FFFF",lightgoldenrodyellow:"#FAFAD2",lightgreen:"#90EE90",lightgrey:"#D3D3D3",lightpink:"#FFB6C1",lightsalmon:"#FFA07A",lightseagreen:"#20B2AA",lightskyblue:"#87CEFA",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#B0C4DE",lightyellow:"#FFFFE0",limegreen:"#32CD32",linen:"#FAF0E6",magenta:"#FF00FF",mediumaquamarine:"#66CDAA",mediumblue:"#0000CD",mediumorchid:"#BA55D3",mediumpurple:"#9370DB",mediumseagreen:"#3CB371",mediumslateblue:"#7B68EE",mediumspringgreen:"#00FA9A",mediumturquoise:"#48D1CC",mediumvioletred:"#C71585",midnightblue:"#191970",mintcream:"#F5FFFA",mistyrose:"#FFE4E1",moccasin:"#FFE4B5",navajowhite:"#FFDEAD",oldlace:"#FDF5E6",olivedrab:"#6B8E23",orange:"#FFA500",orangered:"#FF4500",orchid:"#DA70D6",palegoldenrod:"#EEE8AA",palegreen:"#98FB98",paleturquoise:"#AFEEEE",palevioletred:"#DB7093",papayawhip:"#FFEFD5",peachpuff:"#FFDAB9",peru:"#CD853F",pink:"#FFC0CB",plum:"#DDA0DD",powderblue:"#B0E0E6",rosybrown:"#BC8F8F",royalblue:"#4169E1",saddlebrown:"#8B4513",salmon:"#FA8072",sandybrown:"#F4A460",seagreen:"#2E8B57",seashell:"#FFF5EE",sienna:"#A0522D",skyblue:"#87CEEB",slateblue:"#6A5ACD",slategray:"#708090",slategrey:"#708090",snow:"#FFFAFA",springgreen:"#00FF7F",steelblue:"#4682B4",tan:"#D2B48C",thistle:"#D8BFD8",tomato:"#FF6347",turquoise:"#40E0D0",violet:"#EE82EE",wheat:"#F5DEB3",whitesmoke:"#F5F5F5",yellowgreen:"#9ACD32"};function M(j){var p=j.indexOf("(",3);var i=j.indexOf(")",p+1);var m=j.substring(p+1,i).split(",");if(m.length!=4||j.charAt(3)!="a"){m[3]=1}return m}function c(i){return parseFloat(i)/100}function r(j,m,i){return Math.min(i,Math.max(m,j))}function I(ag){var i,ai,aj,ah,ak,Z;ah=parseFloat(ag[0])/360%360;if(ah<0){ah++}ak=r(c(ag[1]),0,1);Z=r(c(ag[2]),0,1);if(ak==0){i=ai=aj=Z}else{var j=Z<0.5?Z*(1+ak):Z+ak-Z*ak;var m=2*Z-j;i=a(m,j,ah+1/3);ai=a(m,j,ah);aj=a(m,j,ah-1/3)}return"#"+k[Math.floor(i*255)]+k[Math.floor(ai*255)]+k[Math.floor(aj*255)]}function a(j,i,m){if(m<0){m++}if(m>1){m--}if(6*m<1){return j+(i-j)*6*m}else{if(2*m<1){return i}else{if(3*m<2){return j+(i-j)*(2/3-m)*6}else{return j}}}}var C={};function F(j){if(j in C){return C[j]}var ag,Z=1;j=String(j);if(j.charAt(0)=="#"){ag=j}else{if(/^rgb/.test(j)){var p=M(j);var ag="#",ah;for(var m=0;m<3;m++){if(p[m].indexOf("%")!=-1){ah=Math.floor(c(p[m])*255)}else{ah=+p[m]}ag+=k[r(ah,0,255)]}Z=+p[3]}else{if(/^hsl/.test(j)){var p=M(j);ag=I(p);Z=p[3]}else{ag=b[j]||j}}}return C[j]={color:ag,alpha:Z}}var o={style:"normal",variant:"normal",weight:"normal",size:10,family:"sans-serif"};var L={};function E(i){if(L[i]){return L[i]}var p=document.createElement("div");var m=p.style;try{m.font=i}catch(j){}return L[i]={style:m.fontStyle||o.style,variant:m.fontVariant||o.variant,weight:m.fontWeight||o.weight,size:m.fontSize||o.size,family:m.fontFamily||o.family}}function u(m,j){var i={};for(var ah in m){i[ah]=m[ah]}var ag=parseFloat(j.currentStyle.fontSize),Z=parseFloat(m.size);if(typeof m.size=="number"){i.size=m.size}else{if(m.size.indexOf("px")!=-1){i.size=Z}else{if(m.size.indexOf("em")!=-1){i.size=ag*Z}else{if(m.size.indexOf("%")!=-1){i.size=(ag/100)*Z}else{if(m.size.indexOf("pt")!=-1){i.size=Z/0.75}else{i.size=ag}}}}}i.size*=0.981;return i}function ac(i){return i.style+" "+i.variant+" "+i.weight+" "+i.size+"px "+i.family}var s={butt:"flat",round:"round"};function S(i){return s[i]||"square"}function D(i){this.m_=B();this.mStack_=[];this.aStack_=[];this.currentPath_=[];this.strokeStyle="#000";this.fillStyle="#000";this.lineWidth=1;this.lineJoin="miter";this.lineCap="butt";this.miterLimit=d*1;this.globalAlpha=1;this.font="10px sans-serif";this.textAlign="left";this.textBaseline="alphabetic";this.canvas=i;var m="width:"+i.clientWidth+"px;height:"+i.clientHeight+"px;overflow:hidden;position:absolute";var j=i.ownerDocument.createElement("div");j.style.cssText=m;i.appendChild(j);var p=j.cloneNode(false);p.style.backgroundColor="red";p.style.filter="alpha(opacity=0)";i.appendChild(p);this.element_=j;this.arcScaleX_=1;this.arcScaleY_=1;this.lineScale_=1}var q=D.prototype;q.clearRect=function(){if(this.textMeasureEl_){this.textMeasureEl_.removeNode(true);this.textMeasureEl_=null}this.element_.innerHTML=""};q.beginPath=function(){this.currentPath_=[]};q.moveTo=function(j,i){var m=V(this,j,i);this.currentPath_.push({type:"moveTo",x:m.x,y:m.y});this.currentX_=m.x;this.currentY_=m.y};q.lineTo=function(j,i){var m=V(this,j,i);this.currentPath_.push({type:"lineTo",x:m.x,y:m.y});this.currentX_=m.x;this.currentY_=m.y};q.bezierCurveTo=function(m,j,ak,aj,ai,ag){var i=V(this,ai,ag);var ah=V(this,m,j);var Z=V(this,ak,aj);K(this,ah,Z,i)};function K(i,Z,m,j){i.currentPath_.push({type:"bezierCurveTo",cp1x:Z.x,cp1y:Z.y,cp2x:m.x,cp2y:m.y,x:j.x,y:j.y});i.currentX_=j.x;i.currentY_=j.y}q.quadraticCurveTo=function(ai,m,j,i){var ah=V(this,ai,m);var ag=V(this,j,i);var aj={x:this.currentX_+2/3*(ah.x-this.currentX_),y:this.currentY_+2/3*(ah.y-this.currentY_)};var Z={x:aj.x+(ag.x-this.currentX_)/3,y:aj.y+(ag.y-this.currentY_)/3};K(this,aj,Z,ag)};q.arc=function(al,aj,ak,ag,j,m){ak*=d;var ap=m?"at":"wa";var am=al+A(ag)*ak-f;var ao=aj+l(ag)*ak-f;var i=al+A(j)*ak-f;var an=aj+l(j)*ak-f;if(am==i&&!m){am+=0.125}var Z=V(this,al,aj);var ai=V(this,am,ao);var ah=V(this,i,an);this.currentPath_.push({type:ap,x:Z.x,y:Z.y,radius:ak,xStart:ai.x,yStart:ai.y,xEnd:ah.x,yEnd:ah.y})};q.rect=function(m,j,i,p){this.moveTo(m,j);this.lineTo(m+i,j);this.lineTo(m+i,j+p);this.lineTo(m,j+p);this.closePath()};q.strokeRect=function(m,j,i,p){var Z=this.currentPath_;this.beginPath();this.moveTo(m,j);this.lineTo(m+i,j);this.lineTo(m+i,j+p);this.lineTo(m,j+p);this.closePath();this.stroke();this.currentPath_=Z};q.fillRect=function(m,j,i,p){var Z=this.currentPath_;this.beginPath();this.moveTo(m,j);this.lineTo(m+i,j);this.lineTo(m+i,j+p);this.lineTo(m,j+p);this.closePath();this.fill();this.currentPath_=Z};q.createLinearGradient=function(j,p,i,m){var Z=new U("gradient");Z.x0_=j;Z.y0_=p;Z.x1_=i;Z.y1_=m;return Z};q.createRadialGradient=function(p,ag,m,j,Z,i){var ah=new U("gradientradial");ah.x0_=p;ah.y0_=ag;ah.r0_=m;ah.x1_=j;ah.y1_=Z;ah.r1_=i;return ah};q.drawImage=function(aq,m){var aj,ah,al,ay,ao,am,at,aA;var ak=aq.runtimeStyle.width;var ap=aq.runtimeStyle.height;aq.runtimeStyle.width="auto";aq.runtimeStyle.height="auto";var ai=aq.width;var aw=aq.height;aq.runtimeStyle.width=ak;aq.runtimeStyle.height=ap;if(arguments.length==3){aj=arguments[1];ah=arguments[2];ao=am=0;at=al=ai;aA=ay=aw}else{if(arguments.length==5){aj=arguments[1];ah=arguments[2];al=arguments[3];ay=arguments[4];ao=am=0;at=ai;aA=aw}else{if(arguments.length==9){ao=arguments[1];am=arguments[2];at=arguments[3];aA=arguments[4];aj=arguments[5];ah=arguments[6];al=arguments[7];ay=arguments[8]}else{throw Error("Invalid number of arguments")}}}var az=V(this,aj,ah);var p=at/2;var j=aA/2;var ax=[];var i=10;var ag=10;ax.push(" <g_vml_:group",' coordsize="',d*i,",",d*ag,'"',' coordorigin="0,0"',' style="width:',i,"px;height:",ag,"px;position:absolute;");if(this.m_[0][0]!=1||this.m_[0][1]||this.m_[1][1]!=1||this.m_[1][0]){var Z=[];Z.push("M11=",this.m_[0][0],",","M12=",this.m_[1][0],",","M21=",this.m_[0][1],",","M22=",this.m_[1][1],",","Dx=",n(az.x/d),",","Dy=",n(az.y/d),"");var av=az;var au=V(this,aj+al,ah);var ar=V(this,aj,ah+ay);var an=V(this,aj+al,ah+ay);av.x=ab.max(av.x,au.x,ar.x,an.x);av.y=ab.max(av.y,au.y,ar.y,an.y);ax.push("padding:0 ",n(av.x/d),"px ",n(av.y/d),"px 0;filter:progid:DXImageTransform.Microsoft.Matrix(",Z.join(""),", sizingmethod='clip');")}else{ax.push("top:",n(az.y/d),"px;left:",n(az.x/d),"px;")}ax.push(' ">','<g_vml_:image src="',aq.src,'"',' style="width:',d*al,"px;"," height:",d*ay,'px"',' cropleft="',ao/ai,'"',' croptop="',am/aw,'"',' cropright="',(ai-ao-at)/ai,'"',' cropbottom="',(aw-am-aA)/aw,'"'," />","</g_vml_:group>");this.element_.insertAdjacentHTML("BeforeEnd",ax.join(""))};q.stroke=function(ao){var Z=10;var ap=10;var ag=5000;var ai={x:null,y:null};var an={x:null,y:null};for(var aj=0;aj<this.currentPath_.length;aj+=ag){var am=[];var ah=false;am.push("<g_vml_:shape",' filled="',!!ao,'"',' style="position:absolute;width:',Z,"px;height:",ap,'px;"',' coordorigin="0,0"',' coordsize="',d*Z,",",d*ap,'"',' stroked="',!ao,'"',' path="');var aq=false;for(var ak=aj;ak<Math.min(aj+ag,this.currentPath_.length);ak++){if(ak%ag==0&&ak>0){am.push(" m ",n(this.currentPath_[ak-1].x),",",n(this.currentPath_[ak-1].y))}var m=this.currentPath_[ak];var al;switch(m.type){case"moveTo":al=m;am.push(" m ",n(m.x),",",n(m.y));break;case"lineTo":am.push(" l ",n(m.x),",",n(m.y));break;case"close":am.push(" x ");m=null;break;case"bezierCurveTo":am.push(" c ",n(m.cp1x),",",n(m.cp1y),",",n(m.cp2x),",",n(m.cp2y),",",n(m.x),",",n(m.y));break;case"at":case"wa":am.push(" ",m.type," ",n(m.x-this.arcScaleX_*m.radius),",",n(m.y-this.arcScaleY_*m.radius)," ",n(m.x+this.arcScaleX_*m.radius),",",n(m.y+this.arcScaleY_*m.radius)," ",n(m.xStart),",",n(m.yStart)," ",n(m.xEnd),",",n(m.yEnd));break}if(m){if(ai.x==null||m.x<ai.x){ai.x=m.x}if(an.x==null||m.x>an.x){an.x=m.x}if(ai.y==null||m.y<ai.y){ai.y=m.y}if(an.y==null||m.y>an.y){an.y=m.y}}}am.push(' ">');if(!ao){w(this,am)}else{G(this,am,ai,an)}am.push("</g_vml_:shape>");this.element_.insertAdjacentHTML("beforeEnd",am.join(""))}};function w(m,ag){var j=F(m.strokeStyle);var p=j.color;var Z=j.alpha*m.globalAlpha;var i=m.lineScale_*m.lineWidth;if(i<1){Z*=i}ag.push("<g_vml_:stroke",' opacity="',Z,'"',' joinstyle="',m.lineJoin,'"',' miterlimit="',m.miterLimit,'"',' endcap="',S(m.lineCap),'"',' weight="',i,'px"',' color="',p,'" />')}function G(aq,ai,aK,ar){var aj=aq.fillStyle;var aB=aq.arcScaleX_;var aA=aq.arcScaleY_;var j=ar.x-aK.x;var p=ar.y-aK.y;if(aj instanceof U){var an=0;var aF={x:0,y:0};var ax=0;var am=1;if(aj.type_=="gradient"){var al=aj.x0_/aB;var m=aj.y0_/aA;var ak=aj.x1_/aB;var aM=aj.y1_/aA;var aJ=V(aq,al,m);var aI=V(aq,ak,aM);var ag=aI.x-aJ.x;var Z=aI.y-aJ.y;an=Math.atan2(ag,Z)*180/Math.PI;if(an<0){an+=360}if(an<0.000001){an=0}}else{var aJ=V(aq,aj.x0_,aj.y0_);aF={x:(aJ.x-aK.x)/j,y:(aJ.y-aK.y)/p};j/=aB*d;p/=aA*d;var aD=ab.max(j,p);ax=2*aj.r0_/aD;am=2*aj.r1_/aD-ax}var av=aj.colors_;av.sort(function(aN,i){return aN.offset-i.offset});var ap=av.length;var au=av[0].color;var at=av[ap-1].color;var az=av[0].alpha*aq.globalAlpha;var ay=av[ap-1].alpha*aq.globalAlpha;var aE=[];for(var aH=0;aH<ap;aH++){var ao=av[aH];aE.push(ao.offset*am+ax+" "+ao.color)}ai.push('<g_vml_:fill type="',aj.type_,'"',' method="none" focus="100%"',' color="',au,'"',' color2="',at,'"',' colors="',aE.join(","),'"',' opacity="',ay,'"',' g_o_:opacity2="',az,'"',' angle="',an,'"',' focusposition="',aF.x,",",aF.y,'" />')}else{if(aj instanceof T){if(j&&p){var ah=-aK.x;var aC=-aK.y;ai.push("<g_vml_:fill",' position="',ah/j*aB*aB,",",aC/p*aA*aA,'"',' type="tile"',' src="',aj.src_,'" />')}}else{var aL=F(aq.fillStyle);var aw=aL.color;var aG=aL.alpha*aq.globalAlpha;ai.push('<g_vml_:fill color="',aw,'" opacity="',aG,'" />')}}}q.fill=function(){this.stroke(true)};q.closePath=function(){this.currentPath_.push({type:"close"})};function V(j,Z,p){var i=j.m_;return{x:d*(Z*i[0][0]+p*i[1][0]+i[2][0])-f,y:d*(Z*i[0][1]+p*i[1][1]+i[2][1])-f}}q.save=function(){var i={};v(this,i);this.aStack_.push(i);this.mStack_.push(this.m_);this.m_=J(B(),this.m_)};q.restore=function(){if(this.aStack_.length){v(this.aStack_.pop(),this);this.m_=this.mStack_.pop()}};function h(i){return isFinite(i[0][0])&&isFinite(i[0][1])&&isFinite(i[1][0])&&isFinite(i[1][1])&&isFinite(i[2][0])&&isFinite(i[2][1])}function aa(j,i,p){if(!h(i)){return}j.m_=i;if(p){var Z=i[0][0]*i[1][1]-i[0][1]*i[1][0];j.lineScale_=N(H(Z))}}q.translate=function(m,j){var i=[[1,0,0],[0,1,0],[m,j,1]];aa(this,J(i,this.m_),false)};q.rotate=function(j){var p=A(j);var m=l(j);var i=[[p,m,0],[-m,p,0],[0,0,1]];aa(this,J(i,this.m_),false)};q.scale=function(m,j){this.arcScaleX_*=m;this.arcScaleY_*=j;var i=[[m,0,0],[0,j,0],[0,0,1]];aa(this,J(i,this.m_),true)};q.transform=function(Z,p,ah,ag,j,i){var m=[[Z,p,0],[ah,ag,0],[j,i,1]];aa(this,J(m,this.m_),true)};q.setTransform=function(ag,Z,ai,ah,p,j){var i=[[ag,Z,0],[ai,ah,0],[p,j,1]];aa(this,i,true)};q.drawText_=function(am,ak,aj,ap,ai){var ao=this.m_,at=1000,j=0,ar=at,ah={x:0,y:0},ag=[];var i=u(E(this.font),this.element_);var p=ac(i);var au=this.element_.currentStyle;var Z=this.textAlign.toLowerCase();switch(Z){case"left":case"center":case"right":break;case"end":Z=au.direction=="ltr"?"right":"left";break;case"start":Z=au.direction=="rtl"?"right":"left";break;default:Z="left"}switch(this.textBaseline){case"hanging":case"top":ah.y=i.size/1.75;break;case"middle":break;default:case null:case"alphabetic":case"ideographic":case"bottom":ah.y=-i.size/2.25;break}switch(Z){case"right":j=at;ar=0.05;break;case"center":j=ar=at/2;break}var aq=V(this,ak+ah.x,aj+ah.y);ag.push('<g_vml_:line from="',-j,' 0" to="',ar,' 0.05" ',' coordsize="100 100" coordorigin="0 0"',' filled="',!ai,'" stroked="',!!ai,'" style="position:absolute;width:1px;height:1px;">');if(ai){w(this,ag)}else{G(this,ag,{x:-j,y:0},{x:ar,y:i.size})}var an=ao[0][0].toFixed(3)+","+ao[1][0].toFixed(3)+","+ao[0][1].toFixed(3)+","+ao[1][1].toFixed(3)+",0,0";var al=n(aq.x/d)+","+n(aq.y/d);ag.push('<g_vml_:skew on="t" matrix="',an,'" ',' offset="',al,'" origin="',j,' 0" />','<g_vml_:path textpathok="true" />','<g_vml_:textpath on="true" string="',af(am),'" style="v-text-align:',Z,";font:",af(p),'" /></g_vml_:line>');this.element_.insertAdjacentHTML("beforeEnd",ag.join(""))};q.fillText=function(m,i,p,j){this.drawText_(m,i,p,j,false)};q.strokeText=function(m,i,p,j){this.drawText_(m,i,p,j,true)};q.measureText=function(m){if(!this.textMeasureEl_){var i='<span style="position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;"></span>';this.element_.insertAdjacentHTML("beforeEnd",i);this.textMeasureEl_=this.element_.lastChild}var j=this.element_.ownerDocument;this.textMeasureEl_.innerHTML="";this.textMeasureEl_.style.font=this.font;this.textMeasureEl_.appendChild(j.createTextNode(m));return{width:this.textMeasureEl_.offsetWidth}};q.clip=function(){};q.arcTo=function(){};q.createPattern=function(j,i){return new T(j,i)};function U(i){this.type_=i;this.x0_=0;this.y0_=0;this.r0_=0;this.x1_=0;this.y1_=0;this.r1_=0;this.colors_=[]}U.prototype.addColorStop=function(j,i){i=F(i);this.colors_.push({offset:j,color:i.color,alpha:i.alpha})};function T(j,i){Q(j);switch(i){case"repeat":case null:case"":this.repetition_="repeat";break;case"repeat-x":case"repeat-y":case"no-repeat":this.repetition_=i;break;default:O("SYNTAX_ERR")}this.src_=j.src;this.width_=j.width;this.height_=j.height}function O(i){throw new P(i)}function Q(i){if(!i||i.nodeType!=1||i.tagName!="IMG"){O("TYPE_MISMATCH_ERR")}if(i.readyState!="complete"){O("INVALID_STATE_ERR")}}function P(i){this.code=this[i];this.message=i+": DOM Exception "+this.code}var X=P.prototype=new Error;X.INDEX_SIZE_ERR=1;X.DOMSTRING_SIZE_ERR=2;X.HIERARCHY_REQUEST_ERR=3;X.WRONG_DOCUMENT_ERR=4;X.INVALID_CHARACTER_ERR=5;X.NO_DATA_ALLOWED_ERR=6;X.NO_MODIFICATION_ALLOWED_ERR=7;X.NOT_FOUND_ERR=8;X.NOT_SUPPORTED_ERR=9;X.INUSE_ATTRIBUTE_ERR=10;X.INVALID_STATE_ERR=11;X.SYNTAX_ERR=12;X.INVALID_MODIFICATION_ERR=13;X.NAMESPACE_ERR=14;X.INVALID_ACCESS_ERR=15;X.VALIDATION_ERR=16;X.TYPE_MISMATCH_ERR=17;G_vmlCanvasManager=e;CanvasRenderingContext2D=D;CanvasGradient=U;CanvasPattern=T;DOMException=P})()};/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas. Dual MIT/BSD license */
/*! NOTE: If you're already including a window.matchMedia polyfill via Modernizr or otherwise, you don't need this part */
window.matchMedia=window.matchMedia||function(a){"use strict";var c,d=a.documentElement,e=d.firstElementChild||d.firstChild,f=a.createElement("body"),g=a.createElement("div");return g.id="mq-test-1",g.style.cssText="position:absolute;top:-100em",f.style.background="none",f.appendChild(g),function(a){return g.innerHTML='&shy;<style media="'+a+'"> #mq-test-1 { width: 42px; }</style>',d.insertBefore(f,e),c=42===g.offsetWidth,d.removeChild(f),{matches:c,media:a}}}(document);

/*! Respond.js v1.1.0: min/max-width media query polyfill. (c) Scott Jehl. MIT/GPLv2 Lic. j.mp/respondjs  */
(function(a){"use strict";function x(){u(!0)}var b={};if(a.respond=b,b.update=function(){},b.mediaQueriesSupported=a.matchMedia&&a.matchMedia("only all").matches,!b.mediaQueriesSupported){var q,r,t,c=a.document,d=c.documentElement,e=[],f=[],g=[],h={},i=30,j=c.getElementsByTagName("head")[0]||d,k=c.getElementsByTagName("base")[0],l=j.getElementsByTagName("link"),m=[],n=function(){for(var b=0;l.length>b;b++){var c=l[b],d=c.href,e=c.media,f=c.rel&&"stylesheet"===c.rel.toLowerCase();d&&f&&!h[d]&&(c.styleSheet&&c.styleSheet.rawCssText?(p(c.styleSheet.rawCssText,d,e),h[d]=!0):(!/^([a-zA-Z:]*\/\/)/.test(d)&&!k||d.replace(RegExp.$1,"").split("/")[0]===a.location.host)&&m.push({href:d,media:e}))}o()},o=function(){if(m.length){var b=m.shift();v(b.href,function(c){p(c,b.href,b.media),h[b.href]=!0,a.setTimeout(function(){o()},0)})}},p=function(a,b,c){var d=a.match(/@media[^\{]+\{([^\{\}]*\{[^\}\{]*\})+/gi),g=d&&d.length||0;b=b.substring(0,b.lastIndexOf("/"));var h=function(a){return a.replace(/(url\()['"]?([^\/\)'"][^:\)'"]+)['"]?(\))/g,"$1"+b+"$2$3")},i=!g&&c;b.length&&(b+="/"),i&&(g=1);for(var j=0;g>j;j++){var k,l,m,n;i?(k=c,f.push(h(a))):(k=d[j].match(/@media *([^\{]+)\{([\S\s]+?)$/)&&RegExp.$1,f.push(RegExp.$2&&h(RegExp.$2))),m=k.split(","),n=m.length;for(var o=0;n>o;o++)l=m[o],e.push({media:l.split("(")[0].match(/(only\s+)?([a-zA-Z]+)\s?/)&&RegExp.$2||"all",rules:f.length-1,hasquery:l.indexOf("(")>-1,minw:l.match(/\(\s*min\-width\s*:\s*(\s*[0-9\.]+)(px|em)\s*\)/)&&parseFloat(RegExp.$1)+(RegExp.$2||""),maxw:l.match(/\(\s*max\-width\s*:\s*(\s*[0-9\.]+)(px|em)\s*\)/)&&parseFloat(RegExp.$1)+(RegExp.$2||"")})}u()},s=function(){var a,b=c.createElement("div"),e=c.body,f=!1;return b.style.cssText="position:absolute;font-size:1em;width:1em",e||(e=f=c.createElement("body"),e.style.background="none"),e.appendChild(b),d.insertBefore(e,d.firstChild),a=b.offsetWidth,f?d.removeChild(e):e.removeChild(b),a=t=parseFloat(a)},u=function(b){var h="clientWidth",k=d[h],m="CSS1Compat"===c.compatMode&&k||c.body[h]||k,n={},o=l[l.length-1],p=(new Date).getTime();if(b&&q&&i>p-q)return a.clearTimeout(r),r=a.setTimeout(u,i),void 0;q=p;for(var v in e)if(e.hasOwnProperty(v)){var w=e[v],x=w.minw,y=w.maxw,z=null===x,A=null===y,B="em";x&&(x=parseFloat(x)*(x.indexOf(B)>-1?t||s():1)),y&&(y=parseFloat(y)*(y.indexOf(B)>-1?t||s():1)),w.hasquery&&(z&&A||!(z||m>=x)||!(A||y>=m))||(n[w.media]||(n[w.media]=[]),n[w.media].push(f[w.rules]))}for(var C in g)g.hasOwnProperty(C)&&g[C]&&g[C].parentNode===j&&j.removeChild(g[C]);for(var D in n)if(n.hasOwnProperty(D)){var E=c.createElement("style"),F=n[D].join("\n");E.type="text/css",E.media=D,j.insertBefore(E,o.nextSibling),E.styleSheet?E.styleSheet.cssText=F:E.appendChild(c.createTextNode(F)),g.push(E)}},v=function(a,b){var c=w();c&&(c.open("GET",a,!0),c.onreadystatechange=function(){4!==c.readyState||200!==c.status&&304!==c.status||b(c.responseText)},4!==c.readyState&&c.send(null))},w=function(){var b=!1;try{b=new a.XMLHttpRequest}catch(c){b=new a.ActiveXObject("Microsoft.XMLHTTP")}return function(){return b}}();n(),b.update=n,a.addEventListener?a.addEventListener("resize",x,!1):a.attachEvent&&a.attachEvent("onresize",x)}})(this);
/* ===========================================================
 * bootstrap-modal.js v2.1
 * ===========================================================
 * Copyright 2012 Jordan Schroter
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

	"use strict"; // jshint ;_;

	/* MODAL CLASS DEFINITION
	* ====================== */

	var Modal = function (element, options) {
		this.init(element, options);
	};

	Modal.prototype = {

		constructor: Modal,

		init: function (element, options) {
			this.options = options;

			this.$element = $(element)
				.delegate('[data-dismiss="modal"]', 'click.dismiss.modal', $.proxy(this.hide, this));

			this.options.remote && this.$element.find('.modal-body').load(this.options.remote);

			var manager = typeof this.options.manager === 'function' ?
				this.options.manager.call(this) : this.options.manager;

			manager = manager.appendModal ?
				manager : $(manager).modalmanager().data('modalmanager');

			manager.appendModal(this);
		},

		toggle: function () {
			return this[!this.isShown ? 'show' : 'hide']();
		},

		show: function () {
			var e = $.Event('show');

			if (this.isShown) return;

			this.$element.trigger(e);

			if (e.isDefaultPrevented()) return;

			this.escape();

			this.tab();

			this.options.loading && this.loading();
		},

		hide: function (e) {
			e && e.preventDefault();

			e = $.Event('hide');

			this.$element.trigger(e);

			if (!this.isShown || e.isDefaultPrevented()) return (this.isShown = false);

			this.isShown = false;

			this.escape();

			this.tab();

			this.isLoading && this.loading();

			$(document).off('focusin.modal');

			this.$element
				.removeClass('in')
				.removeClass('animated')
				.removeClass(this.options.attentionAnimation)
				.removeClass('modal-overflow')
				.attr('aria-hidden', true);

			$.support.transition && this.$element.hasClass('fade') ?
				this.hideWithTransition() :
				this.hideModal();
		},

		layout: function () {
			var prop = this.options.height ? 'height' : 'max-height',
				value = this.options.height || this.options.maxHeight;

			if (this.options.width){
				this.$element.css('width', this.options.width);

				var that = this;
				this.$element.css('margin-left', function () {
					if (/%/ig.test(that.options.width)){
						return -(parseInt(that.options.width) / 2) + '%';
					} else {
						return -($(this).width() / 2) + 'px';
					}
				});
			} else {
				this.$element.css('width', '');
				this.$element.css('margin-left', '');
			}

			this.$element.find('.modal-body')
				.css('overflow', '')
				.css(prop, '');

			if (value){
				this.$element.find('.modal-body')
					.css('overflow', 'auto')
					.css(prop, value);
			}

			var modalOverflow = $(window).height() - 10 < this.$element.height();
            
			if (modalOverflow || this.options.modalOverflow) {
				this.$element
					.css('margin-top', 0)
					.addClass('modal-overflow');
			} else {
				this.$element
					.css('margin-top', 0 - this.$element.height() / 2)
					.removeClass('modal-overflow');
			}
		},

		tab: function () {
			var that = this;

			if (this.isShown && this.options.consumeTab) {
				this.$element.on('keydown.tabindex.modal', '[data-tabindex]', function (e) {
			    	if (e.keyCode && e.keyCode == 9){
						var $next = $(this),
							$rollover = $(this);

						that.$element.find('[data-tabindex]:enabled:not([readonly])').each(function (e) {
							if (!e.shiftKey){
						 		$next = $next.data('tabindex') < $(this).data('tabindex') ?
									$next = $(this) :
									$rollover = $(this);
							} else {
								$next = $next.data('tabindex') > $(this).data('tabindex') ?
									$next = $(this) :
									$rollover = $(this);
							}
						});

						$next[0] !== $(this)[0] ?
							$next.focus() : $rollover.focus();

						e.preventDefault();
					}
				});
			} else if (!this.isShown) {
				this.$element.off('keydown.tabindex.modal');
			}
		},

		escape: function () {
			var that = this;
			if (this.isShown && this.options.keyboard) {
				if (!this.$element.attr('tabindex')) this.$element.attr('tabindex', -1);

				this.$element.on('keyup.dismiss.modal', function (e) {
					e.which == 27 && that.hide();
				});
			} else if (!this.isShown) {
				this.$element.off('keyup.dismiss.modal')
			}
		},

		hideWithTransition: function () {
			var that = this
				, timeout = setTimeout(function () {
					that.$element.off($.support.transition.end);
					that.hideModal();
				}, 500);

			this.$element.one($.support.transition.end, function () {
				clearTimeout(timeout);
				that.hideModal();
			});
		},

		hideModal: function () {
			var prop = this.options.height ? 'height' : 'max-height';
			var value = this.options.height || this.options.maxHeight;

			if (value){
				this.$element.find('.modal-body')
					.css('overflow', '')
					.css(prop, '');
			}

			this.$element
				.hide()
				.trigger('hidden');
		},

		removeLoading: function () {
			this.$loading.remove();
			this.$loading = null;
			this.isLoading = false;
		},

		loading: function (callback) {
			callback = callback || function () {};

			var animate = this.$element.hasClass('fade') ? 'fade' : '';

			if (!this.isLoading) {
				var doAnimate = $.support.transition && animate;

				this.$loading = $('<div class="loading-mask ' + animate + '">')
					.append(this.options.spinner)
					.appendTo(this.$element);

				if (doAnimate) this.$loading[0].offsetWidth; // force reflow

				this.$loading.addClass('in');

				this.isLoading = true;

				doAnimate ?
					this.$loading.one($.support.transition.end, callback) :
					callback();

			} else if (this.isLoading && this.$loading) {
				this.$loading.removeClass('in');

				var that = this;
				$.support.transition && this.$element.hasClass('fade')?
					this.$loading.one($.support.transition.end, function () { that.removeLoading() }) :
					that.removeLoading();

			} else if (callback) {
				callback(this.isLoading);
			}
		},

		focus: function () {
			var $focusElem = this.$element.find(this.options.focusOn);

			$focusElem = $focusElem.length ? $focusElem : this.$element;

			$focusElem.focus();
		},

		attention: function (){
			// NOTE: transitionEnd with keyframes causes odd behaviour

			if (this.options.attentionAnimation){
				this.$element
					.removeClass('animated')
					.removeClass(this.options.attentionAnimation);

				var that = this;

				setTimeout(function () {
					that.$element
						.addClass('animated')
						.addClass(that.options.attentionAnimation);
				}, 0);
			}


			this.focus();
		},


		destroy: function () {
			var e = $.Event('destroy');
			this.$element.trigger(e);
			if (e.isDefaultPrevented()) return;

			this.teardown();
		},

		teardown: function () {
			if (!this.$parent.length){
				this.$element.remove();
				this.$element = null;
				return;
			}

			if (this.$parent !== this.$element.parent()){
				this.$element.appendTo(this.$parent);
			}

			this.$element.off('.modal');
			this.$element.removeData('modal');
			this.$element
				.removeClass('in')
				.attr('aria-hidden', true);
		}
	};


	/* MODAL PLUGIN DEFINITION
	* ======================= */

	$.fn.modal = function (option, args) {
		return this.each(function () {
			var $this = $(this),
				data = $this.data('modal'),
				options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option);

			if (!data) $this.data('modal', (data = new Modal(this, options)));
			if (typeof option == 'string') data[option].apply(data, [].concat(args));
			else if (options.show) data.show()
		})
	};

	$.fn.modal.defaults = {
		keyboard: true,
		backdrop: true,
		loading: false,
		show: true,
		width: null,
		height: null,
		maxHeight: null,
		modalOverflow: false,
		consumeTab: true,
		focusOn: null,
		replace: false,
		resize: false,
		attentionAnimation: 'shake',
		manager: 'body',
		spinner: '<div class="loading-spinner" style="width: 200px; margin-left: -100px;"><div class="progress progress-striped active"><div class="bar" style="width: 100%;"></div></div></div>'
	};

	$.fn.modal.Constructor = Modal;


	/* MODAL DATA-API
	* ============== */

	$(function () {
		$(document).off('click.modal').on('click.modal.data-api', '[data-toggle="modal"]', function ( e ) {
			var $this = $(this),
				href = $this.attr('href'),
				$target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))), //strip for ie7
				option = $target.data('modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data());

			e.preventDefault();
			$target
				.modal(option)
				.one('hide', function () {
					$this.focus();
				})
		});
	});

}(window.jQuery);
/* ===========================================================
 * bootstrap-modalmanager.js v2.1
 * ===========================================================
 * Copyright 2012 Jordan Schroter.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */

!function ($) {

	"use strict"; // jshint ;_;

	/* MODAL MANAGER CLASS DEFINITION
	* ====================== */

	var ModalManager = function (element, options) {
		this.init(element, options);
	};

	ModalManager.prototype = {

		constructor: ModalManager,

		init: function (element, options) {
			this.$element = $(element);
			this.options = $.extend({}, $.fn.modalmanager.defaults, this.$element.data(), typeof options == 'object' && options);
			this.stack = [];
			this.backdropCount = 0;

			if (this.options.resize) {
				var resizeTimeout,
					that = this;

				var pfResize = function(){
					resizeTimeout && clearTimeout(resizeTimeout);
					resizeTimeout = setTimeout(function(){
						for (var i = 0; i < that.stack.length; i++){
							that.stack[i].isShown && that.stack[i].layout();
						}
					}, 10);
				}
				$(window).on('resize.modal', pfResize);
			}
		},

		createModal: function (element, options) {
			$(element).modal($.extend({ manager: this }, options));
		},

		appendModal: function (modal) {
			this.stack.push(modal);

			var that = this;

			modal.$element.on('show.modalmanager', targetIsSelf(function (e) {

				var showModal = function(){
					modal.isShown = true;

					var transition = $.support.transition && modal.$element.hasClass('fade');

					that.$element
						.toggleClass('modal-open', that.hasOpenModal())
						.toggleClass('page-overflow', $(window).height() < that.$element.height());

					modal.$parent = modal.$element.parent();

					modal.$container = that.createContainer(modal);

					modal.$element.appendTo(modal.$container);

					that.backdrop(modal, function () {

						modal.$element.show();

						if (transition) {       
							//modal.$element[0].style.display = 'run-in';       
							modal.$element[0].offsetWidth;
							//modal.$element.one($.support.transition.end, function () { modal.$element[0].style.display = 'block' });  
						}
						
						modal.layout();

						modal.$element
							.addClass('in')
							.attr('aria-hidden', false);

						var complete = function () {
							that.setFocus();
							modal.$element.trigger('shown');
						};

						transition ?
							modal.$element.one($.support.transition.end, complete) :
							complete();
					});
				};

				modal.options.replace ?
					that.replace(showModal) :
					showModal();
			}));

			modal.$element.on('hidden.modalmanager', targetIsSelf(function (e) {

				that.backdrop(modal);

				if (modal.$backdrop){
					$.support.transition && modal.$element.hasClass('fade') ?
						modal.$backdrop.one($.support.transition.end, function () { that.destroyModal(modal) }) :
						that.destroyModal(modal);
				} else {
					that.destroyModal(modal);
				}

			}));

			modal.$element.on('destroy.modalmanager', targetIsSelf(function (e) {
				that.removeModal(modal);
			}));

		},

		destroyModal: function (modal) {

			modal.destroy();

			var hasOpenModal = this.hasOpenModal();

			this.$element.toggleClass('modal-open', hasOpenModal);

			if (!hasOpenModal){
				this.$element.removeClass('page-overflow');
			}

			this.removeContainer(modal);

			this.setFocus();
		},

		hasOpenModal: function () {
			for (var i = 0; i < this.stack.length; i++){
				if (this.stack[i].isShown) return true;
			}

			return false;
		},

		setFocus: function () {
			var topModal;

			for (var i = 0; i < this.stack.length; i++){
				if (this.stack[i].isShown) topModal = this.stack[i];
			}

			if (!topModal) return;

			topModal.focus();

		},

		removeModal: function (modal) {
			modal.$element.off('.modalmanager');
			if (modal.$backdrop) this.removeBackdrop(modal);
			this.stack.splice(this.getIndexOfModal(modal), 1);
		},

		getModalAt: function (index) {
			return this.stack[index];
		},

		getIndexOfModal: function (modal) {
			for (var i = 0; i < this.stack.length; i++){
				if (modal === this.stack[i]) return i;
			}
		},

		replace: function (callback) {
			var topModal;

			for (var i = 0; i < this.stack.length; i++){
				if (this.stack[i].isShown) topModal = this.stack[i];
			}

			if (topModal) {
				this.$backdropHandle = topModal.$backdrop;
				topModal.$backdrop = null;

				callback && topModal.$element.one('hidden',
					targetIsSelf( $.proxy(callback, this) ));

				topModal.hide();
			} else if (callback) {
				callback();
			}
		},

		removeBackdrop: function (modal) {
			modal.$backdrop.remove();
			modal.$backdrop = null;
		},

		createBackdrop: function (animate) {
			var $backdrop;

			if (!this.$backdropHandle) {
				$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
					.appendTo(this.$element);
			} else {
				$backdrop = this.$backdropHandle;
				$backdrop.off('.modalmanager');
				this.$backdropHandle = null;
				this.isLoading && this.removeSpinner();
			}

			return $backdrop;
		},

		removeContainer: function (modal) {
			modal.$container.remove();
			modal.$container = null;
		},

		createContainer: function (modal) {
			var $container;

			$container = $('<div class="modal-scrollable">')
				.css('z-index', getzIndex( 'modal',
					modal ? this.getIndexOfModal(modal) : this.stack.length ))
				.appendTo(this.$element);

			if (modal && modal.options.backdrop != 'static') {
				$container.on('click.modal', targetIsSelf(function (e) {
					//modal.hide();
				}));
			} else if (modal) {
				$container.on('click.modal', targetIsSelf(function (e) {
					modal.attention();
				}));
			}

			return $container;

		},

		backdrop: function (modal, callback) {
			var animate = modal.$element.hasClass('fade') ? 'fade' : '',
				showBackdrop = modal.options.backdrop &&
					this.backdropCount < this.options.backdropLimit;

			if (modal.isShown && showBackdrop) {
				var doAnimate = $.support.transition && animate && !this.$backdropHandle;

				modal.$backdrop = this.createBackdrop(animate);

				modal.$backdrop.css('z-index', getzIndex( 'backdrop', this.getIndexOfModal(modal) ));

				if (doAnimate) modal.$backdrop[0].offsetWidth; // force reflow

				modal.$backdrop.addClass('in');

				this.backdropCount += 1;

				doAnimate ?
					modal.$backdrop.one($.support.transition.end, callback) :
					callback();

			} else if (!modal.isShown && modal.$backdrop) {
				modal.$backdrop.removeClass('in');

				this.backdropCount -= 1;

				var that = this;

				$.support.transition && modal.$element.hasClass('fade')?
					modal.$backdrop.one($.support.transition.end, function () { that.removeBackdrop(modal) }) :
					that.removeBackdrop(modal);

			} else if (callback) {
				callback();
			}
		},

		removeSpinner: function(){
			this.$spinner && this.$spinner.remove();
			this.$spinner = null;
			this.isLoading = false;
		},

		removeLoading: function () {
			this.$backdropHandle && this.$backdropHandle.remove();
			this.$backdropHandle = null;
			this.removeSpinner();
		},

		loading: function (callback) {
			callback = callback || function () { };

			this.$element
				.toggleClass('modal-open', !this.isLoading || this.hasOpenModal())
				.toggleClass('page-overflow', $(window).height() < this.$element.height());

			if (!this.isLoading) {

				this.$backdropHandle = this.createBackdrop('fade');

				this.$backdropHandle[0].offsetWidth; // force reflow

				this.$backdropHandle
					.css('z-index', getzIndex('backdrop', this.stack.length))
					.addClass('in');

				var $spinner = $(this.options.spinner)
					.css('z-index', getzIndex('modal', this.stack.length))
					.appendTo(this.$element)
					.addClass('in');

				this.$spinner = $(this.createContainer())
					.append($spinner)
					.on('click.modalmanager', $.proxy(this.loading, this));

				this.isLoading = true;

				$.support.transition ?
					this.$backdropHandle.one($.support.transition.end, callback) :
					callback();

			} else if (this.isLoading && this.$backdropHandle) {
				this.$backdropHandle.removeClass('in');

				var that = this;
				$.support.transition ?
					this.$backdropHandle.one($.support.transition.end, function () { that.removeLoading() }) :
					that.removeLoading();

			} else if (callback) {
				callback(this.isLoading);
			}
		}
	};

	/* PRIVATE METHODS
	* ======================= */

	// computes and caches the zindexes
	var getzIndex = (function () {
		var zIndexFactor,
			baseIndex = {};

		return function (type, pos) {

			if (typeof zIndexFactor === 'undefined'){
				var $baseModal = $('<div class="modal hide" />').appendTo('body'),
					$baseBackdrop = $('<div class="modal-backdrop hide" />').appendTo('body');

				baseIndex['modal'] = +$baseModal.css('z-index');
				baseIndex['backdrop'] = +$baseBackdrop.css('z-index');
				zIndexFactor = baseIndex['modal'] - baseIndex['backdrop'];

				$baseModal.remove();
				$baseBackdrop.remove();
				$baseBackdrop = $baseModal = null;
			}

			return baseIndex[type] + (zIndexFactor * pos);

		}
	}());

	// make sure the event target is the modal itself in order to prevent
	// other components such as tabsfrom triggering the modal manager.
	// if Boostsrap namespaced events, this would not be needed.
	function targetIsSelf(callback){
		return function (e) {
			if (this === e.target){
				return callback.apply(this, arguments);
			}
		}
	}


	/* MODAL MANAGER PLUGIN DEFINITION
	* ======================= */

	$.fn.modalmanager = function (option, args) {
		return this.each(function () {
			var $this = $(this),
				data = $this.data('modalmanager');

			if (!data) $this.data('modalmanager', (data = new ModalManager(this, option)));
			if (typeof option === 'string') data[option].apply(data, [].concat(args))
		})
	};

	$.fn.modalmanager.defaults = {
		backdropLimit: 999,
		resize: true,
		spinner: '<div class="loading-spinner fade" style="width: 200px; margin-left: -100px;"><div class="progress progress-striped active"><div class="bar" style="width: 100%;"></div></div></div>'
	};

	$.fn.modalmanager.Constructor = ModalManager

}(jQuery);
/* ==========================================================
 * bootstrap-carousel.js v2.0.2
 * http://twitter.github.com/bootstrap/javascript.html#carousel
 * ==========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function( $ ){

  "use strict"

 /* CAROUSEL CLASS DEFINITION
  * ========================= */

  var Carousel = function (element, options) {
    this.$element = $(element)
    this.options = $.extend({}, $.fn.carousel.defaults, options)
    this.options.slide && this.slide(this.options.slide)
    this.options.pause == 'hover' && this.$element
      .on('mouseenter', $.proxy(this.pause, this))
      .on('mouseleave', $.proxy(this.cycle, this))
  }

  Carousel.prototype = {

    cycle: function () {
      this.interval = setInterval($.proxy(this.next, this), this.options.interval)
      return this
    }

  , to: function (pos) {
      var $active = this.$element.find('.active')
        , children = $active.parent().children()
        , activePos = children.index($active)
        , that = this

      if (pos > (children.length - 1) || pos < 0) return

      if (this.sliding) {
        return this.$element.one('slid', function () {
          that.to(pos)
        })
      }

      if (activePos == pos) {
        return this.pause().cycle()
      }

      return this.slide(pos > activePos ? 'next' : 'prev', $(children[pos]))
    }

  , pause: function () {
      clearInterval(this.interval)
      this.interval = null
      return this
    }

  , next: function () {
      if (this.sliding) return
      return this.slide('next')
    }

  , prev: function () {
      if (this.sliding) return
      return this.slide('prev')
    }

  , slide: function (type, next) {
      var $active = this.$element.find('.active')
        , $next = next || $active[type]()
        , isCycling = this.interval
        , direction = type == 'next' ? 'left' : 'right'
        , fallback  = type == 'next' ? 'first' : 'last'
        , that = this

      this.sliding = true

      isCycling && this.pause()

      $next = $next.length ? $next : this.$element.find('.item')[fallback]()

      if ($next.hasClass('active')) return

      if (!$.support.transition && this.$element.hasClass('slide')) {
        this.$element.trigger('slide')
        $active.removeClass('active')
        $next.addClass('active')
        this.sliding = false
        this.$element.trigger('slid')
      } else {
        $next.addClass(type)
        $next[0].offsetWidth // force reflow
        $active.addClass(direction)
        $next.addClass(direction)
        this.$element.trigger('slide')
        this.$element.one($.support.transition.end, function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () { that.$element.trigger('slid') }, 0)
        })
      }

      isCycling && this.cycle()

      return this
    }

  }


 /* CAROUSEL PLUGIN DEFINITION
  * ========================== */

  $.fn.carousel = function ( option ) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('carousel')
        , options = typeof option == 'object' && option
      if (!data) $this.data('carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (typeof option == 'string' || (option = options.slide)) data[option]()
      else data.cycle()
    })
  }

  $.fn.carousel.defaults = {
    interval: 5000
  , pause: 'hover'
  }

  $.fn.carousel.Constructor = Carousel


 /* CAROUSEL DATA-API
  * ================= */

  $(function () {
    $('body').on('click.carousel.data-api', '[data-slide]', function ( e ) {
      var $this = $(this), href
        , $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
        , options = !$target.data('modal') && $.extend({}, $target.data(), $this.data())
      $target.carousel(options)
      e.preventDefault()
    })
  })

}( window.jQuery );//! moment.js
//! version : 2.9.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
(function(a){function b(a,b,c){switch(arguments.length){case 2:return null!=a?a:b;case 3:return null!=a?a:null!=b?b:c;default:throw new Error("Implement me")}}function c(a,b){return Bb.call(a,b)}function d(){return{empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1}}function e(a){vb.suppressDeprecationWarnings===!1&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+a)}function f(a,b){var c=!0;return o(function(){return c&&(e(a),c=!1),b.apply(this,arguments)},b)}function g(a,b){sc[a]||(e(b),sc[a]=!0)}function h(a,b){return function(c){return r(a.call(this,c),b)}}function i(a,b){return function(c){return this.localeData().ordinal(a.call(this,c),b)}}function j(a,b){var c,d,e=12*(b.year()-a.year())+(b.month()-a.month()),f=a.clone().add(e,"months");return 0>b-f?(c=a.clone().add(e-1,"months"),d=(b-f)/(f-c)):(c=a.clone().add(e+1,"months"),d=(b-f)/(c-f)),-(e+d)}function k(a,b,c){var d;return null==c?b:null!=a.meridiemHour?a.meridiemHour(b,c):null!=a.isPM?(d=a.isPM(c),d&&12>b&&(b+=12),d||12!==b||(b=0),b):b}function l(){}function m(a,b){b!==!1&&H(a),p(this,a),this._d=new Date(+a._d),uc===!1&&(uc=!0,vb.updateOffset(this),uc=!1)}function n(a){var b=A(a),c=b.year||0,d=b.quarter||0,e=b.month||0,f=b.week||0,g=b.day||0,h=b.hour||0,i=b.minute||0,j=b.second||0,k=b.millisecond||0;this._milliseconds=+k+1e3*j+6e4*i+36e5*h,this._days=+g+7*f,this._months=+e+3*d+12*c,this._data={},this._locale=vb.localeData(),this._bubble()}function o(a,b){for(var d in b)c(b,d)&&(a[d]=b[d]);return c(b,"toString")&&(a.toString=b.toString),c(b,"valueOf")&&(a.valueOf=b.valueOf),a}function p(a,b){var c,d,e;if("undefined"!=typeof b._isAMomentObject&&(a._isAMomentObject=b._isAMomentObject),"undefined"!=typeof b._i&&(a._i=b._i),"undefined"!=typeof b._f&&(a._f=b._f),"undefined"!=typeof b._l&&(a._l=b._l),"undefined"!=typeof b._strict&&(a._strict=b._strict),"undefined"!=typeof b._tzm&&(a._tzm=b._tzm),"undefined"!=typeof b._isUTC&&(a._isUTC=b._isUTC),"undefined"!=typeof b._offset&&(a._offset=b._offset),"undefined"!=typeof b._pf&&(a._pf=b._pf),"undefined"!=typeof b._locale&&(a._locale=b._locale),Kb.length>0)for(c in Kb)d=Kb[c],e=b[d],"undefined"!=typeof e&&(a[d]=e);return a}function q(a){return 0>a?Math.ceil(a):Math.floor(a)}function r(a,b,c){for(var d=""+Math.abs(a),e=a>=0;d.length<b;)d="0"+d;return(e?c?"+":"":"-")+d}function s(a,b){var c={milliseconds:0,months:0};return c.months=b.month()-a.month()+12*(b.year()-a.year()),a.clone().add(c.months,"M").isAfter(b)&&--c.months,c.milliseconds=+b-+a.clone().add(c.months,"M"),c}function t(a,b){var c;return b=M(b,a),a.isBefore(b)?c=s(a,b):(c=s(b,a),c.milliseconds=-c.milliseconds,c.months=-c.months),c}function u(a,b){return function(c,d){var e,f;return null===d||isNaN(+d)||(g(b,"moment()."+b+"(period, number) is deprecated. Please use moment()."+b+"(number, period)."),f=c,c=d,d=f),c="string"==typeof c?+c:c,e=vb.duration(c,d),v(this,e,a),this}}function v(a,b,c,d){var e=b._milliseconds,f=b._days,g=b._months;d=null==d?!0:d,e&&a._d.setTime(+a._d+e*c),f&&pb(a,"Date",ob(a,"Date")+f*c),g&&nb(a,ob(a,"Month")+g*c),d&&vb.updateOffset(a,f||g)}function w(a){return"[object Array]"===Object.prototype.toString.call(a)}function x(a){return"[object Date]"===Object.prototype.toString.call(a)||a instanceof Date}function y(a,b,c){var d,e=Math.min(a.length,b.length),f=Math.abs(a.length-b.length),g=0;for(d=0;e>d;d++)(c&&a[d]!==b[d]||!c&&C(a[d])!==C(b[d]))&&g++;return g+f}function z(a){if(a){var b=a.toLowerCase().replace(/(.)s$/,"$1");a=lc[a]||mc[b]||b}return a}function A(a){var b,d,e={};for(d in a)c(a,d)&&(b=z(d),b&&(e[b]=a[d]));return e}function B(b){var c,d;if(0===b.indexOf("week"))c=7,d="day";else{if(0!==b.indexOf("month"))return;c=12,d="month"}vb[b]=function(e,f){var g,h,i=vb._locale[b],j=[];if("number"==typeof e&&(f=e,e=a),h=function(a){var b=vb().utc().set(d,a);return i.call(vb._locale,b,e||"")},null!=f)return h(f);for(g=0;c>g;g++)j.push(h(g));return j}}function C(a){var b=+a,c=0;return 0!==b&&isFinite(b)&&(c=b>=0?Math.floor(b):Math.ceil(b)),c}function D(a,b){return new Date(Date.UTC(a,b+1,0)).getUTCDate()}function E(a,b,c){return jb(vb([a,11,31+b-c]),b,c).week}function F(a){return G(a)?366:365}function G(a){return a%4===0&&a%100!==0||a%400===0}function H(a){var b;a._a&&-2===a._pf.overflow&&(b=a._a[Db]<0||a._a[Db]>11?Db:a._a[Eb]<1||a._a[Eb]>D(a._a[Cb],a._a[Db])?Eb:a._a[Fb]<0||a._a[Fb]>24||24===a._a[Fb]&&(0!==a._a[Gb]||0!==a._a[Hb]||0!==a._a[Ib])?Fb:a._a[Gb]<0||a._a[Gb]>59?Gb:a._a[Hb]<0||a._a[Hb]>59?Hb:a._a[Ib]<0||a._a[Ib]>999?Ib:-1,a._pf._overflowDayOfYear&&(Cb>b||b>Eb)&&(b=Eb),a._pf.overflow=b)}function I(b){return null==b._isValid&&(b._isValid=!isNaN(b._d.getTime())&&b._pf.overflow<0&&!b._pf.empty&&!b._pf.invalidMonth&&!b._pf.nullInput&&!b._pf.invalidFormat&&!b._pf.userInvalidated,b._strict&&(b._isValid=b._isValid&&0===b._pf.charsLeftOver&&0===b._pf.unusedTokens.length&&b._pf.bigHour===a)),b._isValid}function J(a){return a?a.toLowerCase().replace("_","-"):a}function K(a){for(var b,c,d,e,f=0;f<a.length;){for(e=J(a[f]).split("-"),b=e.length,c=J(a[f+1]),c=c?c.split("-"):null;b>0;){if(d=L(e.slice(0,b).join("-")))return d;if(c&&c.length>=b&&y(e,c,!0)>=b-1)break;b--}f++}return null}function L(a){var b=null;if(!Jb[a]&&Lb)try{b=vb.locale(),require("./locale/"+a),vb.locale(b)}catch(c){}return Jb[a]}function M(a,b){var c,d;return b._isUTC?(c=b.clone(),d=(vb.isMoment(a)||x(a)?+a:+vb(a))-+c,c._d.setTime(+c._d+d),vb.updateOffset(c,!1),c):vb(a).local()}function N(a){return a.match(/\[[\s\S]/)?a.replace(/^\[|\]$/g,""):a.replace(/\\/g,"")}function O(a){var b,c,d=a.match(Pb);for(b=0,c=d.length;c>b;b++)d[b]=rc[d[b]]?rc[d[b]]:N(d[b]);return function(e){var f="";for(b=0;c>b;b++)f+=d[b]instanceof Function?d[b].call(e,a):d[b];return f}}function P(a,b){return a.isValid()?(b=Q(b,a.localeData()),nc[b]||(nc[b]=O(b)),nc[b](a)):a.localeData().invalidDate()}function Q(a,b){function c(a){return b.longDateFormat(a)||a}var d=5;for(Qb.lastIndex=0;d>=0&&Qb.test(a);)a=a.replace(Qb,c),Qb.lastIndex=0,d-=1;return a}function R(a,b){var c,d=b._strict;switch(a){case"Q":return _b;case"DDDD":return bc;case"YYYY":case"GGGG":case"gggg":return d?cc:Tb;case"Y":case"G":case"g":return ec;case"YYYYYY":case"YYYYY":case"GGGGG":case"ggggg":return d?dc:Ub;case"S":if(d)return _b;case"SS":if(d)return ac;case"SSS":if(d)return bc;case"DDD":return Sb;case"MMM":case"MMMM":case"dd":case"ddd":case"dddd":return Wb;case"a":case"A":return b._locale._meridiemParse;case"x":return Zb;case"X":return $b;case"Z":case"ZZ":return Xb;case"T":return Yb;case"SSSS":return Vb;case"MM":case"DD":case"YY":case"GG":case"gg":case"HH":case"hh":case"mm":case"ss":case"ww":case"WW":return d?ac:Rb;case"M":case"D":case"d":case"H":case"h":case"m":case"s":case"w":case"W":case"e":case"E":return Rb;case"Do":return d?b._locale._ordinalParse:b._locale._ordinalParseLenient;default:return c=new RegExp($(Z(a.replace("\\","")),"i"))}}function S(a){a=a||"";var b=a.match(Xb)||[],c=b[b.length-1]||[],d=(c+"").match(jc)||["-",0,0],e=+(60*d[1])+C(d[2]);return"+"===d[0]?e:-e}function T(a,b,c){var d,e=c._a;switch(a){case"Q":null!=b&&(e[Db]=3*(C(b)-1));break;case"M":case"MM":null!=b&&(e[Db]=C(b)-1);break;case"MMM":case"MMMM":d=c._locale.monthsParse(b,a,c._strict),null!=d?e[Db]=d:c._pf.invalidMonth=b;break;case"D":case"DD":null!=b&&(e[Eb]=C(b));break;case"Do":null!=b&&(e[Eb]=C(parseInt(b.match(/\d{1,2}/)[0],10)));break;case"DDD":case"DDDD":null!=b&&(c._dayOfYear=C(b));break;case"YY":e[Cb]=vb.parseTwoDigitYear(b);break;case"YYYY":case"YYYYY":case"YYYYYY":e[Cb]=C(b);break;case"a":case"A":c._meridiem=b;break;case"h":case"hh":c._pf.bigHour=!0;case"H":case"HH":e[Fb]=C(b);break;case"m":case"mm":e[Gb]=C(b);break;case"s":case"ss":e[Hb]=C(b);break;case"S":case"SS":case"SSS":case"SSSS":e[Ib]=C(1e3*("0."+b));break;case"x":c._d=new Date(C(b));break;case"X":c._d=new Date(1e3*parseFloat(b));break;case"Z":case"ZZ":c._useUTC=!0,c._tzm=S(b);break;case"dd":case"ddd":case"dddd":d=c._locale.weekdaysParse(b),null!=d?(c._w=c._w||{},c._w.d=d):c._pf.invalidWeekday=b;break;case"w":case"ww":case"W":case"WW":case"d":case"e":case"E":a=a.substr(0,1);case"gggg":case"GGGG":case"GGGGG":a=a.substr(0,2),b&&(c._w=c._w||{},c._w[a]=C(b));break;case"gg":case"GG":c._w=c._w||{},c._w[a]=vb.parseTwoDigitYear(b)}}function U(a){var c,d,e,f,g,h,i;c=a._w,null!=c.GG||null!=c.W||null!=c.E?(g=1,h=4,d=b(c.GG,a._a[Cb],jb(vb(),1,4).year),e=b(c.W,1),f=b(c.E,1)):(g=a._locale._week.dow,h=a._locale._week.doy,d=b(c.gg,a._a[Cb],jb(vb(),g,h).year),e=b(c.w,1),null!=c.d?(f=c.d,g>f&&++e):f=null!=c.e?c.e+g:g),i=kb(d,e,f,h,g),a._a[Cb]=i.year,a._dayOfYear=i.dayOfYear}function V(a){var c,d,e,f,g=[];if(!a._d){for(e=X(a),a._w&&null==a._a[Eb]&&null==a._a[Db]&&U(a),a._dayOfYear&&(f=b(a._a[Cb],e[Cb]),a._dayOfYear>F(f)&&(a._pf._overflowDayOfYear=!0),d=fb(f,0,a._dayOfYear),a._a[Db]=d.getUTCMonth(),a._a[Eb]=d.getUTCDate()),c=0;3>c&&null==a._a[c];++c)a._a[c]=g[c]=e[c];for(;7>c;c++)a._a[c]=g[c]=null==a._a[c]?2===c?1:0:a._a[c];24===a._a[Fb]&&0===a._a[Gb]&&0===a._a[Hb]&&0===a._a[Ib]&&(a._nextDay=!0,a._a[Fb]=0),a._d=(a._useUTC?fb:eb).apply(null,g),null!=a._tzm&&a._d.setUTCMinutes(a._d.getUTCMinutes()-a._tzm),a._nextDay&&(a._a[Fb]=24)}}function W(a){var b;a._d||(b=A(a._i),a._a=[b.year,b.month,b.day||b.date,b.hour,b.minute,b.second,b.millisecond],V(a))}function X(a){var b=new Date;return a._useUTC?[b.getUTCFullYear(),b.getUTCMonth(),b.getUTCDate()]:[b.getFullYear(),b.getMonth(),b.getDate()]}function Y(b){if(b._f===vb.ISO_8601)return void ab(b);b._a=[],b._pf.empty=!0;var c,d,e,f,g,h=""+b._i,i=h.length,j=0;for(e=Q(b._f,b._locale).match(Pb)||[],c=0;c<e.length;c++)f=e[c],d=(h.match(R(f,b))||[])[0],d&&(g=h.substr(0,h.indexOf(d)),g.length>0&&b._pf.unusedInput.push(g),h=h.slice(h.indexOf(d)+d.length),j+=d.length),rc[f]?(d?b._pf.empty=!1:b._pf.unusedTokens.push(f),T(f,d,b)):b._strict&&!d&&b._pf.unusedTokens.push(f);b._pf.charsLeftOver=i-j,h.length>0&&b._pf.unusedInput.push(h),b._pf.bigHour===!0&&b._a[Fb]<=12&&(b._pf.bigHour=a),b._a[Fb]=k(b._locale,b._a[Fb],b._meridiem),V(b),H(b)}function Z(a){return a.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(a,b,c,d,e){return b||c||d||e})}function $(a){return a.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function _(a){var b,c,e,f,g;if(0===a._f.length)return a._pf.invalidFormat=!0,void(a._d=new Date(0/0));for(f=0;f<a._f.length;f++)g=0,b=p({},a),null!=a._useUTC&&(b._useUTC=a._useUTC),b._pf=d(),b._f=a._f[f],Y(b),I(b)&&(g+=b._pf.charsLeftOver,g+=10*b._pf.unusedTokens.length,b._pf.score=g,(null==e||e>g)&&(e=g,c=b));o(a,c||b)}function ab(a){var b,c,d=a._i,e=fc.exec(d);if(e){for(a._pf.iso=!0,b=0,c=hc.length;c>b;b++)if(hc[b][1].exec(d)){a._f=hc[b][0]+(e[6]||" ");break}for(b=0,c=ic.length;c>b;b++)if(ic[b][1].exec(d)){a._f+=ic[b][0];break}d.match(Xb)&&(a._f+="Z"),Y(a)}else a._isValid=!1}function bb(a){ab(a),a._isValid===!1&&(delete a._isValid,vb.createFromInputFallback(a))}function cb(a,b){var c,d=[];for(c=0;c<a.length;++c)d.push(b(a[c],c));return d}function db(b){var c,d=b._i;d===a?b._d=new Date:x(d)?b._d=new Date(+d):null!==(c=Mb.exec(d))?b._d=new Date(+c[1]):"string"==typeof d?bb(b):w(d)?(b._a=cb(d.slice(0),function(a){return parseInt(a,10)}),V(b)):"object"==typeof d?W(b):"number"==typeof d?b._d=new Date(d):vb.createFromInputFallback(b)}function eb(a,b,c,d,e,f,g){var h=new Date(a,b,c,d,e,f,g);return 1970>a&&h.setFullYear(a),h}function fb(a){var b=new Date(Date.UTC.apply(null,arguments));return 1970>a&&b.setUTCFullYear(a),b}function gb(a,b){if("string"==typeof a)if(isNaN(a)){if(a=b.weekdaysParse(a),"number"!=typeof a)return null}else a=parseInt(a,10);return a}function hb(a,b,c,d,e){return e.relativeTime(b||1,!!c,a,d)}function ib(a,b,c){var d=vb.duration(a).abs(),e=Ab(d.as("s")),f=Ab(d.as("m")),g=Ab(d.as("h")),h=Ab(d.as("d")),i=Ab(d.as("M")),j=Ab(d.as("y")),k=e<oc.s&&["s",e]||1===f&&["m"]||f<oc.m&&["mm",f]||1===g&&["h"]||g<oc.h&&["hh",g]||1===h&&["d"]||h<oc.d&&["dd",h]||1===i&&["M"]||i<oc.M&&["MM",i]||1===j&&["y"]||["yy",j];return k[2]=b,k[3]=+a>0,k[4]=c,hb.apply({},k)}function jb(a,b,c){var d,e=c-b,f=c-a.day();return f>e&&(f-=7),e-7>f&&(f+=7),d=vb(a).add(f,"d"),{week:Math.ceil(d.dayOfYear()/7),year:d.year()}}function kb(a,b,c,d,e){var f,g,h=fb(a,0,1).getUTCDay();return h=0===h?7:h,c=null!=c?c:e,f=e-h+(h>d?7:0)-(e>h?7:0),g=7*(b-1)+(c-e)+f+1,{year:g>0?a:a-1,dayOfYear:g>0?g:F(a-1)+g}}function lb(b){var c,d=b._i,e=b._f;return b._locale=b._locale||vb.localeData(b._l),null===d||e===a&&""===d?vb.invalid({nullInput:!0}):("string"==typeof d&&(b._i=d=b._locale.preparse(d)),vb.isMoment(d)?new m(d,!0):(e?w(e)?_(b):Y(b):db(b),c=new m(b),c._nextDay&&(c.add(1,"d"),c._nextDay=a),c))}function mb(a,b){var c,d;if(1===b.length&&w(b[0])&&(b=b[0]),!b.length)return vb();for(c=b[0],d=1;d<b.length;++d)b[d][a](c)&&(c=b[d]);return c}function nb(a,b){var c;return"string"==typeof b&&(b=a.localeData().monthsParse(b),"number"!=typeof b)?a:(c=Math.min(a.date(),D(a.year(),b)),a._d["set"+(a._isUTC?"UTC":"")+"Month"](b,c),a)}function ob(a,b){return a._d["get"+(a._isUTC?"UTC":"")+b]()}function pb(a,b,c){return"Month"===b?nb(a,c):a._d["set"+(a._isUTC?"UTC":"")+b](c)}function qb(a,b){return function(c){return null!=c?(pb(this,a,c),vb.updateOffset(this,b),this):ob(this,a)}}function rb(a){return 400*a/146097}function sb(a){return 146097*a/400}function tb(a){vb.duration.fn[a]=function(){return this._data[a]}}function ub(a){"undefined"==typeof ender&&(wb=zb.moment,zb.moment=a?f("Accessing Moment through the global scope is deprecated, and will be removed in an upcoming release.",vb):vb)}for(var vb,wb,xb,yb="2.9.0",zb="undefined"==typeof global||"undefined"!=typeof window&&window!==global.window?this:global,Ab=Math.round,Bb=Object.prototype.hasOwnProperty,Cb=0,Db=1,Eb=2,Fb=3,Gb=4,Hb=5,Ib=6,Jb={},Kb=[],Lb="undefined"!=typeof module&&module&&module.exports,Mb=/^\/?Date\((\-?\d+)/i,Nb=/(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,Ob=/^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,Pb=/(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g,Qb=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,Rb=/\d\d?/,Sb=/\d{1,3}/,Tb=/\d{1,4}/,Ub=/[+\-]?\d{1,6}/,Vb=/\d+/,Wb=/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,Xb=/Z|[\+\-]\d\d:?\d\d/gi,Yb=/T/i,Zb=/[\+\-]?\d+/,$b=/[\+\-]?\d+(\.\d{1,3})?/,_b=/\d/,ac=/\d\d/,bc=/\d{3}/,cc=/\d{4}/,dc=/[+-]?\d{6}/,ec=/[+-]?\d+/,fc=/^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,gc="YYYY-MM-DDTHH:mm:ssZ",hc=[["YYYYYY-MM-DD",/[+-]\d{6}-\d{2}-\d{2}/],["YYYY-MM-DD",/\d{4}-\d{2}-\d{2}/],["GGGG-[W]WW-E",/\d{4}-W\d{2}-\d/],["GGGG-[W]WW",/\d{4}-W\d{2}/],["YYYY-DDD",/\d{4}-\d{3}/]],ic=[["HH:mm:ss.SSSS",/(T| )\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss",/(T| )\d\d:\d\d:\d\d/],["HH:mm",/(T| )\d\d:\d\d/],["HH",/(T| )\d\d/]],jc=/([\+\-]|\d\d)/gi,kc=("Date|Hours|Minutes|Seconds|Milliseconds".split("|"),{Milliseconds:1,Seconds:1e3,Minutes:6e4,Hours:36e5,Days:864e5,Months:2592e6,Years:31536e6}),lc={ms:"millisecond",s:"second",m:"minute",h:"hour",d:"day",D:"date",w:"week",W:"isoWeek",M:"month",Q:"quarter",y:"year",DDD:"dayOfYear",e:"weekday",E:"isoWeekday",gg:"weekYear",GG:"isoWeekYear"},mc={dayofyear:"dayOfYear",isoweekday:"isoWeekday",isoweek:"isoWeek",weekyear:"weekYear",isoweekyear:"isoWeekYear"},nc={},oc={s:45,m:45,h:22,d:26,M:11},pc="DDD w W M D d".split(" "),qc="M D H h m s w W".split(" "),rc={M:function(){return this.month()+1},MMM:function(a){return this.localeData().monthsShort(this,a)},MMMM:function(a){return this.localeData().months(this,a)},D:function(){return this.date()},DDD:function(){return this.dayOfYear()},d:function(){return this.day()},dd:function(a){return this.localeData().weekdaysMin(this,a)},ddd:function(a){return this.localeData().weekdaysShort(this,a)},dddd:function(a){return this.localeData().weekdays(this,a)},w:function(){return this.week()},W:function(){return this.isoWeek()},YY:function(){return r(this.year()%100,2)},YYYY:function(){return r(this.year(),4)},YYYYY:function(){return r(this.year(),5)},YYYYYY:function(){var a=this.year(),b=a>=0?"+":"-";return b+r(Math.abs(a),6)},gg:function(){return r(this.weekYear()%100,2)},gggg:function(){return r(this.weekYear(),4)},ggggg:function(){return r(this.weekYear(),5)},GG:function(){return r(this.isoWeekYear()%100,2)},GGGG:function(){return r(this.isoWeekYear(),4)},GGGGG:function(){return r(this.isoWeekYear(),5)},e:function(){return this.weekday()},E:function(){return this.isoWeekday()},a:function(){return this.localeData().meridiem(this.hours(),this.minutes(),!0)},A:function(){return this.localeData().meridiem(this.hours(),this.minutes(),!1)},H:function(){return this.hours()},h:function(){return this.hours()%12||12},m:function(){return this.minutes()},s:function(){return this.seconds()},S:function(){return C(this.milliseconds()/100)},SS:function(){return r(C(this.milliseconds()/10),2)},SSS:function(){return r(this.milliseconds(),3)},SSSS:function(){return r(this.milliseconds(),3)},Z:function(){var a=this.utcOffset(),b="+";return 0>a&&(a=-a,b="-"),b+r(C(a/60),2)+":"+r(C(a)%60,2)},ZZ:function(){var a=this.utcOffset(),b="+";return 0>a&&(a=-a,b="-"),b+r(C(a/60),2)+r(C(a)%60,2)},z:function(){return this.zoneAbbr()},zz:function(){return this.zoneName()},x:function(){return this.valueOf()},X:function(){return this.unix()},Q:function(){return this.quarter()}},sc={},tc=["months","monthsShort","weekdays","weekdaysShort","weekdaysMin"],uc=!1;pc.length;)xb=pc.pop(),rc[xb+"o"]=i(rc[xb],xb);for(;qc.length;)xb=qc.pop(),rc[xb+xb]=h(rc[xb],2);rc.DDDD=h(rc.DDD,3),o(l.prototype,{set:function(a){var b,c;for(c in a)b=a[c],"function"==typeof b?this[c]=b:this["_"+c]=b;this._ordinalParseLenient=new RegExp(this._ordinalParse.source+"|"+/\d{1,2}/.source)},_months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),months:function(a){return this._months[a.month()]},_monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),monthsShort:function(a){return this._monthsShort[a.month()]},monthsParse:function(a,b,c){var d,e,f;for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),d=0;12>d;d++){if(e=vb.utc([2e3,d]),c&&!this._longMonthsParse[d]&&(this._longMonthsParse[d]=new RegExp("^"+this.months(e,"").replace(".","")+"$","i"),this._shortMonthsParse[d]=new RegExp("^"+this.monthsShort(e,"").replace(".","")+"$","i")),c||this._monthsParse[d]||(f="^"+this.months(e,"")+"|^"+this.monthsShort(e,""),this._monthsParse[d]=new RegExp(f.replace(".",""),"i")),c&&"MMMM"===b&&this._longMonthsParse[d].test(a))return d;if(c&&"MMM"===b&&this._shortMonthsParse[d].test(a))return d;if(!c&&this._monthsParse[d].test(a))return d}},_weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdays:function(a){return this._weekdays[a.day()]},_weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysShort:function(a){return this._weekdaysShort[a.day()]},_weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),weekdaysMin:function(a){return this._weekdaysMin[a.day()]},weekdaysParse:function(a){var b,c,d;for(this._weekdaysParse||(this._weekdaysParse=[]),b=0;7>b;b++)if(this._weekdaysParse[b]||(c=vb([2e3,1]).day(b),d="^"+this.weekdays(c,"")+"|^"+this.weekdaysShort(c,"")+"|^"+this.weekdaysMin(c,""),this._weekdaysParse[b]=new RegExp(d.replace(".",""),"i")),this._weekdaysParse[b].test(a))return b},_longDateFormat:{LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY LT",LLLL:"dddd, MMMM D, YYYY LT"},longDateFormat:function(a){var b=this._longDateFormat[a];return!b&&this._longDateFormat[a.toUpperCase()]&&(b=this._longDateFormat[a.toUpperCase()].replace(/MMMM|MM|DD|dddd/g,function(a){return a.slice(1)}),this._longDateFormat[a]=b),b},isPM:function(a){return"p"===(a+"").toLowerCase().charAt(0)},_meridiemParse:/[ap]\.?m?\.?/i,meridiem:function(a,b,c){return a>11?c?"pm":"PM":c?"am":"AM"},_calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},calendar:function(a,b,c){var d=this._calendar[a];return"function"==typeof d?d.apply(b,[c]):d},_relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},relativeTime:function(a,b,c,d){var e=this._relativeTime[c];return"function"==typeof e?e(a,b,c,d):e.replace(/%d/i,a)},pastFuture:function(a,b){var c=this._relativeTime[a>0?"future":"past"];return"function"==typeof c?c(b):c.replace(/%s/i,b)},ordinal:function(a){return this._ordinal.replace("%d",a)},_ordinal:"%d",_ordinalParse:/\d{1,2}/,preparse:function(a){return a},postformat:function(a){return a},week:function(a){return jb(a,this._week.dow,this._week.doy).week},_week:{dow:0,doy:6},firstDayOfWeek:function(){return this._week.dow},firstDayOfYear:function(){return this._week.doy},_invalidDate:"Invalid date",invalidDate:function(){return this._invalidDate}}),vb=function(b,c,e,f){var g;return"boolean"==typeof e&&(f=e,e=a),g={},g._isAMomentObject=!0,g._i=b,g._f=c,g._l=e,g._strict=f,g._isUTC=!1,g._pf=d(),lb(g)},vb.suppressDeprecationWarnings=!1,vb.createFromInputFallback=f("moment construction falls back to js Date. This is discouraged and will be removed in upcoming major release. Please refer to https://github.com/moment/moment/issues/1407 for more info.",function(a){a._d=new Date(a._i+(a._useUTC?" UTC":""))}),vb.min=function(){var a=[].slice.call(arguments,0);return mb("isBefore",a)},vb.max=function(){var a=[].slice.call(arguments,0);return mb("isAfter",a)},vb.utc=function(b,c,e,f){var g;return"boolean"==typeof e&&(f=e,e=a),g={},g._isAMomentObject=!0,g._useUTC=!0,g._isUTC=!0,g._l=e,g._i=b,g._f=c,g._strict=f,g._pf=d(),lb(g).utc()},vb.unix=function(a){return vb(1e3*a)},vb.duration=function(a,b){var d,e,f,g,h=a,i=null;return vb.isDuration(a)?h={ms:a._milliseconds,d:a._days,M:a._months}:"number"==typeof a?(h={},b?h[b]=a:h.milliseconds=a):(i=Nb.exec(a))?(d="-"===i[1]?-1:1,h={y:0,d:C(i[Eb])*d,h:C(i[Fb])*d,m:C(i[Gb])*d,s:C(i[Hb])*d,ms:C(i[Ib])*d}):(i=Ob.exec(a))?(d="-"===i[1]?-1:1,f=function(a){var b=a&&parseFloat(a.replace(",","."));return(isNaN(b)?0:b)*d},h={y:f(i[2]),M:f(i[3]),d:f(i[4]),h:f(i[5]),m:f(i[6]),s:f(i[7]),w:f(i[8])}):null==h?h={}:"object"==typeof h&&("from"in h||"to"in h)&&(g=t(vb(h.from),vb(h.to)),h={},h.ms=g.milliseconds,h.M=g.months),e=new n(h),vb.isDuration(a)&&c(a,"_locale")&&(e._locale=a._locale),e},vb.version=yb,vb.defaultFormat=gc,vb.ISO_8601=function(){},vb.momentProperties=Kb,vb.updateOffset=function(){},vb.relativeTimeThreshold=function(b,c){return oc[b]===a?!1:c===a?oc[b]:(oc[b]=c,!0)},vb.lang=f("moment.lang is deprecated. Use moment.locale instead.",function(a,b){return vb.locale(a,b)}),vb.locale=function(a,b){var c;return a&&(c="undefined"!=typeof b?vb.defineLocale(a,b):vb.localeData(a),c&&(vb.duration._locale=vb._locale=c)),vb._locale._abbr},vb.defineLocale=function(a,b){return null!==b?(b.abbr=a,Jb[a]||(Jb[a]=new l),Jb[a].set(b),vb.locale(a),Jb[a]):(delete Jb[a],null)},vb.langData=f("moment.langData is deprecated. Use moment.localeData instead.",function(a){return vb.localeData(a)}),vb.localeData=function(a){var b;if(a&&a._locale&&a._locale._abbr&&(a=a._locale._abbr),!a)return vb._locale;if(!w(a)){if(b=L(a))return b;a=[a]}return K(a)},vb.isMoment=function(a){return a instanceof m||null!=a&&c(a,"_isAMomentObject")},vb.isDuration=function(a){return a instanceof n};for(xb=tc.length-1;xb>=0;--xb)B(tc[xb]);vb.normalizeUnits=function(a){return z(a)},vb.invalid=function(a){var b=vb.utc(0/0);return null!=a?o(b._pf,a):b._pf.userInvalidated=!0,b},vb.parseZone=function(){return vb.apply(null,arguments).parseZone()},vb.parseTwoDigitYear=function(a){return C(a)+(C(a)>68?1900:2e3)},vb.isDate=x,o(vb.fn=m.prototype,{clone:function(){return vb(this)},valueOf:function(){return+this._d-6e4*(this._offset||0)},unix:function(){return Math.floor(+this/1e3)},toString:function(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},toDate:function(){return this._offset?new Date(+this):this._d},toISOString:function(){var a=vb(this).utc();return 0<a.year()&&a.year()<=9999?"function"==typeof Date.prototype.toISOString?this.toDate().toISOString():P(a,"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]"):P(a,"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")},toArray:function(){var a=this;return[a.year(),a.month(),a.date(),a.hours(),a.minutes(),a.seconds(),a.milliseconds()]},isValid:function(){return I(this)},isDSTShifted:function(){return this._a?this.isValid()&&y(this._a,(this._isUTC?vb.utc(this._a):vb(this._a)).toArray())>0:!1},parsingFlags:function(){return o({},this._pf)},invalidAt:function(){return this._pf.overflow},utc:function(a){return this.utcOffset(0,a)},local:function(a){return this._isUTC&&(this.utcOffset(0,a),this._isUTC=!1,a&&this.subtract(this._dateUtcOffset(),"m")),this},format:function(a){var b=P(this,a||vb.defaultFormat);return this.localeData().postformat(b)},add:u(1,"add"),subtract:u(-1,"subtract"),diff:function(a,b,c){var d,e,f=M(a,this),g=6e4*(f.utcOffset()-this.utcOffset());return b=z(b),"year"===b||"month"===b||"quarter"===b?(e=j(this,f),"quarter"===b?e/=3:"year"===b&&(e/=12)):(d=this-f,e="second"===b?d/1e3:"minute"===b?d/6e4:"hour"===b?d/36e5:"day"===b?(d-g)/864e5:"week"===b?(d-g)/6048e5:d),c?e:q(e)},from:function(a,b){return vb.duration({to:this,from:a}).locale(this.locale()).humanize(!b)},fromNow:function(a){return this.from(vb(),a)},calendar:function(a){var b=a||vb(),c=M(b,this).startOf("day"),d=this.diff(c,"days",!0),e=-6>d?"sameElse":-1>d?"lastWeek":0>d?"lastDay":1>d?"sameDay":2>d?"nextDay":7>d?"nextWeek":"sameElse";return this.format(this.localeData().calendar(e,this,vb(b)))},isLeapYear:function(){return G(this.year())},isDST:function(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()},day:function(a){var b=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=a?(a=gb(a,this.localeData()),this.add(a-b,"d")):b},month:qb("Month",!0),startOf:function(a){switch(a=z(a)){case"year":this.month(0);case"quarter":case"month":this.date(1);case"week":case"isoWeek":case"day":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return"week"===a?this.weekday(0):"isoWeek"===a&&this.isoWeekday(1),"quarter"===a&&this.month(3*Math.floor(this.month()/3)),this},endOf:function(b){return b=z(b),b===a||"millisecond"===b?this:this.startOf(b).add(1,"isoWeek"===b?"week":b).subtract(1,"ms")},isAfter:function(a,b){var c;return b=z("undefined"!=typeof b?b:"millisecond"),"millisecond"===b?(a=vb.isMoment(a)?a:vb(a),+this>+a):(c=vb.isMoment(a)?+a:+vb(a),c<+this.clone().startOf(b))},isBefore:function(a,b){var c;return b=z("undefined"!=typeof b?b:"millisecond"),"millisecond"===b?(a=vb.isMoment(a)?a:vb(a),+a>+this):(c=vb.isMoment(a)?+a:+vb(a),+this.clone().endOf(b)<c)},isBetween:function(a,b,c){return this.isAfter(a,c)&&this.isBefore(b,c)},isSame:function(a,b){var c;return b=z(b||"millisecond"),"millisecond"===b?(a=vb.isMoment(a)?a:vb(a),+this===+a):(c=+vb(a),+this.clone().startOf(b)<=c&&c<=+this.clone().endOf(b))},min:f("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548",function(a){return a=vb.apply(null,arguments),this>a?this:a}),max:f("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548",function(a){return a=vb.apply(null,arguments),a>this?this:a}),zone:f("moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779",function(a,b){return null!=a?("string"!=typeof a&&(a=-a),this.utcOffset(a,b),this):-this.utcOffset()}),utcOffset:function(a,b){var c,d=this._offset||0;return null!=a?("string"==typeof a&&(a=S(a)),Math.abs(a)<16&&(a=60*a),!this._isUTC&&b&&(c=this._dateUtcOffset()),this._offset=a,this._isUTC=!0,null!=c&&this.add(c,"m"),d!==a&&(!b||this._changeInProgress?v(this,vb.duration(a-d,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,vb.updateOffset(this,!0),this._changeInProgress=null)),this):this._isUTC?d:this._dateUtcOffset()},isLocal:function(){return!this._isUTC},isUtcOffset:function(){return this._isUTC},isUtc:function(){return this._isUTC&&0===this._offset},zoneAbbr:function(){return this._isUTC?"UTC":""},zoneName:function(){return this._isUTC?"Coordinated Universal Time":""},parseZone:function(){return this._tzm?this.utcOffset(this._tzm):"string"==typeof this._i&&this.utcOffset(S(this._i)),this},hasAlignedHourOffset:function(a){return a=a?vb(a).utcOffset():0,(this.utcOffset()-a)%60===0},daysInMonth:function(){return D(this.year(),this.month())},dayOfYear:function(a){var b=Ab((vb(this).startOf("day")-vb(this).startOf("year"))/864e5)+1;return null==a?b:this.add(a-b,"d")},quarter:function(a){return null==a?Math.ceil((this.month()+1)/3):this.month(3*(a-1)+this.month()%3)},weekYear:function(a){var b=jb(this,this.localeData()._week.dow,this.localeData()._week.doy).year;return null==a?b:this.add(a-b,"y")},isoWeekYear:function(a){var b=jb(this,1,4).year;return null==a?b:this.add(a-b,"y")},week:function(a){var b=this.localeData().week(this);return null==a?b:this.add(7*(a-b),"d")},isoWeek:function(a){var b=jb(this,1,4).week;return null==a?b:this.add(7*(a-b),"d")},weekday:function(a){var b=(this.day()+7-this.localeData()._week.dow)%7;return null==a?b:this.add(a-b,"d")},isoWeekday:function(a){return null==a?this.day()||7:this.day(this.day()%7?a:a-7)},isoWeeksInYear:function(){return E(this.year(),1,4)},weeksInYear:function(){var a=this.localeData()._week;return E(this.year(),a.dow,a.doy)},get:function(a){return a=z(a),this[a]()},set:function(a,b){var c;if("object"==typeof a)for(c in a)this.set(c,a[c]);else a=z(a),"function"==typeof this[a]&&this[a](b);return this},locale:function(b){var c;return b===a?this._locale._abbr:(c=vb.localeData(b),null!=c&&(this._locale=c),this)},lang:f("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(b){return b===a?this.localeData():this.locale(b)}),localeData:function(){return this._locale},_dateUtcOffset:function(){return 15*-Math.round(this._d.getTimezoneOffset()/15)}}),vb.fn.millisecond=vb.fn.milliseconds=qb("Milliseconds",!1),vb.fn.second=vb.fn.seconds=qb("Seconds",!1),vb.fn.minute=vb.fn.minutes=qb("Minutes",!1),vb.fn.hour=vb.fn.hours=qb("Hours",!0),vb.fn.date=qb("Date",!0),vb.fn.dates=f("dates accessor is deprecated. Use date instead.",qb("Date",!0)),vb.fn.year=qb("FullYear",!0),vb.fn.years=f("years accessor is deprecated. Use year instead.",qb("FullYear",!0)),vb.fn.days=vb.fn.day,vb.fn.months=vb.fn.month,vb.fn.weeks=vb.fn.week,vb.fn.isoWeeks=vb.fn.isoWeek,vb.fn.quarters=vb.fn.quarter,vb.fn.toJSON=vb.fn.toISOString,vb.fn.isUTC=vb.fn.isUtc,o(vb.duration.fn=n.prototype,{_bubble:function(){var a,b,c,d=this._milliseconds,e=this._days,f=this._months,g=this._data,h=0;g.milliseconds=d%1e3,a=q(d/1e3),g.seconds=a%60,b=q(a/60),g.minutes=b%60,c=q(b/60),g.hours=c%24,e+=q(c/24),h=q(rb(e)),e-=q(sb(h)),f+=q(e/30),e%=30,h+=q(f/12),f%=12,g.days=e,g.months=f,g.years=h},abs:function(){return this._milliseconds=Math.abs(this._milliseconds),this._days=Math.abs(this._days),this._months=Math.abs(this._months),this._data.milliseconds=Math.abs(this._data.milliseconds),this._data.seconds=Math.abs(this._data.seconds),this._data.minutes=Math.abs(this._data.minutes),this._data.hours=Math.abs(this._data.hours),this._data.months=Math.abs(this._data.months),this._data.years=Math.abs(this._data.years),this},weeks:function(){return q(this.days()/7)},valueOf:function(){return this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*C(this._months/12)
},humanize:function(a){var b=ib(this,!a,this.localeData());return a&&(b=this.localeData().pastFuture(+this,b)),this.localeData().postformat(b)},add:function(a,b){var c=vb.duration(a,b);return this._milliseconds+=c._milliseconds,this._days+=c._days,this._months+=c._months,this._bubble(),this},subtract:function(a,b){var c=vb.duration(a,b);return this._milliseconds-=c._milliseconds,this._days-=c._days,this._months-=c._months,this._bubble(),this},get:function(a){return a=z(a),this[a.toLowerCase()+"s"]()},as:function(a){var b,c;if(a=z(a),"month"===a||"year"===a)return b=this._days+this._milliseconds/864e5,c=this._months+12*rb(b),"month"===a?c:c/12;switch(b=this._days+Math.round(sb(this._months/12)),a){case"week":return b/7+this._milliseconds/6048e5;case"day":return b+this._milliseconds/864e5;case"hour":return 24*b+this._milliseconds/36e5;case"minute":return 24*b*60+this._milliseconds/6e4;case"second":return 24*b*60*60+this._milliseconds/1e3;case"millisecond":return Math.floor(24*b*60*60*1e3)+this._milliseconds;default:throw new Error("Unknown unit "+a)}},lang:vb.fn.lang,locale:vb.fn.locale,toIsoString:f("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",function(){return this.toISOString()}),toISOString:function(){var a=Math.abs(this.years()),b=Math.abs(this.months()),c=Math.abs(this.days()),d=Math.abs(this.hours()),e=Math.abs(this.minutes()),f=Math.abs(this.seconds()+this.milliseconds()/1e3);return this.asSeconds()?(this.asSeconds()<0?"-":"")+"P"+(a?a+"Y":"")+(b?b+"M":"")+(c?c+"D":"")+(d||e||f?"T":"")+(d?d+"H":"")+(e?e+"M":"")+(f?f+"S":""):"P0D"},localeData:function(){return this._locale},toJSON:function(){return this.toISOString()}}),vb.duration.fn.toString=vb.duration.fn.toISOString;for(xb in kc)c(kc,xb)&&tb(xb.toLowerCase());vb.duration.fn.asMilliseconds=function(){return this.as("ms")},vb.duration.fn.asSeconds=function(){return this.as("s")},vb.duration.fn.asMinutes=function(){return this.as("m")},vb.duration.fn.asHours=function(){return this.as("h")},vb.duration.fn.asDays=function(){return this.as("d")},vb.duration.fn.asWeeks=function(){return this.as("weeks")},vb.duration.fn.asMonths=function(){return this.as("M")},vb.duration.fn.asYears=function(){return this.as("y")},vb.locale("en",{ordinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(a){var b=a%10,c=1===C(a%100/10)?"th":1===b?"st":2===b?"nd":3===b?"rd":"th";return a+c}}),Lb?module.exports=vb:"function"==typeof define&&define.amd?(define(function(a,b,c){return c.config&&c.config()&&c.config().noGlobal===!0&&(zb.moment=wb),vb}),ub(!0)):ub()}).call(this);/*! jQuery UI - v1.11.2 - 2014-10-17
* http://jqueryui.com
* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */
(function(e){"function"==typeof define&&define.amd?define(["jquery"],e):e(jQuery)})(function(e){function t(t,s){var n,a,o,r=t.nodeName.toLowerCase();return"area"===r?(n=t.parentNode,a=n.name,t.href&&a&&"map"===n.nodeName.toLowerCase()?(o=e("img[usemap='#"+a+"']")[0],!!o&&i(o)):!1):(/input|select|textarea|button|object/.test(r)?!t.disabled:"a"===r?t.href||s:s)&&i(t)}function i(t){return e.expr.filters.visible(t)&&!e(t).parents().addBack().filter(function(){return"hidden"===e.css(this,"visibility")}).length}e.ui=e.ui||{},e.extend(e.ui,{version:"1.11.2",keyCode:{BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}}),e.fn.extend({scrollParent:function(t){var i=this.css("position"),s="absolute"===i,n=t?/(auto|scroll|hidden)/:/(auto|scroll)/,a=this.parents().filter(function(){var t=e(this);return s&&"static"===t.css("position")?!1:n.test(t.css("overflow")+t.css("overflow-y")+t.css("overflow-x"))}).eq(0);return"fixed"!==i&&a.length?a:e(this[0].ownerDocument||document)},uniqueId:function(){var e=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++e)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&e(this).removeAttr("id")})}}),e.extend(e.expr[":"],{data:e.expr.createPseudo?e.expr.createPseudo(function(t){return function(i){return!!e.data(i,t)}}):function(t,i,s){return!!e.data(t,s[3])},focusable:function(i){return t(i,!isNaN(e.attr(i,"tabindex")))},tabbable:function(i){var s=e.attr(i,"tabindex"),n=isNaN(s);return(n||s>=0)&&t(i,!n)}}),e("<a>").outerWidth(1).jquery||e.each(["Width","Height"],function(t,i){function s(t,i,s,a){return e.each(n,function(){i-=parseFloat(e.css(t,"padding"+this))||0,s&&(i-=parseFloat(e.css(t,"border"+this+"Width"))||0),a&&(i-=parseFloat(e.css(t,"margin"+this))||0)}),i}var n="Width"===i?["Left","Right"]:["Top","Bottom"],a=i.toLowerCase(),o={innerWidth:e.fn.innerWidth,innerHeight:e.fn.innerHeight,outerWidth:e.fn.outerWidth,outerHeight:e.fn.outerHeight};e.fn["inner"+i]=function(t){return void 0===t?o["inner"+i].call(this):this.each(function(){e(this).css(a,s(this,t)+"px")})},e.fn["outer"+i]=function(t,n){return"number"!=typeof t?o["outer"+i].call(this,t):this.each(function(){e(this).css(a,s(this,t,!0,n)+"px")})}}),e.fn.addBack||(e.fn.addBack=function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}),e("<a>").data("a-b","a").removeData("a-b").data("a-b")&&(e.fn.removeData=function(t){return function(i){return arguments.length?t.call(this,e.camelCase(i)):t.call(this)}}(e.fn.removeData)),e.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()),e.fn.extend({focus:function(t){return function(i,s){return"number"==typeof i?this.each(function(){var t=this;setTimeout(function(){e(t).focus(),s&&s.call(t)},i)}):t.apply(this,arguments)}}(e.fn.focus),disableSelection:function(){var e="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.bind(e+".ui-disableSelection",function(e){e.preventDefault()})}}(),enableSelection:function(){return this.unbind(".ui-disableSelection")},zIndex:function(t){if(void 0!==t)return this.css("zIndex",t);if(this.length)for(var i,s,n=e(this[0]);n.length&&n[0]!==document;){if(i=n.css("position"),("absolute"===i||"relative"===i||"fixed"===i)&&(s=parseInt(n.css("zIndex"),10),!isNaN(s)&&0!==s))return s;n=n.parent()}return 0}}),e.ui.plugin={add:function(t,i,s){var n,a=e.ui[t].prototype;for(n in s)a.plugins[n]=a.plugins[n]||[],a.plugins[n].push([i,s[n]])},call:function(e,t,i,s){var n,a=e.plugins[t];if(a&&(s||e.element[0].parentNode&&11!==e.element[0].parentNode.nodeType))for(n=0;a.length>n;n++)e.options[a[n][0]]&&a[n][1].apply(e.element,i)}}});
/*! jQuery UI - v1.11.2 - 2014-10-17
* http://jqueryui.com
* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */
(function(e){"function"==typeof define&&define.amd?define(["jquery"],e):e(jQuery)})(function(e){var t=0,i=Array.prototype.slice;return e.cleanData=function(t){return function(i){var s,n,a;for(a=0;null!=(n=i[a]);a++)try{s=e._data(n,"events"),s&&s.remove&&e(n).triggerHandler("remove")}catch(o){}t(i)}}(e.cleanData),e.widget=function(t,i,s){var n,a,o,r,h={},l=t.split(".")[0];return t=t.split(".")[1],n=l+"-"+t,s||(s=i,i=e.Widget),e.expr[":"][n.toLowerCase()]=function(t){return!!e.data(t,n)},e[l]=e[l]||{},a=e[l][t],o=e[l][t]=function(e,t){return this._createWidget?(arguments.length&&this._createWidget(e,t),void 0):new o(e,t)},e.extend(o,a,{version:s.version,_proto:e.extend({},s),_childConstructors:[]}),r=new i,r.options=e.widget.extend({},r.options),e.each(s,function(t,s){return e.isFunction(s)?(h[t]=function(){var e=function(){return i.prototype[t].apply(this,arguments)},n=function(e){return i.prototype[t].apply(this,e)};return function(){var t,i=this._super,a=this._superApply;return this._super=e,this._superApply=n,t=s.apply(this,arguments),this._super=i,this._superApply=a,t}}(),void 0):(h[t]=s,void 0)}),o.prototype=e.widget.extend(r,{widgetEventPrefix:a?r.widgetEventPrefix||t:t},h,{constructor:o,namespace:l,widgetName:t,widgetFullName:n}),a?(e.each(a._childConstructors,function(t,i){var s=i.prototype;e.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete a._childConstructors):i._childConstructors.push(o),e.widget.bridge(t,o),o},e.widget.extend=function(t){for(var s,n,a=i.call(arguments,1),o=0,r=a.length;r>o;o++)for(s in a[o])n=a[o][s],a[o].hasOwnProperty(s)&&void 0!==n&&(t[s]=e.isPlainObject(n)?e.isPlainObject(t[s])?e.widget.extend({},t[s],n):e.widget.extend({},n):n);return t},e.widget.bridge=function(t,s){var n=s.prototype.widgetFullName||t;e.fn[t]=function(a){var o="string"==typeof a,r=i.call(arguments,1),h=this;return a=!o&&r.length?e.widget.extend.apply(null,[a].concat(r)):a,o?this.each(function(){var i,s=e.data(this,n);return"instance"===a?(h=s,!1):s?e.isFunction(s[a])&&"_"!==a.charAt(0)?(i=s[a].apply(s,r),i!==s&&void 0!==i?(h=i&&i.jquery?h.pushStack(i.get()):i,!1):void 0):e.error("no such method '"+a+"' for "+t+" widget instance"):e.error("cannot call methods on "+t+" prior to initialization; "+"attempted to call method '"+a+"'")}):this.each(function(){var t=e.data(this,n);t?(t.option(a||{}),t._init&&t._init()):e.data(this,n,new s(a,this))}),h}},e.Widget=function(){},e.Widget._childConstructors=[],e.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{disabled:!1,create:null},_createWidget:function(i,s){s=e(s||this.defaultElement||this)[0],this.element=e(s),this.uuid=t++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=e(),this.hoverable=e(),this.focusable=e(),s!==this&&(e.data(s,this.widgetFullName,this),this._on(!0,this.element,{remove:function(e){e.target===s&&this.destroy()}}),this.document=e(s.style?s.ownerDocument:s.document||s),this.window=e(this.document[0].defaultView||this.document[0].parentWindow)),this.options=e.widget.extend({},this.options,this._getCreateOptions(),i),this._create(),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:e.noop,_getCreateEventData:e.noop,_create:e.noop,_init:e.noop,destroy:function(){this._destroy(),this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)),this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName+"-disabled "+"ui-state-disabled"),this.bindings.unbind(this.eventNamespace),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")},_destroy:e.noop,widget:function(){return this.element},option:function(t,i){var s,n,a,o=t;if(0===arguments.length)return e.widget.extend({},this.options);if("string"==typeof t)if(o={},s=t.split("."),t=s.shift(),s.length){for(n=o[t]=e.widget.extend({},this.options[t]),a=0;s.length-1>a;a++)n[s[a]]=n[s[a]]||{},n=n[s[a]];if(t=s.pop(),1===arguments.length)return void 0===n[t]?null:n[t];n[t]=i}else{if(1===arguments.length)return void 0===this.options[t]?null:this.options[t];o[t]=i}return this._setOptions(o),this},_setOptions:function(e){var t;for(t in e)this._setOption(t,e[t]);return this},_setOption:function(e,t){return this.options[e]=t,"disabled"===e&&(this.widget().toggleClass(this.widgetFullName+"-disabled",!!t),t&&(this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus"))),this},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_on:function(t,i,s){var n,a=this;"boolean"!=typeof t&&(s=i,i=t,t=!1),s?(i=n=e(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,n=this.widget()),e.each(s,function(s,o){function r(){return t||a.options.disabled!==!0&&!e(this).hasClass("ui-state-disabled")?("string"==typeof o?a[o]:o).apply(a,arguments):void 0}"string"!=typeof o&&(r.guid=o.guid=o.guid||r.guid||e.guid++);var h=s.match(/^([\w:-]*)\s*(.*)$/),l=h[1]+a.eventNamespace,u=h[2];u?n.delegate(u,l,r):i.bind(l,r)})},_off:function(t,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,t.unbind(i).undelegate(i),this.bindings=e(this.bindings.not(t).get()),this.focusable=e(this.focusable.not(t).get()),this.hoverable=e(this.hoverable.not(t).get())},_delay:function(e,t){function i(){return("string"==typeof e?s[e]:e).apply(s,arguments)}var s=this;return setTimeout(i,t||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){e(t.currentTarget).addClass("ui-state-hover")},mouseleave:function(t){e(t.currentTarget).removeClass("ui-state-hover")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){e(t.currentTarget).addClass("ui-state-focus")},focusout:function(t){e(t.currentTarget).removeClass("ui-state-focus")}})},_trigger:function(t,i,s){var n,a,o=this.options[t];if(s=s||{},i=e.Event(i),i.type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),i.target=this.element[0],a=i.originalEvent)for(n in a)n in i||(i[n]=a[n]);return this.element.trigger(i,s),!(e.isFunction(o)&&o.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},e.each({show:"fadeIn",hide:"fadeOut"},function(t,i){e.Widget.prototype["_"+t]=function(s,n,a){"string"==typeof n&&(n={effect:n});var o,r=n?n===!0||"number"==typeof n?i:n.effect||i:t;n=n||{},"number"==typeof n&&(n={duration:n}),o=!e.isEmptyObject(n),n.complete=a,n.delay&&s.delay(n.delay),o&&e.effects&&e.effects.effect[r]?s[t](n):r!==t&&s[r]?s[r](n.duration,n.easing,a):s.queue(function(i){e(this)[t](),a&&a.call(s[0]),i()})}}),e.widget});
/*! jQuery UI - v1.11.2 - 2014-10-17
* http://jqueryui.com
* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */
(function(e){"function"==typeof define&&define.amd?define(["jquery","./widget"],e):e(jQuery)})(function(e){var t=!1;return e(document).mouseup(function(){t=!1}),e.widget("ui.mouse",{version:"1.11.2",options:{cancel:"input,textarea,button,select,option",distance:1,delay:0},_mouseInit:function(){var t=this;this.element.bind("mousedown."+this.widgetName,function(e){return t._mouseDown(e)}).bind("click."+this.widgetName,function(i){return!0===e.data(i.target,t.widgetName+".preventClickEvent")?(e.removeData(i.target,t.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.unbind("."+this.widgetName),this._mouseMoveDelegate&&this.document.unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(i){if(!t){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(i),this._mouseDownEvent=i;var s=this,n=1===i.which,a="string"==typeof this.options.cancel&&i.target.nodeName?e(i.target).closest(this.options.cancel).length:!1;return n&&!a&&this._mouseCapture(i)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){s.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(i)&&this._mouseDelayMet(i)&&(this._mouseStarted=this._mouseStart(i)!==!1,!this._mouseStarted)?(i.preventDefault(),!0):(!0===e.data(i.target,this.widgetName+".preventClickEvent")&&e.removeData(i.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(e){return s._mouseMove(e)},this._mouseUpDelegate=function(e){return s._mouseUp(e)},this.document.bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate),i.preventDefault(),t=!0,!0)):!0}},_mouseMove:function(t){if(this._mouseMoved){if(e.ui.ie&&(!document.documentMode||9>document.documentMode)&&!t.button)return this._mouseUp(t);if(!t.which)return this._mouseUp(t)}return(t.which||t.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(t),t.preventDefault()):(this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,t)!==!1,this._mouseStarted?this._mouseDrag(t):this._mouseUp(t)),!this._mouseStarted)},_mouseUp:function(i){return this.document.unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,i.target===this._mouseDownEvent.target&&e.data(i.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(i)),t=!1,!1},_mouseDistanceMet:function(e){return Math.max(Math.abs(this._mouseDownEvent.pageX-e.pageX),Math.abs(this._mouseDownEvent.pageY-e.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}})});
/*! jQuery UI - v1.11.2 - 2014-10-17
* http://jqueryui.com
* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */
(function(e){"function"==typeof define&&define.amd?define(["jquery","./core","./mouse","./widget"],e):e(jQuery)})(function(e){return e.widget("ui.draggable",e.ui.mouse,{version:"1.11.2",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this.element.addClass("ui-draggable"),this.options.disabled&&this.element.addClass("ui-draggable-disabled"),this._setHandleClassName(),this._mouseInit()},_setOption:function(e,t){this._super(e,t),"handle"===e&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?(this.destroyOnClear=!0,void 0):(this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),this._removeHandleClassName(),this._mouseDestroy(),void 0)},_mouseCapture:function(t){var i=this.options;return this._blurActiveElement(t),this.helper||i.disabled||e(t.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(t),this.handle?(this._blockFrames(i.iframeFix===!0?"iframe":i.iframeFix),!0):!1)},_blockFrames:function(t){this.iframeBlocks=this.document.find(t).map(function(){var t=e(this);return e("<div>").css("position","absolute").appendTo(t.parent()).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).offset(t.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(t){var i=this.document[0];if(this.handleElement.is(t.target))try{i.activeElement&&"body"!==i.activeElement.nodeName.toLowerCase()&&e(i.activeElement).blur()}catch(s){}},_mouseStart:function(t){var i=this.options;return this.helper=this._createHelper(t),this.helper.addClass("ui-draggable-dragging"),this._cacheHelperProportions(),e.ui.ddmanager&&(e.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=this.helper.parents().filter(function(){return"fixed"===e(this).css("position")}).length>0,this.positionAbs=this.element.offset(),this._refreshOffsets(t),this.originalPosition=this.position=this._generatePosition(t,!1),this.originalPageX=t.pageX,this.originalPageY=t.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",t)===!1?(this._clear(),!1):(this._cacheHelperProportions(),e.ui.ddmanager&&!i.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this._normalizeRightBottom(),this._mouseDrag(t,!0),e.ui.ddmanager&&e.ui.ddmanager.dragStart(this,t),!0)},_refreshOffsets:function(e){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:e.pageX-this.offset.left,top:e.pageY-this.offset.top}},_mouseDrag:function(t,i){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(t,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",t,s)===!1)return this._mouseUp({}),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),!1},_mouseStop:function(t){var i=this,s=!1;return e.ui.ddmanager&&!this.options.dropBehaviour&&(s=e.ui.ddmanager.drop(this,t)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||this.options.revert===!0||e.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?e(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",t)!==!1&&i._clear()}):this._trigger("stop",t)!==!1&&this._clear(),!1},_mouseUp:function(t){return this._unblockFrames(),e.ui.ddmanager&&e.ui.ddmanager.dragStop(this,t),this.handleElement.is(t.target)&&this.element.focus(),e.ui.mouse.prototype._mouseUp.call(this,t)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear(),this},_getHandle:function(t){return this.options.handle?!!e(t.target).closest(this.element.find(this.options.handle)).length:!0},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this.handleElement.addClass("ui-draggable-handle")},_removeHandleClassName:function(){this.handleElement.removeClass("ui-draggable-handle")},_createHelper:function(t){var i=this.options,s=e.isFunction(i.helper),n=s?e(i.helper.apply(this.element[0],[t])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return n.parents("body").length||n.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s&&n[0]===this.element[0]&&this._setPositionRelative(),n[0]===this.element[0]||/(fixed|absolute)/.test(n.css("position"))||n.css("position","absolute"),n},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_isRootNode:function(e){return/(html|body)/i.test(e.tagName)||e===this.document[0]},_getParentOffset:function(){var t=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var e=this.element.position(),t=this._isRootNode(this.scrollParent[0]);return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+(t?0:this.scrollParent.scrollTop()),left:e.left-(parseInt(this.helper.css("left"),10)||0)+(t?0:this.scrollParent.scrollLeft())}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,i,s,n=this.options,a=this.document[0];return this.relativeContainer=null,n.containment?"window"===n.containment?(this.containment=[e(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,e(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,e(window).scrollLeft()+e(window).width()-this.helperProportions.width-this.margins.left,e(window).scrollTop()+(e(window).height()||a.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):"document"===n.containment?(this.containment=[0,0,e(a).width()-this.helperProportions.width-this.margins.left,(e(a).height()||a.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):n.containment.constructor===Array?(this.containment=n.containment,void 0):("parent"===n.containment&&(n.containment=this.helper[0].parentNode),i=e(n.containment),s=i[0],s&&(t=/(scroll|auto)/.test(i.css("overflow")),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(t?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(t?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=i),void 0):(this.containment=null,void 0)},_convertPositionTo:function(e,t){t||(t=this.position);var i="absolute"===e?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:t.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:t.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(e,t){var i,s,n,a,o=this.options,r=this._isRootNode(this.scrollParent[0]),h=e.pageX,l=e.pageY;return r&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),t&&(this.containment&&(this.relativeContainer?(s=this.relativeContainer.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,e.pageX-this.offset.click.left<i[0]&&(h=i[0]+this.offset.click.left),e.pageY-this.offset.click.top<i[1]&&(l=i[1]+this.offset.click.top),e.pageX-this.offset.click.left>i[2]&&(h=i[2]+this.offset.click.left),e.pageY-this.offset.click.top>i[3]&&(l=i[3]+this.offset.click.top)),o.grid&&(n=o.grid[1]?this.originalPageY+Math.round((l-this.originalPageY)/o.grid[1])*o.grid[1]:this.originalPageY,l=i?n-this.offset.click.top>=i[1]||n-this.offset.click.top>i[3]?n:n-this.offset.click.top>=i[1]?n-o.grid[1]:n+o.grid[1]:n,a=o.grid[0]?this.originalPageX+Math.round((h-this.originalPageX)/o.grid[0])*o.grid[0]:this.originalPageX,h=i?a-this.offset.click.left>=i[0]||a-this.offset.click.left>i[2]?a:a-this.offset.click.left>=i[0]?a-o.grid[0]:a+o.grid[0]:a),"y"===o.axis&&(h=this.originalPageX),"x"===o.axis&&(l=this.originalPageY)),{top:l-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:r?0:this.offset.scroll.top),left:h-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:r?0:this.offset.scroll.left)}},_clear:function(){this.helper.removeClass("ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_normalizeRightBottom:function(){"y"!==this.options.axis&&"auto"!==this.helper.css("right")&&(this.helper.width(this.helper.width()),this.helper.css("right","auto")),"x"!==this.options.axis&&"auto"!==this.helper.css("bottom")&&(this.helper.height(this.helper.height()),this.helper.css("bottom","auto"))},_trigger:function(t,i,s){return s=s||this._uiHash(),e.ui.plugin.call(this,t,[i,s,this],!0),/^(drag|start|stop)/.test(t)&&(this.positionAbs=this._convertPositionTo("absolute"),s.offset=this.positionAbs),e.Widget.prototype._trigger.call(this,t,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),e.ui.plugin.add("draggable","connectToSortable",{start:function(t,i,s){var n=e.extend({},i,{item:s.element});s.sortables=[],e(s.options.connectToSortable).each(function(){var i=e(this).sortable("instance");i&&!i.options.disabled&&(s.sortables.push(i),i.refreshPositions(),i._trigger("activate",t,n))})},stop:function(t,i,s){var n=e.extend({},i,{item:s.element});s.cancelHelperRemoval=!1,e.each(s.sortables,function(){var e=this;e.isOver?(e.isOver=0,s.cancelHelperRemoval=!0,e.cancelHelperRemoval=!1,e._storedCSS={position:e.placeholder.css("position"),top:e.placeholder.css("top"),left:e.placeholder.css("left")},e._mouseStop(t),e.options.helper=e.options._helper):(e.cancelHelperRemoval=!0,e._trigger("deactivate",t,n))})},drag:function(t,i,s){e.each(s.sortables,function(){var n=!1,a=this;a.positionAbs=s.positionAbs,a.helperProportions=s.helperProportions,a.offset.click=s.offset.click,a._intersectsWith(a.containerCache)&&(n=!0,e.each(s.sortables,function(){return this.positionAbs=s.positionAbs,this.helperProportions=s.helperProportions,this.offset.click=s.offset.click,this!==a&&this._intersectsWith(this.containerCache)&&e.contains(a.element[0],this.element[0])&&(n=!1),n})),n?(a.isOver||(a.isOver=1,a.currentItem=i.helper.appendTo(a.element).data("ui-sortable-item",!0),a.options._helper=a.options.helper,a.options.helper=function(){return i.helper[0]},t.target=a.currentItem[0],a._mouseCapture(t,!0),a._mouseStart(t,!0,!0),a.offset.click.top=s.offset.click.top,a.offset.click.left=s.offset.click.left,a.offset.parent.left-=s.offset.parent.left-a.offset.parent.left,a.offset.parent.top-=s.offset.parent.top-a.offset.parent.top,s._trigger("toSortable",t),s.dropped=a.element,e.each(s.sortables,function(){this.refreshPositions()}),s.currentItem=s.element,a.fromOutside=s),a.currentItem&&(a._mouseDrag(t),i.position=a.position)):a.isOver&&(a.isOver=0,a.cancelHelperRemoval=!0,a.options._revert=a.options.revert,a.options.revert=!1,a._trigger("out",t,a._uiHash(a)),a._mouseStop(t,!0),a.options.revert=a.options._revert,a.options.helper=a.options._helper,a.placeholder&&a.placeholder.remove(),s._refreshOffsets(t),i.position=s._generatePosition(t,!0),s._trigger("fromSortable",t),s.dropped=!1,e.each(s.sortables,function(){this.refreshPositions()}))})}}),e.ui.plugin.add("draggable","cursor",{start:function(t,i,s){var n=e("body"),a=s.options;n.css("cursor")&&(a._cursor=n.css("cursor")),n.css("cursor",a.cursor)},stop:function(t,i,s){var n=s.options;n._cursor&&e("body").css("cursor",n._cursor)}}),e.ui.plugin.add("draggable","opacity",{start:function(t,i,s){var n=e(i.helper),a=s.options;n.css("opacity")&&(a._opacity=n.css("opacity")),n.css("opacity",a.opacity)},stop:function(t,i,s){var n=s.options;n._opacity&&e(i.helper).css("opacity",n._opacity)}}),e.ui.plugin.add("draggable","scroll",{start:function(e,t,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(t,i,s){var n=s.options,a=!1,o=s.scrollParentNotHidden[0],r=s.document[0];o!==r&&"HTML"!==o.tagName?(n.axis&&"x"===n.axis||(s.overflowOffset.top+o.offsetHeight-t.pageY<n.scrollSensitivity?o.scrollTop=a=o.scrollTop+n.scrollSpeed:t.pageY-s.overflowOffset.top<n.scrollSensitivity&&(o.scrollTop=a=o.scrollTop-n.scrollSpeed)),n.axis&&"y"===n.axis||(s.overflowOffset.left+o.offsetWidth-t.pageX<n.scrollSensitivity?o.scrollLeft=a=o.scrollLeft+n.scrollSpeed:t.pageX-s.overflowOffset.left<n.scrollSensitivity&&(o.scrollLeft=a=o.scrollLeft-n.scrollSpeed))):(n.axis&&"x"===n.axis||(t.pageY-e(r).scrollTop()<n.scrollSensitivity?a=e(r).scrollTop(e(r).scrollTop()-n.scrollSpeed):e(window).height()-(t.pageY-e(r).scrollTop())<n.scrollSensitivity&&(a=e(r).scrollTop(e(r).scrollTop()+n.scrollSpeed))),n.axis&&"y"===n.axis||(t.pageX-e(r).scrollLeft()<n.scrollSensitivity?a=e(r).scrollLeft(e(r).scrollLeft()-n.scrollSpeed):e(window).width()-(t.pageX-e(r).scrollLeft())<n.scrollSensitivity&&(a=e(r).scrollLeft(e(r).scrollLeft()+n.scrollSpeed)))),a!==!1&&e.ui.ddmanager&&!n.dropBehaviour&&e.ui.ddmanager.prepareOffsets(s,t)}}),e.ui.plugin.add("draggable","snap",{start:function(t,i,s){var n=s.options;s.snapElements=[],e(n.snap.constructor!==String?n.snap.items||":data(ui-draggable)":n.snap).each(function(){var t=e(this),i=t.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:t.outerWidth(),height:t.outerHeight(),top:i.top,left:i.left})})},drag:function(t,i,s){var n,a,o,r,h,l,u,d,c,f,p=s.options,m=p.snapTolerance,g=i.offset.left,v=g+s.helperProportions.width,y=i.offset.top,_=y+s.helperProportions.height;for(c=s.snapElements.length-1;c>=0;c--)h=s.snapElements[c].left-s.margins.left,l=h+s.snapElements[c].width,u=s.snapElements[c].top-s.margins.top,d=u+s.snapElements[c].height,h-m>v||g>l+m||u-m>_||y>d+m||!e.contains(s.snapElements[c].item.ownerDocument,s.snapElements[c].item)?(s.snapElements[c].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,t,e.extend(s._uiHash(),{snapItem:s.snapElements[c].item})),s.snapElements[c].snapping=!1):("inner"!==p.snapMode&&(n=m>=Math.abs(u-_),a=m>=Math.abs(d-y),o=m>=Math.abs(h-v),r=m>=Math.abs(l-g),n&&(i.position.top=s._convertPositionTo("relative",{top:u-s.helperProportions.height,left:0}).top),a&&(i.position.top=s._convertPositionTo("relative",{top:d,left:0}).top),o&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h-s.helperProportions.width}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left)),f=n||a||o||r,"outer"!==p.snapMode&&(n=m>=Math.abs(u-y),a=m>=Math.abs(d-_),o=m>=Math.abs(h-g),r=m>=Math.abs(l-v),n&&(i.position.top=s._convertPositionTo("relative",{top:u,left:0}).top),a&&(i.position.top=s._convertPositionTo("relative",{top:d-s.helperProportions.height,left:0}).top),o&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left)),!s.snapElements[c].snapping&&(n||a||o||r||f)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,t,e.extend(s._uiHash(),{snapItem:s.snapElements[c].item})),s.snapElements[c].snapping=n||a||o||r||f)}}),e.ui.plugin.add("draggable","stack",{start:function(t,i,s){var n,a=s.options,o=e.makeArray(e(a.stack)).sort(function(t,i){return(parseInt(e(t).css("zIndex"),10)||0)-(parseInt(e(i).css("zIndex"),10)||0)});o.length&&(n=parseInt(e(o[0]).css("zIndex"),10)||0,e(o).each(function(t){e(this).css("zIndex",n+t)}),this.css("zIndex",n+o.length))}}),e.ui.plugin.add("draggable","zIndex",{start:function(t,i,s){var n=e(i.helper),a=s.options;n.css("zIndex")&&(a._zIndex=n.css("zIndex")),n.css("zIndex",a.zIndex)},stop:function(t,i,s){var n=s.options;n._zIndex&&e(i.helper).css("zIndex",n._zIndex)}}),e.ui.draggable});/*!
 * FullCalendar v2.5.0
 * Docs & License: http://fullcalendar.io/
 * (c) 2015 Adam Shaw
 */
	(function (factory) {
		if (typeof define === 'function' && define.amd) {
			define(['jquery', 'moment'], factory);
		}
		else if (typeof exports === 'object') { // Node/CommonJS
			module.exports = factory(require('jquery'), require('moment'));
		}
		else {
			factory(jQuery, moment);
		}
	})(function ($, moment) {

		;
		;

		var FC = $.fullCalendar = {
			version: "2.5.0",
			internalApiVersion: 1
		};
		var fcViews = FC.views = {};


		$.fn.fullCalendar = function (options) {
			var args = Array.prototype.slice.call(arguments, 1); // for a possible method call
			var res = this; // what this function will return (this jQuery object by default)

			this.each(function (i, _element) { // loop each DOM element involved
				var element = $(_element);
				var calendar = element.data('fullCalendar'); // get the existing calendar object (if any)
				var singleRes; // the returned value of this single method call

				// a method call
				if (typeof options === 'string') {
					if (calendar && $.isFunction(calendar[options])) {
						singleRes = calendar[options].apply(calendar, args);
						if (!i) {
							res = singleRes; // record the first method call result
						}
						if (options === 'destroy') { // for the destroy method, must remove Calendar object data
							element.removeData('fullCalendar');
						}
					}
				}
				// a new calendar initialization
				else if (!calendar) { // don't initialize twice
					calendar = new Calendar(element, options);
					element.data('fullCalendar', calendar);
					calendar.render();
				}
			});

			return res;
		};


		var complexOptions = [ // names of options that are objects whose properties should be combined
			'header',
			'buttonText',
			'buttonIcons',
			'themeButtonIcons'
		];


// Merges an array of option objects into a single object
		function mergeOptions(optionObjs) {
			return mergeProps(optionObjs, complexOptions);
		}


// Given options specified for the calendar's constructor, massages any legacy options into a non-legacy form.
// Converts View-Option-Hashes into the View-Specific-Options format.
		function massageOverrides(input) {
			var overrides = {views: input.views || {}}; // the output. ensure a `views` hash
			var subObj;

			// iterate through all option override properties (except `views`)
			$.each(input, function (name, val) {
				if (name != 'views') {

					// could the value be a legacy View-Option-Hash?
					if (
						$.isPlainObject(val) && !/(time|duration|interval)$/i.test(name) && // exclude duration options. might be given as objects
						$.inArray(name, complexOptions) == -1 // complex options aren't allowed to be View-Option-Hashes
					) {
						subObj = null;

						// iterate through the properties of this possible View-Option-Hash value
						$.each(val, function (subName, subVal) {

							// is the property targeting a view?
							if (/^(month|week|day|default|basic(Week|Day)?|agenda(Week|Day)?)$/.test(subName)) {
								if (!overrides.views[subName]) { // ensure the view-target entry exists
									overrides.views[subName] = {};
								}
								overrides.views[subName][name] = subVal; // record the value in the `views` object
							}
							else { // a non-View-Option-Hash property
								if (!subObj) {
									subObj = {};
								}
								subObj[subName] = subVal; // accumulate these unrelated values for later
							}
						});

						if (subObj) { // non-View-Option-Hash properties? transfer them as-is
							overrides[name] = subObj;
						}
					}
					else {
						overrides[name] = val; // transfer normal options as-is
					}
				}
			});

			return overrides;
		}

		;
		;

// exports
		FC.intersectRanges = intersectRanges;
		FC.applyAll = applyAll;
		FC.debounce = debounce;
		FC.isInt = isInt;
		FC.htmlEscape = htmlEscape;
		FC.cssToStr = cssToStr;
		FC.proxy = proxy;
		FC.capitaliseFirstLetter = capitaliseFirstLetter;


		/* FullCalendar-specific DOM Utilities
		 ----------------------------------------------------------------------------------------------------------------------*/


// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left
// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.
		function compensateScroll(rowEls, scrollbarWidths) {
			if (scrollbarWidths.left) {
				rowEls.css({
					'border-left-width': 1,
					'margin-left': scrollbarWidths.left - 1
				});
			}
			if (scrollbarWidths.right) {
				rowEls.css({
					'border-right-width': 1,
					'margin-right': scrollbarWidths.right - 1
				});
			}
		}


// Undoes compensateScroll and restores all borders/margins
		function uncompensateScroll(rowEls) {
			rowEls.css({
				'margin-left': '',
				'margin-right': '',
				'border-left-width': '',
				'border-right-width': ''
			});
		}


// Make the mouse cursor express that an event is not allowed in the current area
		function disableCursor() {
			$('body').addClass('fc-not-allowed');
		}


// Returns the mouse cursor to its original look
		function enableCursor() {
			$('body').removeClass('fc-not-allowed');
		}


// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.
// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering
// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and 
// reduces the available height.
		function distributeHeight(els, availableHeight, shouldRedistribute) {

			// *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
			// and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.

			var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element
			var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*
			var flexEls = []; // elements that are allowed to expand. array of DOM nodes
			var flexOffsets = []; // amount of vertical space it takes up
			var flexHeights = []; // actual css height
			var usedHeight = 0;

			undistributeHeight(els); // give all elements their natural height

			// find elements that are below the recommended height (expandable).
			// important to query for heights in a single first pass (to avoid reflow oscillation).
			els.each(function (i, el) {
				var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
				var naturalOffset = $(el).outerHeight(true);

				if (naturalOffset < minOffset) {
					flexEls.push(el);
					flexOffsets.push(naturalOffset);
					flexHeights.push($(el).height());
				}
				else {
					// this element stretches past recommended height (non-expandable). mark the space as occupied.
					usedHeight += naturalOffset;
				}
			});

			// readjust the recommended height to only consider the height available to non-maxed-out rows.
			if (shouldRedistribute) {
				availableHeight -= usedHeight;
				minOffset1 = Math.floor(availableHeight / flexEls.length);
				minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*
			}

			// assign heights to all expandable elements
			$(flexEls).each(function (i, el) {
				var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
				var naturalOffset = flexOffsets[i];
				var naturalHeight = flexHeights[i];
				var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding

				if (naturalOffset < minOffset) { // we check this again because redistribution might have changed things
					$(el).height(newHeight);
				}
			});
		}


// Undoes distrubuteHeight, restoring all els to their natural height
		function undistributeHeight(els) {
			els.height('');
		}


// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the
// cells to be that width.
// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline
		function matchCellWidths(els) {
			var maxInnerWidth = 0;

			els.find('> *').each(function (i, innerEl) {
				var innerWidth = $(innerEl).outerWidth();
				if (innerWidth > maxInnerWidth) {
					maxInnerWidth = innerWidth;
				}
			});

			maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance

			els.width(maxInnerWidth);

			return maxInnerWidth;
		}


// Turns a container element into a scroller if its contents is taller than the allotted height.
// Returns true if the element is now a scroller, false otherwise.
// NOTE: this method is best because it takes weird zooming dimensions into account
		function setPotentialScroller(containerEl, height) {
			containerEl.height(height).addClass('fc-scroller');

			// are scrollbars needed?
			if (containerEl[0].scrollHeight - 1 > containerEl[0].clientHeight) { // !!! -1 because IE is often off-by-one :(
				return true;
			}

			unsetScroller(containerEl); // undo
			return false;
		}


// Takes an element that might have been a scroller, and turns it back into a normal element.
		function unsetScroller(containerEl) {
			containerEl.height('').removeClass('fc-scroller');
		}


		/* General DOM Utilities
		 ----------------------------------------------------------------------------------------------------------------------*/

		FC.getOuterRect = getOuterRect;
		FC.getClientRect = getClientRect;
		FC.getContentRect = getContentRect;
		FC.getScrollbarWidths = getScrollbarWidths;


// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51
		function getScrollParent(el) {
			var position = el.css('position'),
				scrollParent = el.parents().filter(function () {
					var parent = $(this);
					return (/(auto|scroll)/).test(
						parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x')
					);
				}).eq(0);

			return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;
		}


// Queries the outer bounding area of a jQuery element.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
		function getOuterRect(el) {
			var offset = el.offset();

			return {
				left: offset.left,
				right: offset.left + el.outerWidth(),
				top: offset.top,
				bottom: offset.top + el.outerHeight()
			};
		}


// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
		function getClientRect(el) {
			var offset = el.offset();
			var scrollbarWidths = getScrollbarWidths(el);
			var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left;
			var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top;

			return {
				left: left,
				right: left + el[0].clientWidth, // clientWidth includes padding but NOT scrollbars
				top: top,
				bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars
			};
		}


// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
		function getContentRect(el) {
			var offset = el.offset(); // just outside of border, margin not included
			var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left');
			var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top');

			return {
				left: left,
				right: left + el.width(),
				top: top,
				bottom: top + el.height()
			};
		}


// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
		function getScrollbarWidths(el) {
			var leftRightWidth = el.innerWidth() - el[0].clientWidth; // the paddings cancel out, leaving the scrollbars
			var widths = {
				left: 0,
				right: 0,
				top: 0,
				bottom: el.innerHeight() - el[0].clientHeight // the paddings cancel out, leaving the bottom scrollbar
			};

			if (getIsLeftRtlScrollbars() && el.css('direction') == 'rtl') { // is the scrollbar on the left side?
				widths.left = leftRightWidth;
			}
			else {
				widths.right = leftRightWidth;
			}

			return widths;
		}


// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side

		var _isLeftRtlScrollbars = null;

		function getIsLeftRtlScrollbars() { // responsible for caching the computation
			if (_isLeftRtlScrollbars === null) {
				_isLeftRtlScrollbars = computeIsLeftRtlScrollbars();
			}
			return _isLeftRtlScrollbars;
		}

		function computeIsLeftRtlScrollbars() { // creates an offscreen test element, then removes it
			var el = $('<div><div/></div>')
				.css({
					position: 'absolute',
					top: -1000,
					left: 0,
					border: 0,
					padding: 0,
					overflow: 'scroll',
					direction: 'rtl'
				})
				.appendTo('body');
			var innerEl = el.children();
			var res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?
			el.remove();
			return res;
		}


// Retrieves a jQuery element's computed CSS value as a floating-point number.
// If the queried value is non-numeric (ex: IE can return "medium" for border width), will just return zero.
		function getCssFloat(el, prop) {
			return parseFloat(el.css(prop)) || 0;
		}


// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
		function isPrimaryMouseButton(ev) {
			return ev.which == 1 && !ev.ctrlKey;
		}


		/* Geometry
		 ----------------------------------------------------------------------------------------------------------------------*/

		FC.intersectRects = intersectRects;

// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false
		function intersectRects(rect1, rect2) {
			var res = {
				left: Math.max(rect1.left, rect2.left),
				right: Math.min(rect1.right, rect2.right),
				top: Math.max(rect1.top, rect2.top),
				bottom: Math.min(rect1.bottom, rect2.bottom)
			};

			if (res.left < res.right && res.top < res.bottom) {
				return res;
			}
			return false;
		}


// Returns a new point that will have been moved to reside within the given rectangle
		function constrainPoint(point, rect) {
			return {
				left: Math.min(Math.max(point.left, rect.left), rect.right),
				top: Math.min(Math.max(point.top, rect.top), rect.bottom)
			};
		}


// Returns a point that is the center of the given rectangle
		function getRectCenter(rect) {
			return {
				left: (rect.left + rect.right) / 2,
				top: (rect.top + rect.bottom) / 2
			};
		}


// Subtracts point2's coordinates from point1's coordinates, returning a delta
		function diffPoints(point1, point2) {
			return {
				left: point1.left - point2.left,
				top: point1.top - point2.top
			};
		}


		/* Object Ordering by Field
		 ----------------------------------------------------------------------------------------------------------------------*/

		FC.parseFieldSpecs = parseFieldSpecs;
		FC.compareByFieldSpecs = compareByFieldSpecs;
		FC.compareByFieldSpec = compareByFieldSpec;
		FC.flexibleCompare = flexibleCompare;


		function parseFieldSpecs(input) {
			var specs = [];
			var tokens = [];
			var i, token;

			if (typeof input === 'string') {
				tokens = input.split(/\s*,\s*/);
			}
			else if (typeof input === 'function') {
				tokens = [input];
			}
			else if ($.isArray(input)) {
				tokens = input;
			}

			for (i = 0; i < tokens.length; i++) {
				token = tokens[i];

				if (typeof token === 'string') {
					specs.push(
						token.charAt(0) == '-' ?
						{field: token.substring(1), order: -1} :
						{field: token, order: 1}
					);
				}
				else if (typeof token === 'function') {
					specs.push({func: token});
				}
			}

			return specs;
		}


		function compareByFieldSpecs(obj1, obj2, fieldSpecs) {
			var i;
			var cmp;

			for (i = 0; i < fieldSpecs.length; i++) {
				cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i]);
				if (cmp) {
					return cmp;
				}
			}

			return 0;
		}


		function compareByFieldSpec(obj1, obj2, fieldSpec) {
			if (fieldSpec.func) {
				return fieldSpec.func(obj1, obj2);
			}
			return flexibleCompare(obj1[fieldSpec.field], obj2[fieldSpec.field]) *
				(fieldSpec.order || 1);
		}


		function flexibleCompare(a, b) {
			if (!a && !b) {
				return 0;
			}
			if (b == null) {
				return -1;
			}
			if (a == null) {
				return 1;
			}
			if ($.type(a) === 'string' || $.type(b) === 'string') {
				return String(a).localeCompare(String(b));
			}
			return a - b;
		}


		/* FullCalendar-specific Misc Utilities
		 ----------------------------------------------------------------------------------------------------------------------*/


// Computes the intersection of the two ranges. Returns undefined if no intersection.
// Expects all dates to be normalized to the same timezone beforehand.
// TODO: move to date section?
		function intersectRanges(subjectRange, constraintRange) {
			var subjectStart = subjectRange.start;
			var subjectEnd = subjectRange.end;
			var constraintStart = constraintRange.start;
			var constraintEnd = constraintRange.end;
			var segStart, segEnd;
			var isStart, isEnd;

			if (subjectEnd > constraintStart && subjectStart < constraintEnd) { // in bounds at all?

				if (subjectStart >= constraintStart) {
					segStart = subjectStart.clone();
					isStart = true;
				}
				else {
					segStart = constraintStart.clone();
					isStart = false;
				}

				if (subjectEnd <= constraintEnd) {
					segEnd = subjectEnd.clone();
					isEnd = true;
				}
				else {
					segEnd = constraintEnd.clone();
					isEnd = false;
				}

				return {
					start: segStart,
					end: segEnd,
					isStart: isStart,
					isEnd: isEnd
				};
			}
		}


		/* Date Utilities
		 ----------------------------------------------------------------------------------------------------------------------*/

		FC.computeIntervalUnit = computeIntervalUnit;
		FC.divideRangeByDuration = divideRangeByDuration;
		FC.divideDurationByDuration = divideDurationByDuration;
		FC.multiplyDuration = multiplyDuration;
		FC.durationHasTime = durationHasTime;

		var dayIDs = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
		var intervalUnits = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];


// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.
// Moments will have their timezones normalized.
		function diffDayTime(a, b) {
			return moment.duration({
				days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),
				ms: a.time() - b.time() // time-of-day from day start. disregards timezone
			});
		}


// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.
		function diffDay(a, b) {
			return moment.duration({
				days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')
			});
		}


// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.
		function diffByUnit(a, b, unit) {
			return moment.duration(
				Math.round(a.diff(b, unit, true)), // returnFloat=true
				unit
			);
		}


// Computes the unit name of the largest whole-unit period of time.
// For example, 48 hours will be "days" whereas 49 hours will be "hours".
// Accepts start/end, a range object, or an original duration object.
		function computeIntervalUnit(start, end) {
			var i, unit;
			var val;

			for (i = 0; i < intervalUnits.length; i++) {
				unit = intervalUnits[i];
				val = computeRangeAs(unit, start, end);

				if (val >= 1 && isInt(val)) {
					break;
				}
			}

			return unit; // will be "milliseconds" if nothing else matches
		}


// Computes the number of units (like "hours") in the given range.
// Range can be a {start,end} object, separate start/end args, or a Duration.
// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling
// of month-diffing logic (which tends to vary from version to version).
		function computeRangeAs(unit, start, end) {

			if (end != null) { // given start, end
				return end.diff(start, unit, true);
			}
			else if (moment.isDuration(start)) { // given duration
				return start.as(unit);
			}
			else { // given { start, end } range object
				return start.end.diff(start.start, unit, true);
			}
		}


// Intelligently divides a range (specified by a start/end params) by a duration
		function divideRangeByDuration(start, end, dur) {
			var months;

			if (durationHasTime(dur)) {
				return (end - start) / dur;
			}
			months = dur.asMonths();
			if (Math.abs(months) >= 1 && isInt(months)) {
				return end.diff(start, 'months', true) / months;
			}
			return end.diff(start, 'days', true) / dur.asDays();
		}


// Intelligently divides one duration by another
		function divideDurationByDuration(dur1, dur2) {
			var months1, months2;

			if (durationHasTime(dur1) || durationHasTime(dur2)) {
				return dur1 / dur2;
			}
			months1 = dur1.asMonths();
			months2 = dur2.asMonths();
			if (
				Math.abs(months1) >= 1 && isInt(months1) &&
				Math.abs(months2) >= 1 && isInt(months2)
			) {
				return months1 / months2;
			}
			return dur1.asDays() / dur2.asDays();
		}


// Intelligently multiplies a duration by a number
		function multiplyDuration(dur, n) {
			var months;

			if (durationHasTime(dur)) {
				return moment.duration(dur * n);
			}
			months = dur.asMonths();
			if (Math.abs(months) >= 1 && isInt(months)) {
				return moment.duration({months: months * n});
			}
			return moment.duration({days: dur.asDays() * n});
		}


// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)
		function durationHasTime(dur) {
			return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());
		}


		function isNativeDate(input) {
			return Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;
		}


// Returns a boolean about whether the given input is a time string, like "06:40:00" or "06:00"
		function isTimeString(str) {
			return /^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(str);
		}


		/* Logging and Debug
		 ----------------------------------------------------------------------------------------------------------------------*/

		FC.log = function () {
			var console = window.console;

			if (console && console.log) {
				return console.log.apply(console, arguments);
			}
		};

		FC.warn = function () {
			var console = window.console;

			if (console && console.warn) {
				return console.warn.apply(console, arguments);
			}
			else {
				return FC.log.apply(FC, arguments);
			}
		};


		/* General Utilities
		 ----------------------------------------------------------------------------------------------------------------------*/

		var hasOwnPropMethod = {}.hasOwnProperty;


// Merges an array of objects into a single object.
// The second argument allows for an array of property names who's object values will be merged together.
		function mergeProps(propObjs, complexProps) {
			var dest = {};
			var i, name;
			var complexObjs;
			var j, val;
			var props;

			if (complexProps) {
				for (i = 0; i < complexProps.length; i++) {
					name = complexProps[i];
					complexObjs = [];

					// collect the trailing object values, stopping when a non-object is discovered
					for (j = propObjs.length - 1; j >= 0; j--) {
						val = propObjs[j][name];

						if (typeof val === 'object') {
							complexObjs.unshift(val);
						}
						else if (val !== undefined) {
							dest[name] = val; // if there were no objects, this value will be used
							break;
						}
					}

					// if the trailing values were objects, use the merged value
					if (complexObjs.length) {
						dest[name] = mergeProps(complexObjs);
					}
				}
			}

			// copy values into the destination, going from last to first
			for (i = propObjs.length - 1; i >= 0; i--) {
				props = propObjs[i];

				for (name in props) {
					if (!(name in dest)) { // if already assigned by previous props or complex props, don't reassign
						dest[name] = props[name];
					}
				}
			}

			return dest;
		}


// Create an object that has the given prototype. Just like Object.create
		function createObject(proto) {
			var f = function () {
			};
			f.prototype = proto;
			return new f();
		}


		function copyOwnProps(src, dest) {
			for (var name in src) {
				if (hasOwnProp(src, name)) {
					dest[name] = src[name];
				}
			}
		}


// Copies over certain methods with the same names as Object.prototype methods. Overcomes an IE<=8 bug:
// https://developer.mozilla.org/en-US/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug
		function copyNativeMethods(src, dest) {
			var names = ['constructor', 'toString', 'valueOf'];
			var i, name;

			for (i = 0; i < names.length; i++) {
				name = names[i];

				if (src[name] !== Object.prototype[name]) {
					dest[name] = src[name];
				}
			}
		}


		function hasOwnProp(obj, name) {
			return hasOwnPropMethod.call(obj, name);
		}


// Is the given value a non-object non-function value?
		function isAtomic(val) {
			return /undefined|null|boolean|number|string/.test($.type(val));
		}


		function applyAll(functions, thisObj, args) {
			if ($.isFunction(functions)) {
				functions = [functions];
			}
			if (functions) {
				var i;
				var ret;
				for (i = 0; i < functions.length; i++) {
					ret = functions[i].apply(thisObj, args) || ret;
				}
				return ret;
			}
		}


		function firstDefined() {
			for (var i = 0; i < arguments.length; i++) {
				if (arguments[i] !== undefined) {
					return arguments[i];
				}
			}
		}


		function htmlEscape(s) {
			return (s + '').replace(/&/g, '&amp;')
				.replace(/</g, '&lt;')
				.replace(/>/g, '&gt;')
				.replace(/'/g, '&#039;')
				.replace(/"/g, '&quot;')
				.replace(/\n/g, '<br />');
		}


		function stripHtmlEntities(text) {
			return text.replace(/&.*?;/g, '');
		}


// Given a hash of CSS properties, returns a string of CSS.
// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.
		function cssToStr(cssProps) {
			var statements = [];

			$.each(cssProps, function (name, val) {
				if (val != null) {
					statements.push(name + ':' + val);
				}
			});

			return statements.join(';');
		}


		function capitaliseFirstLetter(str) {
			return str.charAt(0).toUpperCase() + str.slice(1);
		}


		function compareNumbers(a, b) { // for .sort()
			return a - b;
		}


		function isInt(n) {
			return n % 1 === 0;
		}


// Returns a method bound to the given object context.
// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with
// different contexts as identical when binding/unbinding events.
		function proxy(obj, methodName) {
			var method = obj[methodName];

			return function () {
				return method.apply(obj, arguments);
			};
		}


// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds.
// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714
		function debounce(func, wait) {
			var timeoutId;
			var args;
			var context;
			var timestamp; // of most recent call
			var later = function () {
				var last = +new Date() - timestamp;
				if (last < wait && last > 0) {
					timeoutId = setTimeout(later, wait - last);
				}
				else {
					timeoutId = null;
					func.apply(context, args);
					if (!timeoutId) {
						context = args = null;
					}
				}
			};

			return function () {
				context = this;
				args = arguments;
				timestamp = +new Date();
				if (!timeoutId) {
					timeoutId = setTimeout(later, wait);
				}
			};
		}

		;
		;

		var ambigDateOfMonthRegex = /^\s*\d{4}-\d\d$/;
		var ambigTimeOrZoneRegex =
			/^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/;
		var newMomentProto = moment.fn; // where we will attach our new methods
		var oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods
		var allowValueOptimization;
		var setUTCValues; // function defined below
		var setLocalValues; // function defined below


// Creating
// -------------------------------------------------------------------------------------------------

// Creates a new moment, similar to the vanilla moment(...) constructor, but with
// extra features (ambiguous time, enhanced formatting). When given an existing moment,
// it will function as a clone (and retain the zone of the moment). Anything else will
// result in a moment in the local zone.
		FC.moment = function () {
			return makeMoment(arguments);
		};

// Sames as FC.moment, but forces the resulting moment to be in the UTC timezone.
		FC.moment.utc = function () {
			var mom = makeMoment(arguments, true);

			// Force it into UTC because makeMoment doesn't guarantee it
			// (if given a pre-existing moment for example)
			if (mom.hasTime()) { // don't give ambiguously-timed moments a UTC zone
				mom.utc();
			}

			return mom;
		};

// Same as FC.moment, but when given an ISO8601 string, the timezone offset is preserved.
// ISO8601 strings with no timezone offset will become ambiguously zoned.
		FC.moment.parseZone = function () {
			return makeMoment(arguments, true, true);
		};

// Builds an enhanced moment from args. When given an existing moment, it clones. When given a
// native Date, or called with no arguments (the current time), the resulting moment will be local.
// Anything else needs to be "parsed" (a string or an array), and will be affected by:
//    parseAsUTC - if there is no zone information, should we parse the input in UTC?
//    parseZone - if there is zone information, should we force the zone of the moment?
		function makeMoment(args, parseAsUTC, parseZone) {
			var input = args[0];
			var isSingleString = args.length == 1 && typeof input === 'string';
			var isAmbigTime;
			var isAmbigZone;
			var ambigMatch;
			var mom;

			if (moment.isMoment(input)) {
				mom = moment.apply(null, args); // clone it
				transferAmbigs(input, mom); // the ambig flags weren't transfered with the clone
			}
			else if (isNativeDate(input) || input === undefined) {
				mom = moment.apply(null, args); // will be local
			}
			else { // "parsing" is required
				isAmbigTime = false;
				isAmbigZone = false;

				if (isSingleString) {
					if (ambigDateOfMonthRegex.test(input)) {
						// accept strings like '2014-05', but convert to the first of the month
						input += '-01';
						args = [input]; // for when we pass it on to moment's constructor
						isAmbigTime = true;
						isAmbigZone = true;
					}
					else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {
						isAmbigTime = !ambigMatch[5]; // no time part?
						isAmbigZone = true;
					}
				}
				else if ($.isArray(input)) {
					// arrays have no timezone information, so assume ambiguous zone
					isAmbigZone = true;
				}
				// otherwise, probably a string with a format

				if (parseAsUTC || isAmbigTime) {
					mom = moment.utc.apply(moment, args);
				}
				else {
					mom = moment.apply(null, args);
				}

				if (isAmbigTime) {
					mom._ambigTime = true;
					mom._ambigZone = true; // ambiguous time always means ambiguous zone
				}
				else if (parseZone) { // let's record the inputted zone somehow
					if (isAmbigZone) {
						mom._ambigZone = true;
					}
					else if (isSingleString) {
						if (mom.utcOffset) {
							mom.utcOffset(input); // if not a valid zone, will assign UTC
						}
						else {
							mom.zone(input); // for moment-pre-2.9
						}
					}
				}
			}

			mom._fullCalendar = true; // flag for extended functionality

			return mom;
		}


// A clone method that works with the flags related to our enhanced functionality.
// In the future, use moment.momentProperties
		newMomentProto.clone = function () {
			var mom = oldMomentProto.clone.apply(this, arguments);

			// these flags weren't transfered with the clone
			transferAmbigs(this, mom);
			if (this._fullCalendar) {
				mom._fullCalendar = true;
			}

			return mom;
		};


// Week Number
// -------------------------------------------------------------------------------------------------


// Returns the week number, considering the locale's custom week number calcuation
// `weeks` is an alias for `week`
		newMomentProto.week = newMomentProto.weeks = function (input) {
			var weekCalc = (this._locale || this._lang) // works pre-moment-2.8
				._fullCalendar_weekCalc;

			if (input == null && typeof weekCalc === 'function') { // custom function only works for getter
				return weekCalc(this);
			}
			else if (weekCalc === 'ISO') {
				return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter
			}

			return oldMomentProto.week.apply(this, arguments); // local getter/setter
		};


// Time-of-day
// -------------------------------------------------------------------------------------------------

// GETTER
// Returns a Duration with the hours/minutes/seconds/ms values of the moment.
// If the moment has an ambiguous time, a duration of 00:00 will be returned.
//
// SETTER
// You can supply a Duration, a Moment, or a Duration-like argument.
// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.
		newMomentProto.time = function (time) {

			// Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.
			// `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.
			if (!this._fullCalendar) {
				return oldMomentProto.time.apply(this, arguments);
			}

			if (time == null) { // getter
				return moment.duration({
					hours: this.hours(),
					minutes: this.minutes(),
					seconds: this.seconds(),
					milliseconds: this.milliseconds()
				});
			}
			else { // setter

				this._ambigTime = false; // mark that the moment now has a time

				if (!moment.isDuration(time) && !moment.isMoment(time)) {
					time = moment.duration(time);
				}

				// The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).
				// Only for Duration times, not Moment times.
				var dayHours = 0;
				if (moment.isDuration(time)) {
					dayHours = Math.floor(time.asDays()) * 24;
				}

				// We need to set the individual fields.
				// Can't use startOf('day') then add duration. In case of DST at start of day.
				return this.hours(dayHours + time.hours())
					.minutes(time.minutes())
					.seconds(time.seconds())
					.milliseconds(time.milliseconds());
			}
		};

// Converts the moment to UTC, stripping out its time-of-day and timezone offset,
// but preserving its YMD. A moment with a stripped time will display no time
// nor timezone offset when .format() is called.
		newMomentProto.stripTime = function () {
			var a;

			if (!this._ambigTime) {

				// get the values before any conversion happens
				a = this.toArray(); // array of y/m/d/h/m/s/ms

				// TODO: use keepLocalTime in the future
				this.utc(); // set the internal UTC flag (will clear the ambig flags)
				setUTCValues(this, a.slice(0, 3)); // set the year/month/date. time will be zero

				// Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
				// which clears all ambig flags. Same with setUTCValues with moment-timezone.
				this._ambigTime = true;
				this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset
			}

			return this; // for chaining
		};

// Returns if the moment has a non-ambiguous time (boolean)
		newMomentProto.hasTime = function () {
			return !this._ambigTime;
		};


// Timezone
// -------------------------------------------------------------------------------------------------

// Converts the moment to UTC, stripping out its timezone offset, but preserving its
// YMD and time-of-day. A moment with a stripped timezone offset will display no
// timezone offset when .format() is called.
// TODO: look into Moment's keepLocalTime functionality
		newMomentProto.stripZone = function () {
			var a, wasAmbigTime;

			if (!this._ambigZone) {

				// get the values before any conversion happens
				a = this.toArray(); // array of y/m/d/h/m/s/ms
				wasAmbigTime = this._ambigTime;

				this.utc(); // set the internal UTC flag (might clear the ambig flags, depending on Moment internals)
				setUTCValues(this, a); // will set the year/month/date/hours/minutes/seconds/ms

				// the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore
				this._ambigTime = wasAmbigTime || false;

				// Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
				// which clears the ambig flags. Same with setUTCValues with moment-timezone.
				this._ambigZone = true;
			}

			return this; // for chaining
		};

// Returns of the moment has a non-ambiguous timezone offset (boolean)
		newMomentProto.hasZone = function () {
			return !this._ambigZone;
		};


// this method implicitly marks a zone
		newMomentProto.local = function () {
			var a = this.toArray(); // year,month,date,hours,minutes,seconds,ms as an array
			var wasAmbigZone = this._ambigZone;

			oldMomentProto.local.apply(this, arguments);

			// ensure non-ambiguous
			// this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals
			this._ambigTime = false;
			this._ambigZone = false;

			if (wasAmbigZone) {
				// If the moment was ambiguously zoned, the date fields were stored as UTC.
				// We want to preserve these, but in local time.
				// TODO: look into Moment's keepLocalTime functionality
				setLocalValues(this, a);
			}

			return this; // for chaining
		};


// implicitly marks a zone
		newMomentProto.utc = function () {
			oldMomentProto.utc.apply(this, arguments);

			// ensure non-ambiguous
			// this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals
			this._ambigTime = false;
			this._ambigZone = false;

			return this;
		};


// methods for arbitrarily manipulating timezone offset.
// should clear time/zone ambiguity when called.
		$.each([
			'zone', // only in moment-pre-2.9. deprecated afterwards
			'utcOffset'
		], function (i, name) {
			if (oldMomentProto[name]) { // original method exists?

				// this method implicitly marks a zone (will probably get called upon .utc() and .local())
				newMomentProto[name] = function (tzo) {

					if (tzo != null) { // setter
						// these assignments needs to happen before the original zone method is called.
						// I forget why, something to do with a browser crash.
						this._ambigTime = false;
						this._ambigZone = false;
					}

					return oldMomentProto[name].apply(this, arguments);
				};
			}
		});


// Formatting
// -------------------------------------------------------------------------------------------------

		newMomentProto.format = function () {
			if (this._fullCalendar && arguments[0]) { // an enhanced moment? and a format string provided?
				return formatDate(this, arguments[0]); // our extended formatting
			}
			if (this._ambigTime) {
				return oldMomentFormat(this, 'YYYY-MM-DD');
			}
			if (this._ambigZone) {
				return oldMomentFormat(this, 'YYYY-MM-DD[T]HH:mm:ss');
			}
			return oldMomentProto.format.apply(this, arguments);
		};

		newMomentProto.toISOString = function () {
			if (this._ambigTime) {
				return oldMomentFormat(this, 'YYYY-MM-DD');
			}
			if (this._ambigZone) {
				return oldMomentFormat(this, 'YYYY-MM-DD[T]HH:mm:ss');
			}
			return oldMomentProto.toISOString.apply(this, arguments);
		};


// Querying
// -------------------------------------------------------------------------------------------------

// Is the moment within the specified range? `end` is exclusive.
// FYI, this method is not a standard Moment method, so always do our enhanced logic.
		newMomentProto.isWithin = function (start, end) {
			var a = commonlyAmbiguate([this, start, end]);
			return a[0] >= a[1] && a[0] < a[2];
		};

// When isSame is called with units, timezone ambiguity is normalized before the comparison happens.
// If no units specified, the two moments must be identically the same, with matching ambig flags.
		newMomentProto.isSame = function (input, units) {
			var a;

			// only do custom logic if this is an enhanced moment
			if (!this._fullCalendar) {
				return oldMomentProto.isSame.apply(this, arguments);
			}

			if (units) {
				a = commonlyAmbiguate([this, input], true); // normalize timezones but don't erase times
				return oldMomentProto.isSame.call(a[0], a[1], units);
			}
			else {
				input = FC.moment.parseZone(input); // normalize input
				return oldMomentProto.isSame.call(this, input) &&
					Boolean(this._ambigTime) === Boolean(input._ambigTime) &&
					Boolean(this._ambigZone) === Boolean(input._ambigZone);
			}
		};

// Make these query methods work with ambiguous moments
		$.each([
			'isBefore',
			'isAfter'
		], function (i, methodName) {
			newMomentProto[methodName] = function (input, units) {
				var a;

				// only do custom logic if this is an enhanced moment
				if (!this._fullCalendar) {
					return oldMomentProto[methodName].apply(this, arguments);
				}

				a = commonlyAmbiguate([this, input]);
				return oldMomentProto[methodName].call(a[0], a[1], units);
			};
		});


// Misc Internals
// -------------------------------------------------------------------------------------------------

// given an array of moment-like inputs, return a parallel array w/ moments similarly ambiguated.
// for example, of one moment has ambig time, but not others, all moments will have their time stripped.
// set `preserveTime` to `true` to keep times, but only normalize zone ambiguity.
// returns the original moments if no modifications are necessary.
		function commonlyAmbiguate(inputs, preserveTime) {
			var anyAmbigTime = false;
			var anyAmbigZone = false;
			var len = inputs.length;
			var moms = [];
			var i, mom;

			// parse inputs into real moments and query their ambig flags
			for (i = 0; i < len; i++) {
				mom = inputs[i];
				if (!moment.isMoment(mom)) {
					mom = FC.moment.parseZone(mom);
				}
				anyAmbigTime = anyAmbigTime || mom._ambigTime;
				anyAmbigZone = anyAmbigZone || mom._ambigZone;
				moms.push(mom);
			}

			// strip each moment down to lowest common ambiguity
			// use clones to avoid modifying the original moments
			for (i = 0; i < len; i++) {
				mom = moms[i];
				if (!preserveTime && anyAmbigTime && !mom._ambigTime) {
					moms[i] = mom.clone().stripTime();
				}
				else if (anyAmbigZone && !mom._ambigZone) {
					moms[i] = mom.clone().stripZone();
				}
			}

			return moms;
		}

// Transfers all the flags related to ambiguous time/zone from the `src` moment to the `dest` moment
// TODO: look into moment.momentProperties for this.
		function transferAmbigs(src, dest) {
			if (src._ambigTime) {
				dest._ambigTime = true;
			}
			else if (dest._ambigTime) {
				dest._ambigTime = false;
			}

			if (src._ambigZone) {
				dest._ambigZone = true;
			}
			else if (dest._ambigZone) {
				dest._ambigZone = false;
			}
		}


// Sets the year/month/date/etc values of the moment from the given array.
// Inefficient because it calls each individual setter.
		function setMomentValues(mom, a) {
			mom.year(a[0] || 0)
				.month(a[1] || 0)
				.date(a[2] || 0)
				.hours(a[3] || 0)
				.minutes(a[4] || 0)
				.seconds(a[5] || 0)
				.milliseconds(a[6] || 0);
		}

// Can we set the moment's internal date directly?
		allowValueOptimization = '_d' in moment() && 'updateOffset' in moment;

// Utility function. Accepts a moment and an array of the UTC year/month/date/etc values to set.
// Assumes the given moment is already in UTC mode.
		setUTCValues = allowValueOptimization ? function (mom, a) {
			// simlate what moment's accessors do
			mom._d.setTime(Date.UTC.apply(Date, a));
			moment.updateOffset(mom, false); // keepTime=false
		} : setMomentValues;

// Utility function. Accepts a moment and an array of the local year/month/date/etc values to set.
// Assumes the given moment is already in local mode.
		setLocalValues = allowValueOptimization ? function (mom, a) {
			// simlate what moment's accessors do
			mom._d.setTime(+new Date( // FYI, there is now way to apply an array of args to a constructor
				a[0] || 0,
				a[1] || 0,
				a[2] || 0,
				a[3] || 0,
				a[4] || 0,
				a[5] || 0,
				a[6] || 0
			));
			moment.updateOffset(mom, false); // keepTime=false
		} : setMomentValues;

		;
		;

// Single Date Formatting
// -------------------------------------------------------------------------------------------------


// call this if you want Moment's original format method to be used
		function oldMomentFormat(mom, formatStr) {
			return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js
		}


// Formats `date` with a Moment formatting string, but allow our non-zero areas and
// additional token.
		function formatDate(date, formatStr) {
			return formatDateWithChunks(date, getFormatStringChunks(formatStr));
		}


		function formatDateWithChunks(date, chunks) {
			var s = '';
			var i;

			for (i = 0; i < chunks.length; i++) {
				s += formatDateWithChunk(date, chunks[i]);
			}

			return s;
		}


// addition formatting tokens we want recognized
		var tokenOverrides = {
			t: function (date) { // "a" or "p"
				return oldMomentFormat(date, 'a').charAt(0);
			},
			T: function (date) { // "A" or "P"
				return oldMomentFormat(date, 'A').charAt(0);
			}
		};


		function formatDateWithChunk(date, chunk) {
			var token;
			var maybeStr;

			if (typeof chunk === 'string') { // a literal string
				return chunk;
			}
			else if ((token = chunk.token)) { // a token, like "YYYY"
				if (tokenOverrides[token]) {
					return tokenOverrides[token](date); // use our custom token
				}
				return oldMomentFormat(date, token);
			}
			else if (chunk.maybe) { // a grouping of other chunks that must be non-zero
				maybeStr = formatDateWithChunks(date, chunk.maybe);
				if (maybeStr.match(/[1-9]/)) {
					return maybeStr;
				}
			}

			return '';
		}


// Date Range Formatting
// -------------------------------------------------------------------------------------------------
// TODO: make it work with timezone offset

// Using a formatting string meant for a single date, generate a range string, like
// "Sep 2 - 9 2013", that intelligently inserts a separator where the dates differ.
// If the dates are the same as far as the format string is concerned, just return a single
// rendering of one date, without any separator.
		function formatRange(date1, date2, formatStr, separator, isRTL) {
			var localeData;

			date1 = FC.moment.parseZone(date1);
			date2 = FC.moment.parseZone(date2);

			localeData = (date1.localeData || date1.lang).call(date1); // works with moment-pre-2.8

			// Expand localized format strings, like "LL" -> "MMMM D YYYY"
			formatStr = localeData.longDateFormat(formatStr) || formatStr;
			// BTW, this is not important for `formatDate` because it is impossible to put custom tokens
			// or non-zero areas in Moment's localized format strings.

			separator = separator || ' - ';

			return formatRangeWithChunks(
				date1,
				date2,
				getFormatStringChunks(formatStr),
				separator,
				isRTL
			);
		}

		FC.formatRange = formatRange; // expose


		function formatRangeWithChunks(date1, date2, chunks, separator, isRTL) {
			var unzonedDate1 = date1.clone().stripZone(); // for formatSimilarChunk
			var unzonedDate2 = date2.clone().stripZone(); // "
			var chunkStr; // the rendering of the chunk
			var leftI;
			var leftStr = '';
			var rightI;
			var rightStr = '';
			var middleI;
			var middleStr1 = '';
			var middleStr2 = '';
			var middleStr = '';

			// Start at the leftmost side of the formatting string and continue until you hit a token
			// that is not the same between dates.
			for (leftI = 0; leftI < chunks.length; leftI++) {
				chunkStr = formatSimilarChunk(date1, date2, unzonedDate1, unzonedDate2, chunks[leftI]);
				if (chunkStr === false) {
					break;
				}
				leftStr += chunkStr;
			}

			// Similarly, start at the rightmost side of the formatting string and move left
			for (rightI = chunks.length - 1; rightI > leftI; rightI--) {
				chunkStr = formatSimilarChunk(date1, date2, unzonedDate1, unzonedDate2, chunks[rightI]);
				if (chunkStr === false) {
					break;
				}
				rightStr = chunkStr + rightStr;
			}

			// The area in the middle is different for both of the dates.
			// Collect them distinctly so we can jam them together later.
			for (middleI = leftI; middleI <= rightI; middleI++) {
				middleStr1 += formatDateWithChunk(date1, chunks[middleI]);
				middleStr2 += formatDateWithChunk(date2, chunks[middleI]);
			}

			if (middleStr1 || middleStr2) {
				if (isRTL) {
					middleStr = middleStr2 + separator + middleStr1;
				}
				else {
					middleStr = middleStr1 + separator + middleStr2;
				}
			}

			return leftStr + middleStr + rightStr;
		}


		var similarUnitMap = {
			Y: 'year',
			M: 'month',
			D: 'day', // day of month
			d: 'day', // day of week
			// prevents a separator between anything time-related...
			A: 'second', // AM/PM
			a: 'second', // am/pm
			T: 'second', // A/P
			t: 'second', // a/p
			H: 'second', // hour (24)
			h: 'second', // hour (12)
			m: 'second', // minute
			s: 'second' // second
		};
// TODO: week maybe?


// Given a formatting chunk, and given that both dates are similar in the regard the
// formatting chunk is concerned, format date1 against `chunk`. Otherwise, return `false`.
		function formatSimilarChunk(date1, date2, unzonedDate1, unzonedDate2, chunk) {
			var token;
			var unit;

			if (typeof chunk === 'string') { // a literal string
				return chunk;
			}
			else if ((token = chunk.token)) {
				unit = similarUnitMap[token.charAt(0)];

				// are the dates the same for this unit of measurement?
				// use the unzoned dates for this calculation because unreliable when near DST (bug #2396)
				if (unit && unzonedDate1.isSame(unzonedDate2, unit)) {
					return oldMomentFormat(date1, token); // would be the same if we used `date2`
					// BTW, don't support custom tokens
				}
			}

			return false; // the chunk is NOT the same for the two dates
			// BTW, don't support splitting on non-zero areas
		}


// Chunking Utils
// -------------------------------------------------------------------------------------------------


		var formatStringChunkCache = {};


		function getFormatStringChunks(formatStr) {
			if (formatStr in formatStringChunkCache) {
				return formatStringChunkCache[formatStr];
			}
			return (formatStringChunkCache[formatStr] = chunkFormatString(formatStr));
		}


// Break the formatting string into an array of chunks
		function chunkFormatString(formatStr) {
			var chunks = [];
			var chunker = /\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g; // TODO: more descrimination
			var match;

			while ((match = chunker.exec(formatStr))) {
				if (match[1]) { // a literal string inside [ ... ]
					chunks.push(match[1]);
				}
				else if (match[2]) { // non-zero formatting inside ( ... )
					chunks.push({maybe: chunkFormatString(match[2])});
				}
				else if (match[3]) { // a formatting token
					chunks.push({token: match[3]});
				}
				else if (match[5]) { // an unenclosed literal string
					chunks.push(match[5]);
				}
			}

			return chunks;
		}

		;
		;

		FC.Class = Class; // export

// Class that all other classes will inherit from
		function Class() {
		}


// Called on a class to create a subclass.
// Last argument contains instance methods. Any argument before the last are considered mixins.
		Class.extend = function () {
			var len = arguments.length;
			var i;
			var members;

			for (i = 0; i < len; i++) {
				members = arguments[i];
				if (i < len - 1) { // not the last argument?
					mixIntoClass(this, members);
				}
			}

			return extendClass(this, members || {}); // members will be undefined if no arguments
		};


// Adds new member variables/methods to the class's prototype.
// Can be called with another class, or a plain object hash containing new members.
		Class.mixin = function (members) {
			mixIntoClass(this, members);
		};


		function extendClass(superClass, members) {
			var subClass;

			// ensure a constructor for the subclass, forwarding all arguments to the super-constructor if it doesn't exist
			if (hasOwnProp(members, 'constructor')) {
				subClass = members.constructor;
			}
			if (typeof subClass !== 'function') {
				subClass = members.constructor = function () {
					superClass.apply(this, arguments);
				};
			}

			// build the base prototype for the subclass, which is an new object chained to the superclass's prototype
			subClass.prototype = createObject(superClass.prototype);

			// copy each member variable/method onto the the subclass's prototype
			copyOwnProps(members, subClass.prototype);
			copyNativeMethods(members, subClass.prototype); // hack for IE8

			// copy over all class variables/methods to the subclass, such as `extend` and `mixin`
			copyOwnProps(superClass, subClass);

			return subClass;
		}


		function mixIntoClass(theClass, members) {
			copyOwnProps(members.prototype || members, theClass.prototype); // TODO: copyNativeMethods?
		}
		;
		;

		var Emitter = FC.Emitter = Class.extend({

			callbackHash: null,


			on: function (name, callback) {
				this.getCallbacks(name).add(callback);
				return this; // for chaining
			},


			off: function (name, callback) {
				this.getCallbacks(name).remove(callback);
				return this; // for chaining
			},


			trigger: function (name) { // args...
				var args = Array.prototype.slice.call(arguments, 1);

				this.triggerWith(name, this, args);

				return this; // for chaining
			},


			triggerWith: function (name, context, args) {
				var callbacks = this.getCallbacks(name);

				callbacks.fireWith(context, args);

				return this; // for chaining
			},


			getCallbacks: function (name) {
				var callbacks;

				if (!this.callbackHash) {
					this.callbackHash = {};
				}

				callbacks = this.callbackHash[name];
				if (!callbacks) {
					callbacks = this.callbackHash[name] = $.Callbacks();
				}

				return callbacks;
			}

		});
		;
		;

		/* A rectangular panel that is absolutely positioned over other content
		 ------------------------------------------------------------------------------------------------------------------------
		 Options:
		 - className (string)
		 - content (HTML string or jQuery element set)
		 - parentEl
		 - top
		 - left
		 - right (the x coord of where the right edge should be. not a "CSS" right)
		 - autoHide (boolean)
		 - show (callback)
		 - hide (callback)
		 */

		var Popover = Class.extend({

			isHidden: true,
			options: null,
			el: null, // the container element for the popover. generated by this object
			documentMousedownProxy: null, // document mousedown handler bound to `this`
			margin: 10, // the space required between the popover and the edges of the scroll container


			constructor: function (options) {
				this.options = options || {};
			},


			// Shows the popover on the specified position. Renders it if not already
			show: function () {
				if (this.isHidden) {
					if (!this.el) {
						this.render();
					}
					this.el.show();
					this.position();
					this.isHidden = false;
					this.trigger('show');
				}
			},


			// Hides the popover, through CSS, but does not remove it from the DOM
			hide: function () {
				if (!this.isHidden) {
					this.el.hide();
					this.isHidden = true;
					this.trigger('hide');
				}
			},


			// Creates `this.el` and renders content inside of it
			render: function () {
				var _this = this;
				var options = this.options;

				this.el = $('<div class="fc-popover"/>')
					.addClass(options.className || '')
					.css({
						// position initially to the top left to avoid creating scrollbars
						top: 0,
						left: 0
					})
					.append(options.content)
					.appendTo(options.parentEl);

				// when a click happens on anything inside with a 'fc-close' className, hide the popover
				this.el.on('click', '.fc-close', function () {
					_this.hide();
				});

				if (options.autoHide) {
					$(document).on('mousedown', this.documentMousedownProxy = proxy(this, 'documentMousedown'));
				}
			},


			// Triggered when the user clicks *anywhere* in the document, for the autoHide feature
			documentMousedown: function (ev) {
				// only hide the popover if the click happened outside the popover
				if (this.el && !$(ev.target).closest(this.el).length) {
					this.hide();
				}
			},


			// Hides and unregisters any handlers
			removeElement: function () {
				this.hide();

				if (this.el) {
					this.el.remove();
					this.el = null;
				}

				$(document).off('mousedown', this.documentMousedownProxy);
			},


			// Positions the popover optimally, using the top/left/right options
			position: function () {
				var options = this.options;
				var origin = this.el.offsetParent().offset();
				var width = this.el.outerWidth();
				var height = this.el.outerHeight();
				var windowEl = $(window);
				var viewportEl = getScrollParent(this.el);
				var viewportTop;
				var viewportLeft;
				var viewportOffset;
				var top; // the "position" (not "offset") values for the popover
				var left; //

				// compute top and left
				top = options.top || 0;
				if (options.left !== undefined) {
					left = options.left;
				}
				else if (options.right !== undefined) {
					left = options.right - width; // derive the left value from the right value
				}
				else {
					left = 0;
				}

				if (viewportEl.is(window) || viewportEl.is(document)) { // normalize getScrollParent's result
					viewportEl = windowEl;
					viewportTop = 0; // the window is always at the top left
					viewportLeft = 0; // (and .offset() won't work if called here)
				}
				else {
					viewportOffset = viewportEl.offset();
					viewportTop = viewportOffset.top;
					viewportLeft = viewportOffset.left;
				}

				// if the window is scrolled, it causes the visible area to be further down
				viewportTop += windowEl.scrollTop();
				viewportLeft += windowEl.scrollLeft();

				// constrain to the view port. if constrained by two edges, give precedence to top/left
				if (options.viewportConstrain !== false) {
					top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);
					top = Math.max(top, viewportTop + this.margin);
					left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);
					left = Math.max(left, viewportLeft + this.margin);
				}

				this.el.css({
					top: top - origin.top,
					left: left - origin.left
				});
			},


			// Triggers a callback. Calls a function in the option hash of the same name.
			// Arguments beyond the first `name` are forwarded on.
			// TODO: better code reuse for this. Repeat code
			trigger: function (name) {
				if (this.options[name]) {
					this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
				}
			}

		});

		;
		;

		/*
		 A cache for the left/right/top/bottom/width/height values for one or more elements.
		 Works with both offset (from topleft document) and position (from offsetParent).

		 options:
		 - els
		 - isHorizontal
		 - isVertical
		 */
		var CoordCache = FC.CoordCache = Class.extend({

			els: null, // jQuery set (assumed to be siblings)
			forcedOffsetParentEl: null, // options can override the natural offsetParent
			origin: null, // {left,top} position of offsetParent of els
			boundingRect: null, // constrain cordinates to this rectangle. {left,right,top,bottom} or null
			isHorizontal: false, // whether to query for left/right/width
			isVertical: false, // whether to query for top/bottom/height

			// arrays of coordinates (offsets from topleft of document)
			lefts: null,
			rights: null,
			tops: null,
			bottoms: null,


			constructor: function (options) {
				this.els = $(options.els);
				this.isHorizontal = options.isHorizontal;
				this.isVertical = options.isVertical;
				this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;
			},


			// Queries the els for coordinates and stores them.
			// Call this method before using and of the get* methods below.
			build: function () {
				var offsetParentEl = this.forcedOffsetParentEl || this.els.eq(0).offsetParent();

				this.origin = offsetParentEl.offset();
				this.boundingRect = this.queryBoundingRect();

				if (this.isHorizontal) {
					this.buildElHorizontals();
				}
				if (this.isVertical) {
					this.buildElVerticals();
				}
			},


			// Destroys all internal data about coordinates, freeing memory
			clear: function () {
				this.origin = null;
				this.boundingRect = null;
				this.lefts = null;
				this.rights = null;
				this.tops = null;
				this.bottoms = null;
			},


			// Compute and return what the elements' bounding rectangle is, from the user's perspective.
			// Right now, only returns a rectangle if constrained by an overflow:scroll element.
			queryBoundingRect: function () {
				var scrollParentEl = getScrollParent(this.els.eq(0));

				if (!scrollParentEl.is(document)) {
					return getClientRect(scrollParentEl);
				}
			},


			// Populates the left/right internal coordinate arrays
			buildElHorizontals: function () {
				var lefts = [];
				var rights = [];

				this.els.each(function (i, node) {
					var el = $(node);
					var left = el.offset().left;
					var width = el.outerWidth();

					lefts.push(left);
					rights.push(left + width);
				});

				this.lefts = lefts;
				this.rights = rights;
			},


			// Populates the top/bottom internal coordinate arrays
			buildElVerticals: function () {
				var tops = [];
				var bottoms = [];

				this.els.each(function (i, node) {
					var el = $(node);
					var top = el.offset().top;
					var height = el.outerHeight();

					tops.push(top);
					bottoms.push(top + height);
				});

				this.tops = tops;
				this.bottoms = bottoms;
			},


			// Given a left offset (from document left), returns the index of the el that it horizontally intersects.
			// If no intersection is made, or outside of the boundingRect, returns undefined.
			getHorizontalIndex: function (leftOffset) {
				var boundingRect = this.boundingRect;
				var lefts = this.lefts;
				var rights = this.rights;
				var len = lefts.length;
				var i;

				if (!boundingRect || (leftOffset >= boundingRect.left && leftOffset < boundingRect.right)) {
					for (i = 0; i < len; i++) {
						if (leftOffset >= lefts[i] && leftOffset < rights[i]) {
							return i;
						}
					}
				}
			},


			// Given a top offset (from document top), returns the index of the el that it vertically intersects.
			// If no intersection is made, or outside of the boundingRect, returns undefined.
			getVerticalIndex: function (topOffset) {
				var boundingRect = this.boundingRect;
				var tops = this.tops;
				var bottoms = this.bottoms;
				var len = tops.length;
				var i;

				if (!boundingRect || (topOffset >= boundingRect.top && topOffset < boundingRect.bottom)) {
					for (i = 0; i < len; i++) {
						if (topOffset >= tops[i] && topOffset < bottoms[i]) {
							return i;
						}
					}
				}
			},


			// Gets the left offset (from document left) of the element at the given index
			getLeftOffset: function (leftIndex) {
				return this.lefts[leftIndex];
			},


			// Gets the left position (from offsetParent left) of the element at the given index
			getLeftPosition: function (leftIndex) {
				return this.lefts[leftIndex] - this.origin.left;
			},


			// Gets the right offset (from document left) of the element at the given index.
			// This value is NOT relative to the document's right edge, like the CSS concept of "right" would be.
			getRightOffset: function (leftIndex) {
				return this.rights[leftIndex];
			},


			// Gets the right position (from offsetParent left) of the element at the given index.
			// This value is NOT relative to the offsetParent's right edge, like the CSS concept of "right" would be.
			getRightPosition: function (leftIndex) {
				return this.rights[leftIndex] - this.origin.left;
			},


			// Gets the width of the element at the given index
			getWidth: function (leftIndex) {
				return this.rights[leftIndex] - this.lefts[leftIndex];
			},


			// Gets the top offset (from document top) of the element at the given index
			getTopOffset: function (topIndex) {
				return this.tops[topIndex];
			},


			// Gets the top position (from offsetParent top) of the element at the given position
			getTopPosition: function (topIndex) {
				return this.tops[topIndex] - this.origin.top;
			},

			// Gets the bottom offset (from the document top) of the element at the given index.
			// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
			getBottomOffset: function (topIndex) {
				return this.bottoms[topIndex];
			},


			// Gets the bottom position (from the offsetParent top) of the element at the given index.
			// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
			getBottomPosition: function (topIndex) {
				return this.bottoms[topIndex] - this.origin.top;
			},


			// Gets the height of the element at the given index
			getHeight: function (topIndex) {
				return this.bottoms[topIndex] - this.tops[topIndex];
			}

		});

		;
		;

		/* Tracks a drag's mouse movement, firing various handlers
		 ----------------------------------------------------------------------------------------------------------------------*/
// TODO: use Emitter

		var DragListener = FC.DragListener = Class.extend({

			options: null,

			isListening: false,
			isDragging: false,

			// coordinates of the initial mousedown
			originX: null,
			originY: null,

			// handler attached to the document, bound to the DragListener's `this`
			mousemoveProxy: null,
			mouseupProxy: null,

			// for IE8 bug-fighting behavior, for now
			subjectEl: null, // the element being draged. optional
			subjectHref: null,

			scrollEl: null,
			scrollBounds: null, // { top, bottom, left, right }
			scrollTopVel: null, // pixels per second
			scrollLeftVel: null, // pixels per second
			scrollIntervalId: null, // ID of setTimeout for scrolling animation loop
			scrollHandlerProxy: null, // this-scoped function for handling when scrollEl is scrolled

			scrollSensitivity: 30, // pixels from edge for scrolling to start
			scrollSpeed: 200, // pixels per second, at maximum speed
			scrollIntervalMs: 50, // millisecond wait between scroll increment


			constructor: function (options) {
				options = options || {};
				this.options = options;
				this.subjectEl = options.subjectEl;
			},


			// Call this when the user does a mousedown. Will probably lead to startListening
			mousedown: function (ev) {
				if (isPrimaryMouseButton(ev)) {

					ev.preventDefault(); // prevents native selection in most browsers

					this.startListening(ev);

					// start the drag immediately if there is no minimum distance for a drag start
					if (!this.options.distance) {
						this.startDrag(ev);
					}
				}
			},


			// Call this to start tracking mouse movements
			startListening: function (ev) {
				var scrollParent;

				if (!this.isListening) {

					// grab scroll container and attach handler
					if (ev && this.options.scroll) {
						scrollParent = getScrollParent($(ev.target));
						if (!scrollParent.is(window) && !scrollParent.is(document)) {
							this.scrollEl = scrollParent;

							// scope to `this`, and use `debounce` to make sure rapid calls don't happen
							this.scrollHandlerProxy = debounce(proxy(this, 'scrollHandler'), 100);
							this.scrollEl.on('scroll', this.scrollHandlerProxy);
						}
					}

					$(document)
						.on('mousemove', this.mousemoveProxy = proxy(this, 'mousemove'))
						.on('mouseup', this.mouseupProxy = proxy(this, 'mouseup'))
						.on('selectstart', this.preventDefault); // prevents native selection in IE<=8

					if (ev) {
						this.originX = ev.pageX;
						this.originY = ev.pageY;
					}
					else {
						// if no starting information was given, origin will be the topleft corner of the screen.
						// if so, dx/dy in the future will be the absolute coordinates.
						this.originX = 0;
						this.originY = 0;
					}

					this.isListening = true;
					this.listenStart(ev);
				}
			},


			// Called when drag listening has started (but a real drag has not necessarily began)
			listenStart: function (ev) {
				this.trigger('listenStart', ev);
			},


			// Called when the user moves the mouse
			mousemove: function (ev) {
				var dx = ev.pageX - this.originX;
				var dy = ev.pageY - this.originY;
				var minDistance;
				var distanceSq; // current distance from the origin, squared

				if (!this.isDragging) { // if not already dragging...
					// then start the drag if the minimum distance criteria is met
					minDistance = this.options.distance || 1;
					distanceSq = dx * dx + dy * dy;
					if (distanceSq >= minDistance * minDistance) { // use pythagorean theorem
						this.startDrag(ev);
					}
				}

				if (this.isDragging) {
					this.drag(dx, dy, ev); // report a drag, even if this mousemove initiated the drag
				}
			},


			// Call this to initiate a legitimate drag.
			// This function is called internally from this class, but can also be called explicitly from outside
			startDrag: function (ev) {

				if (!this.isListening) { // startDrag must have manually initiated
					this.startListening();
				}

				if (!this.isDragging) {
					this.isDragging = true;
					this.dragStart(ev);
				}
			},


			// Called when the actual drag has started (went beyond minDistance)
			dragStart: function (ev) {
				var subjectEl = this.subjectEl;

				this.trigger('dragStart', ev);

				// remove a mousedown'd <a>'s href so it is not visited (IE8 bug)
				if ((this.subjectHref = subjectEl ? subjectEl.attr('href') : null)) {
					subjectEl.removeAttr('href');
				}
			},


			// Called while the mouse is being moved and when we know a legitimate drag is taking place
			drag: function (dx, dy, ev) {
				this.trigger('drag', dx, dy, ev);
				this.updateScroll(ev); // will possibly cause scrolling
			},


			// Called when the user does a mouseup
			mouseup: function (ev) {
				this.stopListening(ev);
			},


			// Called when the drag is over. Will not cause listening to stop however.
			// A concluding 'cellOut' event will NOT be triggered.
			stopDrag: function (ev) {
				if (this.isDragging) {
					this.stopScrolling();
					this.dragStop(ev);
					this.isDragging = false;
				}
			},


			// Called when dragging has been stopped
			dragStop: function (ev) {
				var _this = this;

				this.trigger('dragStop', ev);

				// restore a mousedown'd <a>'s href (for IE8 bug)
				setTimeout(function () { // must be outside of the click's execution
					if (_this.subjectHref) {
						_this.subjectEl.attr('href', _this.subjectHref);
					}
				}, 0);
			},


			// Call this to stop listening to the user's mouse events
			stopListening: function (ev) {
				this.stopDrag(ev); // if there's a current drag, kill it

				if (this.isListening) {

					// remove the scroll handler if there is a scrollEl
					if (this.scrollEl) {
						this.scrollEl.off('scroll', this.scrollHandlerProxy);
						this.scrollHandlerProxy = null;
					}

					$(document)
						.off('mousemove', this.mousemoveProxy)
						.off('mouseup', this.mouseupProxy)
						.off('selectstart', this.preventDefault);

					this.mousemoveProxy = null;
					this.mouseupProxy = null;

					this.isListening = false;
					this.listenStop(ev);
				}
			},


			// Called when drag listening has stopped
			listenStop: function (ev) {
				this.trigger('listenStop', ev);
			},


			// Triggers a callback. Calls a function in the option hash of the same name.
			// Arguments beyond the first `name` are forwarded on.
			trigger: function (name) {
				if (this.options[name]) {
					this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
				}
			},


			// Stops a given mouse event from doing it's native browser action. In our case, text selection.
			preventDefault: function (ev) {
				ev.preventDefault();
			},


			/* Scrolling
			 ------------------------------------------------------------------------------------------------------------------*/


			// Computes and stores the bounding rectangle of scrollEl
			computeScrollBounds: function () {
				var el = this.scrollEl;

				this.scrollBounds = el ? getOuterRect(el) : null;
				// TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars
			},


			// Called when the dragging is in progress and scrolling should be updated
			updateScroll: function (ev) {
				var sensitivity = this.scrollSensitivity;
				var bounds = this.scrollBounds;
				var topCloseness, bottomCloseness;
				var leftCloseness, rightCloseness;
				var topVel = 0;
				var leftVel = 0;

				if (bounds) { // only scroll if scrollEl exists

					// compute closeness to edges. valid range is from 0.0 - 1.0
					topCloseness = (sensitivity - (ev.pageY - bounds.top)) / sensitivity;
					bottomCloseness = (sensitivity - (bounds.bottom - ev.pageY)) / sensitivity;
					leftCloseness = (sensitivity - (ev.pageX - bounds.left)) / sensitivity;
					rightCloseness = (sensitivity - (bounds.right - ev.pageX)) / sensitivity;

					// translate vertical closeness into velocity.
					// mouse must be completely in bounds for velocity to happen.
					if (topCloseness >= 0 && topCloseness <= 1) {
						topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up
					}
					else if (bottomCloseness >= 0 && bottomCloseness <= 1) {
						topVel = bottomCloseness * this.scrollSpeed;
					}

					// translate horizontal closeness into velocity
					if (leftCloseness >= 0 && leftCloseness <= 1) {
						leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left
					}
					else if (rightCloseness >= 0 && rightCloseness <= 1) {
						leftVel = rightCloseness * this.scrollSpeed;
					}
				}

				this.setScrollVel(topVel, leftVel);
			},


			// Sets the speed-of-scrolling for the scrollEl
			setScrollVel: function (topVel, leftVel) {

				this.scrollTopVel = topVel;
				this.scrollLeftVel = leftVel;

				this.constrainScrollVel(); // massages into realistic values

				// if there is non-zero velocity, and an animation loop hasn't already started, then START
				if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {
					this.scrollIntervalId = setInterval(
						proxy(this, 'scrollIntervalFunc'), // scope to `this`
						this.scrollIntervalMs
					);
				}
			},


			// Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way
			constrainScrollVel: function () {
				var el = this.scrollEl;

				if (this.scrollTopVel < 0) { // scrolling up?
					if (el.scrollTop() <= 0) { // already scrolled all the way up?
						this.scrollTopVel = 0;
					}
				}
				else if (this.scrollTopVel > 0) { // scrolling down?
					if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) { // already scrolled all the way down?
						this.scrollTopVel = 0;
					}
				}

				if (this.scrollLeftVel < 0) { // scrolling left?
					if (el.scrollLeft() <= 0) { // already scrolled all the left?
						this.scrollLeftVel = 0;
					}
				}
				else if (this.scrollLeftVel > 0) { // scrolling right?
					if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) { // already scrolled all the way right?
						this.scrollLeftVel = 0;
					}
				}
			},


			// This function gets called during every iteration of the scrolling animation loop
			scrollIntervalFunc: function () {
				var el = this.scrollEl;
				var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by

				// change the value of scrollEl's scroll
				if (this.scrollTopVel) {
					el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);
				}
				if (this.scrollLeftVel) {
					el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);
				}

				this.constrainScrollVel(); // since the scroll values changed, recompute the velocities

				// if scrolled all the way, which causes the vels to be zero, stop the animation loop
				if (!this.scrollTopVel && !this.scrollLeftVel) {
					this.stopScrolling();
				}
			},


			// Kills any existing scrolling animation loop
			stopScrolling: function () {
				if (this.scrollIntervalId) {
					clearInterval(this.scrollIntervalId);
					this.scrollIntervalId = null;

					// when all done with scrolling, recompute positions since they probably changed
					this.scrollStop();
				}
			},


			// Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)
			scrollHandler: function () {
				// recompute all coordinates, but *only* if this is *not* part of our scrolling animation
				if (!this.scrollIntervalId) {
					this.scrollStop();
				}
			},


			// Called when scrolling has stopped, whether through auto scroll, or the user scrolling
			scrollStop: function () {
			}

		});

		;
		;

		/* Tracks mouse movements over a component and raises events about which hit the mouse is over.
		 ------------------------------------------------------------------------------------------------------------------------
		 options:
		 - subjectEl
		 - subjectCenter
		 */

		var HitDragListener = DragListener.extend({

			component: null, // converts coordinates to hits
			// methods: prepareHits, releaseHits, queryHit

			origHit: null, // the hit the mouse was over when listening started
			hit: null, // the hit the mouse is over
			coordAdjust: null, // delta that will be added to the mouse coordinates when computing collisions


			constructor: function (component, options) {
				DragListener.call(this, options); // call the super-constructor

				this.component = component;
			},


			// Called when drag listening starts (but a real drag has not necessarily began).
			// ev might be undefined if dragging was started manually.
			listenStart: function (ev) {
				var subjectEl = this.subjectEl;
				var subjectRect;
				var origPoint;
				var point;

				DragListener.prototype.listenStart.apply(this, arguments); // call the super-method

				this.computeCoords();

				if (ev) {
					origPoint = {left: ev.pageX, top: ev.pageY};
					point = origPoint;

					// constrain the point to bounds of the element being dragged
					if (subjectEl) {
						subjectRect = getOuterRect(subjectEl); // used for centering as well
						point = constrainPoint(point, subjectRect);
					}

					this.origHit = this.queryHit(point.left, point.top);

					// treat the center of the subject as the collision point?
					if (subjectEl && this.options.subjectCenter) {

						// only consider the area the subject overlaps the hit. best for large subjects.
						// TODO: skip this if hit didn't supply left/right/top/bottom
						if (this.origHit) {
							subjectRect = intersectRects(this.origHit, subjectRect) ||
								subjectRect; // in case there is no intersection
						}

						point = getRectCenter(subjectRect);
					}

					this.coordAdjust = diffPoints(point, origPoint); // point - origPoint
				}
				else {
					this.origHit = null;
					this.coordAdjust = null;
				}
			},


			// Recomputes the drag-critical positions of elements
			computeCoords: function () {
				this.component.prepareHits();
				this.computeScrollBounds(); // why is this here???
			},


			// Called when the actual drag has started
			dragStart: function (ev) {
				var hit;

				DragListener.prototype.dragStart.apply(this, arguments); // call the super-method

				// might be different from this.origHit if the min-distance is large
				hit = this.queryHit(ev.pageX, ev.pageY);

				// report the initial hit the mouse is over
				// especially important if no min-distance and drag starts immediately
				if (hit) {
					this.hitOver(hit);
				}
			},


			// Called when the drag moves
			drag: function (dx, dy, ev) {
				var hit;

				DragListener.prototype.drag.apply(this, arguments); // call the super-method

				hit = this.queryHit(ev.pageX, ev.pageY);

				if (!isHitsEqual(hit, this.hit)) { // a different hit than before?
					if (this.hit) {
						this.hitOut();
					}
					if (hit) {
						this.hitOver(hit);
					}
				}
			},


			// Called when dragging has been stopped
			dragStop: function () {
				this.hitDone();
				DragListener.prototype.dragStop.apply(this, arguments); // call the super-method
			},


			// Called when a the mouse has just moved over a new hit
			hitOver: function (hit) {
				var isOrig = isHitsEqual(hit, this.origHit);

				this.hit = hit;

				this.trigger('hitOver', this.hit, isOrig, this.origHit);
			},


			// Called when the mouse has just moved out of a hit
			hitOut: function () {
				if (this.hit) {
					this.trigger('hitOut', this.hit);
					this.hitDone();
					this.hit = null;
				}
			},


			// Called after a hitOut. Also called before a dragStop
			hitDone: function () {
				if (this.hit) {
					this.trigger('hitDone', this.hit);
				}
			},


			// Called when drag listening has stopped
			listenStop: function () {
				DragListener.prototype.listenStop.apply(this, arguments); // call the super-method

				this.origHit = null;
				this.hit = null;

				this.component.releaseHits();
			},


			// Called when scrolling has stopped, whether through auto scroll, or the user scrolling
			scrollStop: function () {
				DragListener.prototype.scrollStop.apply(this, arguments); // call the super-method

				this.computeCoords(); // hits' absolute positions will be in new places. recompute
			},


			// Gets the hit underneath the coordinates for the given mouse event
			queryHit: function (left, top) {

				if (this.coordAdjust) {
					left += this.coordAdjust.left;
					top += this.coordAdjust.top;
				}

				return this.component.queryHit(left, top);
			}

		});


// Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.
// Two null values will be considered equal, as two "out of the component" states are the same.
		function isHitsEqual(hit0, hit1) {

			if (!hit0 && !hit1) {
				return true;
			}

			if (hit0 && hit1) {
				return hit0.component === hit1.component &&
					isHitPropsWithin(hit0, hit1) &&
					isHitPropsWithin(hit1, hit0); // ensures all props are identical
			}

			return false;
		}


// Returns true if all of subHit's non-standard properties are within superHit
		function isHitPropsWithin(subHit, superHit) {
			for (var propName in subHit) {
				if (!/^(component|left|right|top|bottom)$/.test(propName)) {
					if (subHit[propName] !== superHit[propName]) {
						return false;
					}
				}
			}
			return true;
		}

		;
		;

		/* Creates a clone of an element and lets it track the mouse as it moves
		 ----------------------------------------------------------------------------------------------------------------------*/

		var MouseFollower = Class.extend({

			options: null,

			sourceEl: null, // the element that will be cloned and made to look like it is dragging
			el: null, // the clone of `sourceEl` that will track the mouse
			parentEl: null, // the element that `el` (the clone) will be attached to

			// the initial position of el, relative to the offset parent. made to match the initial offset of sourceEl
			top0: null,
			left0: null,

			// the initial position of the mouse
			mouseY0: null,
			mouseX0: null,

			// the number of pixels the mouse has moved from its initial position
			topDelta: null,
			leftDelta: null,

			mousemoveProxy: null, // document mousemove handler, bound to the MouseFollower's `this`

			isFollowing: false,
			isHidden: false,
			isAnimating: false, // doing the revert animation?

			constructor: function (sourceEl, options) {
				this.options = options = options || {};
				this.sourceEl = sourceEl;
				this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent
			},


			// Causes the element to start following the mouse
			start: function (ev) {
				if (!this.isFollowing) {
					this.isFollowing = true;

					this.mouseY0 = ev.pageY;
					this.mouseX0 = ev.pageX;
					this.topDelta = 0;
					this.leftDelta = 0;

					if (!this.isHidden) {
						this.updatePosition();
					}

					$(document).on('mousemove', this.mousemoveProxy = proxy(this, 'mousemove'));
				}
			},


			// Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.
			// `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.
			stop: function (shouldRevert, callback) {
				var _this = this;
				var revertDuration = this.options.revertDuration;

				function complete() {
					this.isAnimating = false;
					_this.removeElement();

					this.top0 = this.left0 = null; // reset state for future updatePosition calls

					if (callback) {
						callback();
					}
				}

				if (this.isFollowing && !this.isAnimating) { // disallow more than one stop animation at a time
					this.isFollowing = false;

					$(document).off('mousemove', this.mousemoveProxy);

					if (shouldRevert && revertDuration && !this.isHidden) { // do a revert animation?
						this.isAnimating = true;
						this.el.animate({
							top: this.top0,
							left: this.left0
						}, {
							duration: revertDuration,
							complete: complete
						});
					}
					else {
						complete();
					}
				}
			},


			// Gets the tracking element. Create it if necessary
			getEl: function () {
				var el = this.el;

				if (!el) {
					this.sourceEl.width(); // hack to force IE8 to compute correct bounding box
					el = this.el = this.sourceEl.clone()
						.css({
							position: 'absolute',
							visibility: '', // in case original element was hidden (commonly through hideEvents())
							display: this.isHidden ? 'none' : '', // for when initially hidden
							margin: 0,
							right: 'auto', // erase and set width instead
							bottom: 'auto', // erase and set height instead
							width: this.sourceEl.width(), // explicit height in case there was a 'right' value
							height: this.sourceEl.height(), // explicit width in case there was a 'bottom' value
							opacity: this.options.opacity || '',
							zIndex: this.options.zIndex
						})
						.appendTo(this.parentEl);
				}

				return el;
			},


			// Removes the tracking element if it has already been created
			removeElement: function () {
				if (this.el) {
					this.el.remove();
					this.el = null;
				}
			},


			// Update the CSS position of the tracking element
			updatePosition: function () {
				var sourceOffset;
				var origin;

				this.getEl(); // ensure this.el

				// make sure origin info was computed
				if (this.top0 === null) {
					this.sourceEl.width(); // hack to force IE8 to compute correct bounding box
					sourceOffset = this.sourceEl.offset();
					origin = this.el.offsetParent().offset();
					this.top0 = sourceOffset.top - origin.top;
					this.left0 = sourceOffset.left - origin.left;
				}

				this.el.css({
					top: this.top0 + this.topDelta,
					left: this.left0 + this.leftDelta
				});
			},


			// Gets called when the user moves the mouse
			mousemove: function (ev) {
				this.topDelta = ev.pageY - this.mouseY0;
				this.leftDelta = ev.pageX - this.mouseX0;

				if (!this.isHidden) {
					this.updatePosition();
				}
			},


			// Temporarily makes the tracking element invisible. Can be called before following starts
			hide: function () {
				if (!this.isHidden) {
					this.isHidden = true;
					if (this.el) {
						this.el.hide();
					}
				}
			},


			// Show the tracking element after it has been temporarily hidden
			show: function () {
				if (this.isHidden) {
					this.isHidden = false;
					this.updatePosition();
					this.getEl().show();
				}
			}

		});

		;
		;

		/* An abstract class comprised of a "grid" of areas that each represent a specific datetime
		 ----------------------------------------------------------------------------------------------------------------------*/

		var Grid = FC.Grid = Class.extend({

			view: null, // a View object
			isRTL: null, // shortcut to the view's isRTL option

			start: null,
			end: null,

			el: null, // the containing element
			elsByFill: null, // a hash of jQuery element sets used for rendering each fill. Keyed by fill name.

			externalDragStartProxy: null, // binds the Grid's scope to externalDragStart (in DayGrid.events)

			// derived from options
			eventTimeFormat: null,
			displayEventTime: null,
			displayEventEnd: null,

			minResizeDuration: null, // TODO: hack. set by subclasses. minumum event resize duration

			// if defined, holds the unit identified (ex: "year" or "month") that determines the level of granularity
			// of the date areas. if not defined, assumes to be day and time granularity.
			// TODO: port isTimeScale into same system?
			largeUnit: null,


			constructor: function (view) {
				this.view = view;
				this.isRTL = view.opt('isRTL');

				this.elsByFill = {};
				this.externalDragStartProxy = proxy(this, 'externalDragStart');
			},


			/* Options
			 ------------------------------------------------------------------------------------------------------------------*/


			// Generates the format string used for event time text, if not explicitly defined by 'timeFormat'
			computeEventTimeFormat: function () {
				return this.view.opt('smallTimeFormat');
			},


			// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventTime'.
			// Only applies to non-all-day events.
			computeDisplayEventTime: function () {
				return true;
			},


			// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventEnd'
			computeDisplayEventEnd: function () {
				return true;
			},


			/* Dates
			 ------------------------------------------------------------------------------------------------------------------*/


			// Tells the grid about what period of time to display.
			// Any date-related internal data should be generated.
			setRange: function (range) {
				this.start = range.start.clone();
				this.end = range.end.clone();

				this.rangeUpdated();
				this.processRangeOptions();
			},


			// Called when internal variables that rely on the range should be updated
			rangeUpdated: function () {
			},


			// Updates values that rely on options and also relate to range
			processRangeOptions: function () {
				var view = this.view;
				var displayEventTime;
				var displayEventEnd;

				this.eventTimeFormat =
					view.opt('eventTimeFormat') ||
					view.opt('timeFormat') || // deprecated
					this.computeEventTimeFormat();

				displayEventTime = view.opt('displayEventTime');
				if (displayEventTime == null) {
					displayEventTime = this.computeDisplayEventTime(); // might be based off of range
				}

				displayEventEnd = view.opt('displayEventEnd');
				if (displayEventEnd == null) {
					displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range
				}

				this.displayEventTime = displayEventTime;
				this.displayEventEnd = displayEventEnd;
			},


			// Converts a span (has unzoned start/end and any other grid-specific location information)
			// into an array of segments (pieces of events whose format is decided by the grid).
			spanToSegs: function (span) {
				// subclasses must implement
			},


			// Diffs the two dates, returning a duration, based on granularity of the grid
			// TODO: port isTimeScale into this system?
			diffDates: function (a, b) {
				if (this.largeUnit) {
					return diffByUnit(a, b, this.largeUnit);
				}
				else {
					return diffDayTime(a, b);
				}
			},


			/* Hit Area
			 ------------------------------------------------------------------------------------------------------------------*/


			// Called before one or more queryHit calls might happen. Should prepare any cached coordinates for queryHit
			prepareHits: function () {
			},


			// Called when queryHit calls have subsided. Good place to clear any coordinate caches.
			releaseHits: function () {
			},


			// Given coordinates from the topleft of the document, return data about the date-related area underneath.
			// Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).
			// Must have a `grid` property, a reference to this current grid. TODO: avoid this
			// The returned object will be processed by getHitSpan and getHitEl.
			queryHit: function (leftOffset, topOffset) {
			},


			// Given position-level information about a date-related area within the grid,
			// should return an object with at least a start/end date. Can provide other information as well.
			getHitSpan: function (hit) {
			},


			// Given position-level information about a date-related area within the grid,
			// should return a jQuery element that best represents it. passed to dayClick callback.
			getHitEl: function (hit) {
			},


			/* Rendering
			 ------------------------------------------------------------------------------------------------------------------*/


			// Sets the container element that the grid should render inside of.
			// Does other DOM-related initializations.
			setElement: function (el) {
				var _this = this;

				this.el = el;

				// attach a handler to the grid's root element.
				// jQuery will take care of unregistering them when removeElement gets called.
				el.on('mousedown', function (ev) {
					if (
						!$(ev.target).is('.fc-event-container *, .fc-more') && // not an an event element, or "more.." link
						!$(ev.target).closest('.fc-popover').length // not on a popover (like the "more.." events one)
					) {
						_this.dayMousedown(ev);
					}
				});

				// attach event-element-related handlers. in Grid.events
				// same garbage collection note as above.
				this.bindSegHandlers();

				this.bindGlobalHandlers();
			},


			// Removes the grid's container element from the DOM. Undoes any other DOM-related attachments.
			// DOES NOT remove any content beforehand (doesn't clear events or call unrenderDates), unlike View
			removeElement: function () {
				this.unbindGlobalHandlers();

				this.el.remove();

				// NOTE: we don't null-out this.el for the same reasons we don't do it within View::removeElement
			},


			// Renders the basic structure of grid view before any content is rendered
			renderSkeleton: function () {
				// subclasses should implement
			},


			// Renders the grid's date-related content (like areas that represent days/times).
			// Assumes setRange has already been called and the skeleton has already been rendered.
			renderDates: function () {
				// subclasses should implement
			},


			// Unrenders the grid's date-related content
			unrenderDates: function () {
				// subclasses should implement
			},


			/* Handlers
			 ------------------------------------------------------------------------------------------------------------------*/


			// Binds DOM handlers to elements that reside outside the grid, such as the document
			bindGlobalHandlers: function () {
				$(document).on('dragstart sortstart', this.externalDragStartProxy); // jqui
			},


			// Unbinds DOM handlers from elements that reside outside the grid
			unbindGlobalHandlers: function () {
				$(document).off('dragstart sortstart', this.externalDragStartProxy); // jqui
			},


			// Process a mousedown on an element that represents a day. For day clicking and selecting.
			dayMousedown: function (ev) {
				var _this = this;
				var view = this.view;
				var isSelectable = view.opt('selectable');
				var dayClickHit; // null if invalid dayClick
				var selectionSpan; // null if invalid selection

				// this listener tracks a mousedown on a day element, and a subsequent drag.
				// if the drag ends on the same day, it is a 'dayClick'.
				// if 'selectable' is enabled, this listener also detects selections.
				var dragListener = new HitDragListener(this, {
					//distance: 5, // needs more work if we want dayClick to fire correctly
					scroll: view.opt('dragScroll'),
					dragStart: function () {
						view.unselect(); // since we could be rendering a new selection, we want to clear any old one
					},
					hitOver: function (hit, isOrig, origHit) {
						if (origHit) { // click needs to have started on a hit
							dayClickHit = isOrig ? hit : null; // single-hit selection is a day click
							if (isSelectable) {
								selectionSpan = _this.computeSelection(
									_this.getHitSpan(origHit),
									_this.getHitSpan(hit)
								);
								if (selectionSpan) {
									_this.renderSelection(selectionSpan);
								}
								else if (selectionSpan === false) {
									disableCursor();
								}
							}
						}
					},
					hitOut: function () {
						dayClickHit = null;
						selectionSpan = null;
						_this.unrenderSelection();
						enableCursor();
					},
					listenStop: function (ev) {
						if (dayClickHit) {
							view.triggerDayClick(
								_this.getHitSpan(dayClickHit),
								_this.getHitEl(dayClickHit),
								ev
							);
						}
						if (selectionSpan) {
							// the selection will already have been rendered. just report it
							view.reportSelection(selectionSpan, ev);
						}
						enableCursor();
					}
				});

				dragListener.mousedown(ev); // start listening, which will eventually initiate a dragStart
			},


			/* Event Helper
			 ------------------------------------------------------------------------------------------------------------------*/
			// TODO: should probably move this to Grid.events, like we did event dragging / resizing


			// Renders a mock event at the given event location, which contains zoned start/end properties.
			renderEventLocationHelper: function (eventLocation, sourceSeg) {
				var fakeEvent = this.fabricateHelperEvent(eventLocation, sourceSeg);

				this.renderHelper(fakeEvent, sourceSeg); // do the actual rendering
			},


			// Builds a fake event given zoned event date properties and a segment is should be inspired from.
			// The range's end can be null, in which case the mock event that is rendered will have a null end time.
			// `sourceSeg` is the internal segment object involved in the drag. If null, something external is dragging.
			fabricateHelperEvent: function (eventLocation, sourceSeg) {
				var fakeEvent = sourceSeg ? createObject(sourceSeg.event) : {}; // mask the original event object if possible

				fakeEvent.start = eventLocation.start.clone();
				fakeEvent.end = eventLocation.end ? eventLocation.end.clone() : null;
				fakeEvent.allDay = null; // force it to be freshly computed by normalizeEventDates
				this.view.calendar.normalizeEventDates(fakeEvent);

				// this extra className will be useful for differentiating real events from mock events in CSS
				fakeEvent.className = (fakeEvent.className || []).concat('fc-helper');

				// if something external is being dragged in, don't render a resizer
				if (!sourceSeg) {
					fakeEvent.editable = false;
				}

				return fakeEvent;
			},


			// Renders a mock event. Given zoned event date properties.
			renderHelper: function (eventLocation, sourceSeg) {
				// subclasses must implement
			},


			// Unrenders a mock event
			unrenderHelper: function () {
				// subclasses must implement
			},


			/* Selection
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders a visual indication of a selection. Will highlight by default but can be overridden by subclasses.
			// Given a span (unzoned start/end and other misc data)
			renderSelection: function (span) {
				this.renderHighlight(span);
			},


			// Unrenders any visual indications of a selection. Will unrender a highlight by default.
			unrenderSelection: function () {
				this.unrenderHighlight();
			},


			// Given the first and last date-spans of a selection, returns another date-span object.
			// Subclasses can override and provide additional data in the span object. Will be passed to renderSelection().
			// Will return false if the selection is invalid and this should be indicated to the user.
			// Will return null/undefined if a selection invalid but no error should be reported.
			computeSelection: function (span0, span1) {
				var span = this.computeSelectionSpan(span0, span1);

				if (span && !this.view.calendar.isSelectionSpanAllowed(span)) {
					return false;
				}

				return span;
			},


			// Given two spans, must return the combination of the two.
			// TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.
			computeSelectionSpan: function (span0, span1) {
				var dates = [span0.start, span0.end, span1.start, span1.end];

				dates.sort(compareNumbers); // sorts chronologically. works with Moments

				return {start: dates[0].clone(), end: dates[3].clone()};
			},


			/* Highlight
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)
			renderHighlight: function (span) {
				this.renderFill('highlight', this.spanToSegs(span));
			},


			// Unrenders the emphasis on a date range
			unrenderHighlight: function () {
				this.unrenderFill('highlight');
			},


			// Generates an array of classNames for rendering the highlight. Used by the fill system.
			highlightSegClasses: function () {
				return ['fc-highlight'];
			},


			/* Fill System (highlight, background events, business hours)
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders a set of rectangles over the given segments of time.
			// MUST RETURN a subset of segs, the segs that were actually rendered.
			// Responsible for populating this.elsByFill. TODO: better API for expressing this requirement
			renderFill: function (type, segs) {
				// subclasses must implement
			},


			// Unrenders a specific type of fill that is currently rendered on the grid
			unrenderFill: function (type) {
				var el = this.elsByFill[type];

				if (el) {
					el.remove();
					delete this.elsByFill[type];
				}
			},


			// Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
			// Only returns segments that successfully rendered.
			// To be harnessed by renderFill (implemented by subclasses).
			// Analagous to renderFgSegEls.
			renderFillSegEls: function (type, segs) {
				var _this = this;
				var segElMethod = this[type + 'SegEl'];
				var html = '';
				var renderedSegs = [];
				var i;

				if (segs.length) {

					// build a large concatenation of segment HTML
					for (i = 0; i < segs.length; i++) {
						html += this.fillSegHtml(type, segs[i]);
					}

					// Grab individual elements from the combined HTML string. Use each as the default rendering.
					// Then, compute the 'el' for each segment.
					$(html).each(function (i, node) {
						var seg = segs[i];
						var el = $(node);

						// allow custom filter methods per-type
						if (segElMethod) {
							el = segElMethod.call(_this, seg, el);
						}

						if (el) { // custom filters did not cancel the render
							el = $(el); // allow custom filter to return raw DOM node

							// correct element type? (would be bad if a non-TD were inserted into a table for example)
							if (el.is(_this.fillSegTag)) {
								seg.el = el;
								renderedSegs.push(seg);
							}
						}
					});
				}

				return renderedSegs;
			},


			fillSegTag: 'div', // subclasses can override


			// Builds the HTML needed for one fill segment. Generic enought o work with different types.
			fillSegHtml: function (type, seg) {

				// custom hooks per-type
				var classesMethod = this[type + 'SegClasses'];
				var cssMethod = this[type + 'SegCss'];

				var classes = classesMethod ? classesMethod.call(this, seg) : [];
				var css = cssToStr(cssMethod ? cssMethod.call(this, seg) : {});

				return '<' + this.fillSegTag +
					(classes.length ? ' class="' + classes.join(' ') + '"' : '') +
					(css ? ' style="' + css + '"' : '') +
					' />';
			},


			/* Generic rendering utilities for subclasses
			 ------------------------------------------------------------------------------------------------------------------*/


			// Computes HTML classNames for a single-day element
			getDayClasses: function (date) {
				var view = this.view;
				var today = view.calendar.getNow().stripTime();
				var classes = ['fc-' + dayIDs[date.day()]];

				if (
					view.intervalDuration.as('months') == 1 &&
					date.month() != view.intervalStart.month()
				) {
					classes.push('fc-other-month');
				}

				if (date.isSame(today, 'day')) {
					classes.push(
						'fc-today',
						view.highlightStateClass
					);
				}
				else if (date < today) {
					classes.push('fc-past');
				}
				else {
					classes.push('fc-future');
				}

				return classes;
			}

		});

		;
		;

		/* Event-rendering and event-interaction methods for the abstract Grid class
		 ----------------------------------------------------------------------------------------------------------------------*/

		Grid.mixin({

			mousedOverSeg: null, // the segment object the user's mouse is over. null if over nothing
			isDraggingSeg: false, // is a segment being dragged? boolean
			isResizingSeg: false, // is a segment being resized? boolean
			isDraggingExternal: false, // jqui-dragging an external element? boolean
			segs: null, // the event segments currently rendered in the grid


			// Renders the given events onto the grid
			renderEvents: function (events) {
				var bgEvents = [];
				var fgEvents = [];
				var i;

				for (i = 0; i < events.length; i++) {
					(isBgEvent(events[i]) ? bgEvents : fgEvents).push(events[i]);
				}

				this.segs = [].concat( // record all segs
					this.renderBgEvents(bgEvents),
					this.renderFgEvents(fgEvents)
				);
			},


			renderBgEvents: function (events) {
				var segs = this.eventsToSegs(events);

				// renderBgSegs might return a subset of segs, segs that were actually rendered
				return this.renderBgSegs(segs) || segs;
			},


			renderFgEvents: function (events) {
				var segs = this.eventsToSegs(events);

				// renderFgSegs might return a subset of segs, segs that were actually rendered
				return this.renderFgSegs(segs) || segs;
			},


			// Unrenders all events currently rendered on the grid
			unrenderEvents: function () {
				this.triggerSegMouseout(); // trigger an eventMouseout if user's mouse is over an event

				this.unrenderFgSegs();
				this.unrenderBgSegs();

				this.segs = null;
			},


			// Retrieves all rendered segment objects currently rendered on the grid
			getEventSegs: function () {
				return this.segs || [];
			},


			/* Foreground Segment Rendering
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders foreground event segments onto the grid. May return a subset of segs that were rendered.
			renderFgSegs: function (segs) {
				// subclasses must implement
			},


			// Unrenders all currently rendered foreground segments
			unrenderFgSegs: function () {
				// subclasses must implement
			},


			// Renders and assigns an `el` property for each foreground event segment.
			// Only returns segments that successfully rendered.
			// A utility that subclasses may use.
			renderFgSegEls: function (segs, disableResizing) {
				var view = this.view;
				var html = '';
				var renderedSegs = [];
				var i;

				if (segs.length) { // don't build an empty html string

					// build a large concatenation of event segment HTML
					for (i = 0; i < segs.length; i++) {
						html += this.fgSegHtml(segs[i], disableResizing);
					}

					// Grab individual elements from the combined HTML string. Use each as the default rendering.
					// Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.
					$(html).each(function (i, node) {
						var seg = segs[i];
						var el = view.resolveEventEl(seg.event, $(node));

						if (el) {
							el.data('fc-seg', seg); // used by handlers
							seg.el = el;
							renderedSegs.push(seg);
						}
					});
				}

				return renderedSegs;
			},


			// Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()
			fgSegHtml: function (seg, disableResizing) {
				// subclasses should implement
			},


			/* Background Segment Rendering
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders the given background event segments onto the grid.
			// Returns a subset of the segs that were actually rendered.
			renderBgSegs: function (segs) {
				return this.renderFill('bgEvent', segs);
			},


			// Unrenders all the currently rendered background event segments
			unrenderBgSegs: function () {
				this.unrenderFill('bgEvent');
			},


			// Renders a background event element, given the default rendering. Called by the fill system.
			bgEventSegEl: function (seg, el) {
				return this.view.resolveEventEl(seg.event, el); // will filter through eventRender
			},


			// Generates an array of classNames to be used for the default rendering of a background event.
			// Called by the fill system.
			bgEventSegClasses: function (seg) {
				var event = seg.event;
				var source = event.source || {};

				return ['fc-bgevent'].concat(
					event.className,
					source.className || []
				);
			},


			// Generates a semicolon-separated CSS string to be used for the default rendering of a background event.
			// Called by the fill system.
			// TODO: consolidate with getEventSkinCss?
			bgEventSegCss: function (seg) {
				var view = this.view;
				var event = seg.event;
				var source = event.source || {};

				return {
					'background-color': event.backgroundColor ||
					event.color ||
					source.backgroundColor ||
					source.color ||
					view.opt('eventBackgroundColor') ||
					view.opt('eventColor')
				};
			},


			// Generates an array of classNames to be used for the rendering business hours overlay. Called by the fill system.
			businessHoursSegClasses: function (seg) {
				return ['fc-nonbusiness', 'fc-bgevent'];
			},


			/* Handlers
			 ------------------------------------------------------------------------------------------------------------------*/


			// Attaches event-element-related handlers to the container element and leverage bubbling
			bindSegHandlers: function () {
				var _this = this;
				var view = this.view;

				$.each(
					{
						mouseenter: function (seg, ev) {
							_this.triggerSegMouseover(seg, ev);
						},
						mouseleave: function (seg, ev) {
							_this.triggerSegMouseout(seg, ev);
						},
						click: function (seg, ev) {
							return view.trigger('eventClick', this, seg, ev); // can return `false` to cancel
						},
						mousedown: function (seg, ev) {
							if ($(ev.target).is('.fc-resizer') && view.isEventResizable(seg.event)) {
								_this.segResizeMousedown(seg, ev, $(ev.target).is('.fc-start-resizer'));
							}
							else if (view.isEventDraggable(seg.event)) {
								_this.segDragMousedown(seg, ev);
							}
						}
					},
					function (name, func) {
						// attach the handler to the container element and only listen for real event elements via bubbling
						_this.el.on(name, '.fc-event-container > *', function (ev) {
							var seg = $(this).data('fc-seg'); // grab segment data. put there by View::renderEvents

							// only call the handlers if there is not a drag/resize in progress
							if (seg && !_this.isDraggingSeg && !_this.isResizingSeg) {
								return func.call(this, seg, ev); // `this` will be the event element
							}
						});
					}
				);
			},


			// Updates internal state and triggers handlers for when an event element is moused over
			triggerSegMouseover: function (seg, ev) {
				if (!this.mousedOverSeg) {
					this.mousedOverSeg = seg;
					this.view.trigger('eventMouseover', seg.el[0], seg.event, ev);
				}
			},


			// Updates internal state and triggers handlers for when an event element is moused out.
			// Can be given no arguments, in which case it will mouseout the segment that was previously moused over.
			triggerSegMouseout: function (seg, ev) {
				ev = ev || {}; // if given no args, make a mock mouse event

				if (this.mousedOverSeg) {
					seg = seg || this.mousedOverSeg; // if given no args, use the currently moused-over segment
					this.mousedOverSeg = null;
					this.view.trigger('eventMouseout', seg.el[0], seg.event, ev);
				}
			},


			/* Event Dragging
			 ------------------------------------------------------------------------------------------------------------------*/


			// Called when the user does a mousedown on an event, which might lead to dragging.
			// Generic enough to work with any type of Grid.
			segDragMousedown: function (seg, ev) {
				var _this = this;
				var view = this.view;
				var calendar = view.calendar;
				var el = seg.el;
				var event = seg.event;
				var dropLocation; // zoned event date properties

				// A clone of the original element that will move with the mouse
				var mouseFollower = new MouseFollower(seg.el, {
					parentEl: view.el,
					opacity: view.opt('dragOpacity'),
					revertDuration: view.opt('dragRevertDuration'),
					zIndex: 2 // one above the .fc-view
				});

				// Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents
				// of the view.
				var dragListener = new HitDragListener(view, {
					distance: 5,
					scroll: view.opt('dragScroll'),
					subjectEl: el,
					subjectCenter: true,
					listenStart: function (ev) {
						mouseFollower.hide(); // don't show until we know this is a real drag
						mouseFollower.start(ev);
					},
					dragStart: function (ev) {
						_this.triggerSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported
						_this.segDragStart(seg, ev);
						view.hideEvent(event); // hide all event segments. our mouseFollower will take over
					},
					hitOver: function (hit, isOrig, origHit) {

						// starting hit could be forced (DayGrid.limit)
						if (seg.hit) {
							origHit = seg.hit;
						}

						// since we are querying the parent view, might not belong to this grid
						dropLocation = _this.computeEventDrop(
							origHit.component.getHitSpan(origHit),
							hit.component.getHitSpan(hit),
							event
						);

						if (dropLocation && !calendar.isEventSpanAllowed(_this.eventToSpan(dropLocation), event)) {
							disableCursor();
							dropLocation = null;
						}

						// if a valid drop location, have the subclass render a visual indication
						if (dropLocation && view.renderDrag(dropLocation, seg)) {
							mouseFollower.hide(); // if the subclass is already using a mock event "helper", hide our own
						}
						else {
							mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)
						}

						if (isOrig) {
							dropLocation = null; // needs to have moved hits to be a valid drop
						}
					},
					hitOut: function () { // called before mouse moves to a different hit OR moved out of all hits
						view.unrenderDrag(); // unrender whatever was done in renderDrag
						mouseFollower.show(); // show in case we are moving out of all hits
						dropLocation = null;
					},
					hitDone: function () { // Called after a hitOut OR before a dragStop
						enableCursor();
					},
					dragStop: function (ev) {
						// do revert animation if hasn't changed. calls a callback when finished (whether animation or not)
						mouseFollower.stop(!dropLocation, function () {
							view.unrenderDrag();
							view.showEvent(event);
							_this.segDragStop(seg, ev);

							if (dropLocation) {
								view.reportEventDrop(event, dropLocation, this.largeUnit, el, ev);
							}
						});
					},
					listenStop: function () {
						mouseFollower.stop(); // put in listenStop in case there was a mousedown but the drag never started
					}
				});

				dragListener.mousedown(ev); // start listening, which will eventually lead to a dragStart
			},


			// Called before event segment dragging starts
			segDragStart: function (seg, ev) {
				this.isDraggingSeg = true;
				this.view.trigger('eventDragStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
			},


			// Called after event segment dragging stops
			segDragStop: function (seg, ev) {
				this.isDraggingSeg = false;
				this.view.trigger('eventDragStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
			},


			// Given the spans an event drag began, and the span event was dropped, calculates the new zoned start/end/allDay
			// values for the event. Subclasses may override and set additional properties to be used by renderDrag.
			// A falsy returned value indicates an invalid drop.
			computeEventDrop: function (startSpan, endSpan, event) {
				var calendar = this.view.calendar;
				var dragStart = startSpan.start;
				var dragEnd = endSpan.start;
				var delta;
				var dropLocation; // zoned event date properties

				if (dragStart.hasTime() === dragEnd.hasTime()) {
					delta = this.diffDates(dragEnd, dragStart);

					// if an all-day event was in a timed area and it was dragged to a different time,
					// guarantee an end and adjust start/end to have times
					if (event.allDay && durationHasTime(delta)) {
						dropLocation = {
							start: event.start.clone(),
							end: calendar.getEventEnd(event), // will be an ambig day
							allDay: false // for normalizeEventTimes
						};
						calendar.normalizeEventTimes(dropLocation);
					}
					// othewise, work off existing values
					else {
						dropLocation = {
							start: event.start.clone(),
							end: event.end ? event.end.clone() : null,
							allDay: event.allDay // keep it the same
						};
					}

					dropLocation.start.add(delta);
					if (dropLocation.end) {
						dropLocation.end.add(delta);
					}
				}
				else {
					// if switching from day <-> timed, start should be reset to the dropped date, and the end cleared
					dropLocation = {
						start: dragEnd.clone(),
						end: null, // end should be cleared
						allDay: !dragEnd.hasTime()
					};
				}

				return dropLocation;
			},


			// Utility for apply dragOpacity to a jQuery set
			applyDragOpacity: function (els) {
				var opacity = this.view.opt('dragOpacity');

				if (opacity != null) {
					els.each(function (i, node) {
						// Don't use jQuery (will set an IE filter), do it the old fashioned way.
						// In IE8, a helper element will disappears if there's a filter.
						node.style.opacity = opacity;
					});
				}
			},


			/* External Element Dragging
			 ------------------------------------------------------------------------------------------------------------------*/


			// Called when a jQuery UI drag is initiated anywhere in the DOM
			externalDragStart: function (ev, ui) {
				var view = this.view;
				var el;
				var accept;

				if (view.opt('droppable')) { // only listen if this setting is on
					el = $((ui ? ui.item : null) || ev.target);

					// Test that the dragged element passes the dropAccept selector or filter function.
					// FYI, the default is "*" (matches all)
					accept = view.opt('dropAccept');
					if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {
						if (!this.isDraggingExternal) { // prevent double-listening if fired twice
							this.listenToExternalDrag(el, ev, ui);
						}
					}
				}
			},


			// Called when a jQuery UI drag starts and it needs to be monitored for dropping
			listenToExternalDrag: function (el, ev, ui) {
				var _this = this;
				var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create
				var dropLocation; // a null value signals an unsuccessful drag

				// listener that tracks mouse movement over date-associated pixel regions
				var dragListener = new HitDragListener(this, {
					listenStart: function () {
						_this.isDraggingExternal = true;
					},
					hitOver: function (hit) {
						dropLocation = _this.computeExternalDrop(
							hit.component.getHitSpan(hit), // since we are querying the parent view, might not belong to this grid
							meta
						);
						if (dropLocation) {
							_this.renderDrag(dropLocation); // called without a seg parameter
						}
						else { // invalid hit
							disableCursor();
						}
					},
					hitOut: function () {
						dropLocation = null; // signal unsuccessful
						_this.unrenderDrag();
						enableCursor();
					},
					dragStop: function () {
						_this.unrenderDrag();
						enableCursor();

						if (dropLocation) { // element was dropped on a valid hit
							_this.view.reportExternalDrop(meta, dropLocation, el, ev, ui);
						}
					},
					listenStop: function () {
						_this.isDraggingExternal = false;
					}
				});

				dragListener.startDrag(ev); // start listening immediately
			},


			// Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),
			// returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.
			// Returning a null value signals an invalid drop hit.
			computeExternalDrop: function (span, meta) {
				var calendar = this.view.calendar;
				var dropLocation = {
					start: calendar.applyTimezone(span.start), // simulate a zoned event start date
					end: null
				};

				// if dropped on an all-day span, and element's metadata specified a time, set it
				if (meta.startTime && !dropLocation.start.hasTime()) {
					dropLocation.start.time(meta.startTime);
				}

				if (meta.duration) {
					dropLocation.end = dropLocation.start.clone().add(meta.duration);
				}

				if (!calendar.isExternalSpanAllowed(this.eventToSpan(dropLocation), dropLocation, meta.eventProps)) {
					return null;
				}

				return dropLocation;
			},


			/* Drag Rendering (for both events and an external elements)
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders a visual indication of an event or external element being dragged.
			// `dropLocation` contains hypothetical start/end/allDay values the event would have if dropped. end can be null.
			// `seg` is the internal segment object that is being dragged. If dragging an external element, `seg` is null.
			// A truthy returned value indicates this method has rendered a helper element.
			renderDrag: function (dropLocation, seg) {
				// subclasses must implement
			},


			// Unrenders a visual indication of an event or external element being dragged
			unrenderDrag: function () {
				// subclasses must implement
			},


			/* Resizing
			 ------------------------------------------------------------------------------------------------------------------*/


			// Called when the user does a mousedown on an event's resizer, which might lead to resizing.
			// Generic enough to work with any type of Grid.
			segResizeMousedown: function (seg, ev, isStart) {
				var _this = this;
				var view = this.view;
				var calendar = view.calendar;
				var el = seg.el;
				var event = seg.event;
				var eventEnd = calendar.getEventEnd(event);
				var resizeLocation; // zoned event date properties. falsy if invalid resize

				// Tracks mouse movement over the *grid's* coordinate map
				var dragListener = new HitDragListener(this, {
					distance: 5,
					scroll: view.opt('dragScroll'),
					subjectEl: el,
					dragStart: function (ev) {
						_this.triggerSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported
						_this.segResizeStart(seg, ev);
					},
					hitOver: function (hit, isOrig, origHit) {
						var origHitSpan = _this.getHitSpan(origHit);
						var hitSpan = _this.getHitSpan(hit);

						resizeLocation = isStart ?
							_this.computeEventStartResize(origHitSpan, hitSpan, event) :
							_this.computeEventEndResize(origHitSpan, hitSpan, event);

						if (resizeLocation) {
							if (!calendar.isEventSpanAllowed(_this.eventToSpan(resizeLocation), event)) {
								disableCursor();
								resizeLocation = null;
							}
							// no change? (TODO: how does this work with timezones?)
							else if (resizeLocation.start.isSame(event.start) && resizeLocation.end.isSame(eventEnd)) {
								resizeLocation = null;
							}
						}

						if (resizeLocation) {
							view.hideEvent(event);
							_this.renderEventResize(resizeLocation, seg);
						}
					},
					hitOut: function () { // called before mouse moves to a different hit OR moved out of all hits
						resizeLocation = null;
					},
					hitDone: function () { // resets the rendering to show the original event
						_this.unrenderEventResize();
						view.showEvent(event);
						enableCursor();
					},
					dragStop: function (ev) {
						_this.segResizeStop(seg, ev);

						if (resizeLocation) { // valid date to resize to?
							view.reportEventResize(event, resizeLocation, this.largeUnit, el, ev);
						}
					}
				});

				dragListener.mousedown(ev); // start listening, which will eventually lead to a dragStart
			},


			// Called before event segment resizing starts
			segResizeStart: function (seg, ev) {
				this.isResizingSeg = true;
				this.view.trigger('eventResizeStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
			},


			// Called after event segment resizing stops
			segResizeStop: function (seg, ev) {
				this.isResizingSeg = false;
				this.view.trigger('eventResizeStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
			},


			// Returns new date-information for an event segment being resized from its start
			computeEventStartResize: function (startSpan, endSpan, event) {
				return this.computeEventResize('start', startSpan, endSpan, event);
			},


			// Returns new date-information for an event segment being resized from its end
			computeEventEndResize: function (startSpan, endSpan, event) {
				return this.computeEventResize('end', startSpan, endSpan, event);
			},


			// Returns new zoned date information for an event segment being resized from its start OR end
			// `type` is either 'start' or 'end'
			computeEventResize: function (type, startSpan, endSpan, event) {
				var calendar = this.view.calendar;
				var delta = this.diffDates(endSpan[type], startSpan[type]);
				var resizeLocation; // zoned event date properties
				var defaultDuration;

				// build original values to work from, guaranteeing a start and end
				resizeLocation = {
					start: event.start.clone(),
					end: calendar.getEventEnd(event),
					allDay: event.allDay
				};

				// if an all-day event was in a timed area and was resized to a time, adjust start/end to have times
				if (resizeLocation.allDay && durationHasTime(delta)) {
					resizeLocation.allDay = false;
					calendar.normalizeEventTimes(resizeLocation);
				}

				resizeLocation[type].add(delta); // apply delta to start or end

				// if the event was compressed too small, find a new reasonable duration for it
				if (!resizeLocation.start.isBefore(resizeLocation.end)) {

					defaultDuration =
						this.minResizeDuration || // TODO: hack
						(event.allDay ?
							calendar.defaultAllDayEventDuration :
							calendar.defaultTimedEventDuration);

					if (type == 'start') { // resizing the start?
						resizeLocation.start = resizeLocation.end.clone().subtract(defaultDuration);
					}
					else { // resizing the end?
						resizeLocation.end = resizeLocation.start.clone().add(defaultDuration);
					}
				}

				return resizeLocation;
			},


			// Renders a visual indication of an event being resized.
			// `range` has the updated dates of the event. `seg` is the original segment object involved in the drag.
			renderEventResize: function (range, seg) {
				// subclasses must implement
			},


			// Unrenders a visual indication of an event being resized.
			unrenderEventResize: function () {
				// subclasses must implement
			},


			/* Rendering Utils
			 ------------------------------------------------------------------------------------------------------------------*/


			// Compute the text that should be displayed on an event's element.
			// `range` can be the Event object itself, or something range-like, with at least a `start`.
			// If event times are disabled, or the event has no time, will return a blank string.
			// If not specified, formatStr will default to the eventTimeFormat setting,
			// and displayEnd will default to the displayEventEnd setting.
			getEventTimeText: function (range, formatStr, displayEnd) {

				if (formatStr == null) {
					formatStr = this.eventTimeFormat;
				}

				if (displayEnd == null) {
					displayEnd = this.displayEventEnd;
				}

				if (this.displayEventTime && range.start.hasTime()) {
					if (displayEnd && range.end) {
						return this.view.formatRange(range, formatStr);
					}
					else {
						return range.start.format(formatStr);
					}
				}

				return '';
			},


			// Generic utility for generating the HTML classNames for an event segment's element
			getSegClasses: function (seg, isDraggable, isResizable) {
				var event = seg.event;
				var classes = [
					'fc-event',
					seg.isStart ? 'fc-start' : 'fc-not-start',
					seg.isEnd ? 'fc-end' : 'fc-not-end'
				].concat(
					event.className,
					event.source ? event.source.className : []
				);

				if (isDraggable) {
					classes.push('fc-draggable');
				}
				if (isResizable) {
					classes.push('fc-resizable');
				}

				return classes;
			},


			// Utility for generating event skin-related CSS properties
			getEventSkinCss: function (event) {
				var view = this.view;
				var source = event.source || {};
				var eventColor = event.color;
				var sourceColor = source.color;
				var optionColor = view.opt('eventColor');

				return {
					'background-color': event.backgroundColor ||
					eventColor ||
					source.backgroundColor ||
					sourceColor ||
					view.opt('eventBackgroundColor') ||
					optionColor,
					'border-color': event.borderColor ||
					eventColor ||
					source.borderColor ||
					sourceColor ||
					view.opt('eventBorderColor') ||
					optionColor,
					color: event.textColor ||
					source.textColor ||
					view.opt('eventTextColor')
				};
			},


			/* Converting events -> eventRange -> eventSpan -> eventSegs
			 ------------------------------------------------------------------------------------------------------------------*/


			// Generates an array of segments for the given single event
			eventToSegs: function (event) {
				return this.eventsToSegs([event]);
			},


			// Generates a single span (always unzoned) by using the given event's dates.
			// Does not do any inverting for inverse-background events.
			eventToSpan: function (event) {
				var range = this.eventToRange(event);
				this.transformEventSpan(range, event); // convert it to a span, in-place
				return range;
			},


			// Converts an array of event objects into an array of event segment objects.
			// A custom `segSliceFunc` may be given for arbitrarily slicing up events.
			// Doesn't guarantee an order for the resulting array.
			eventsToSegs: function (allEvents, segSliceFunc) {
				var _this = this;
				var eventsById = groupEventsById(allEvents);
				var segs = [];

				$.each(eventsById, function (id, events) {
					var ranges = [];
					var i;

					for (i = 0; i < events.length; i++) {
						ranges.push(_this.eventToRange(events[i]));
					}

					// inverse-background events (utilize only the first event in calculations)
					if (isInverseBgEvent(events[0])) {
						ranges = _this.invertRanges(ranges);

						for (i = 0; i < ranges.length; i++) {
							_this.generateEventSegs(ranges[i], events[0], segSliceFunc, segs);
						}
					}
					// normal event ranges
					else {
						for (i = 0; i < ranges.length; i++) {
							_this.generateEventSegs(ranges[i], events[i], segSliceFunc, segs);
						}
					}
				});

				return segs;
			},


			// Generates the unzoned start/end dates an event appears to occupy
			eventToRange: function (event) {
				return {
					start: event.start.clone().stripZone(),
					end: this.view.calendar.getEventEnd(event).stripZone()
				};
			},


			// Given an event's span (unzoned start/end and other misc data), and the event itself,
			// slice into segments (using the segSliceFunc function if specified) and append to the `out` array.
			// SIDE EFFECT: will mutate the given `range`.
			generateEventSegs: function (range, event, segSliceFunc, out) {
				var segs;
				var i;

				this.transformEventSpan(range, event); // converts the range to a span

				segs = segSliceFunc ? segSliceFunc(range) : this.spanToSegs(range);

				for (i = 0; i < segs.length; i++) {
					this.transformEventSeg(segs[i], range, event);
					out.push(segs[i]);
				}
			},


			// Given a range (unzoned start/end) that is about to become a span,
			// attach any event-derived properties to it.
			transformEventSpan: function (range, event) {
				// subclasses can implement
			},


			// Given a segment object, attach any extra properties, based off of its source span and event.
			transformEventSeg: function (seg, span, event) {
				seg.event = event;
				seg.eventStartMS = +span.start; // TODO: not the best name after making spans unzoned
				seg.eventDurationMS = span.end - span.start;
			},


			// Produces a new array of range objects that will cover all the time NOT covered by the given ranges.
			// SIDE EFFECT: will mutate the given array and will use its date references.
			invertRanges: function (ranges) {
				var view = this.view;
				var viewStart = view.start.clone(); // need a copy
				var viewEnd = view.end.clone(); // need a copy
				var inverseRanges = [];
				var start = viewStart; // the end of the previous range. the start of the new range
				var i, range;

				// ranges need to be in order. required for our date-walking algorithm
				ranges.sort(compareRanges);

				for (i = 0; i < ranges.length; i++) {
					range = ranges[i];

					// add the span of time before the event (if there is any)
					if (range.start > start) { // compare millisecond time (skip any ambig logic)
						inverseRanges.push({
							start: start,
							end: range.start
						});
					}

					start = range.end;
				}

				// add the span of time after the last event (if there is any)
				if (start < viewEnd) { // compare millisecond time (skip any ambig logic)
					inverseRanges.push({
						start: start,
						end: viewEnd
					});
				}

				return inverseRanges;
			},


			sortEventSegs: function (segs) {
				segs.sort(proxy(this, 'compareEventSegs'));
			},


			// A cmp function for determining which segments should take visual priority
			compareEventSegs: function (seg1, seg2) {
				return seg1.eventStartMS - seg2.eventStartMS || // earlier events go first
					seg2.eventDurationMS - seg1.eventDurationMS || // tie? longer events go first
					seg2.event.allDay - seg1.event.allDay || // tie? put all-day events first (booleans cast to 0/1)
					compareByFieldSpecs(seg1.event, seg2.event, this.view.eventOrderSpecs);
			}

		});


		/* Utilities
		 ----------------------------------------------------------------------------------------------------------------------*/


		function isBgEvent(event) { // returns true if background OR inverse-background
			var rendering = getEventRendering(event);
			return rendering === 'background' || rendering === 'inverse-background';
		}


		function isInverseBgEvent(event) {
			return getEventRendering(event) === 'inverse-background';
		}


		function getEventRendering(event) {
			return firstDefined((event.source || {}).rendering, event.rendering);
		}


		function groupEventsById(events) {
			var eventsById = {};
			var i, event;

			for (i = 0; i < events.length; i++) {
				event = events[i];
				(eventsById[event._id] || (eventsById[event._id] = [])).push(event);
			}

			return eventsById;
		}


// A cmp function for determining which non-inverted "ranges" (see above) happen earlier
		function compareRanges(range1, range2) {
			return range1.start - range2.start; // earlier ranges go first
		}


		/* External-Dragging-Element Data
		 ----------------------------------------------------------------------------------------------------------------------*/

// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.
// A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.
		FC.dataAttrPrefix = '';

// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure
// to be used for Event Object creation.
// A defined `.eventProps`, even when empty, indicates that an event should be created.
		function getDraggedElMeta(el) {
			var prefix = FC.dataAttrPrefix;
			var eventProps; // properties for creating the event, not related to date/time
			var startTime; // a Duration
			var duration;
			var stick;

			if (prefix) {
				prefix += '-';
			}
			eventProps = el.data(prefix + 'event') || null;

			if (eventProps) {
				if (typeof eventProps === 'object') {
					eventProps = $.extend({}, eventProps); // make a copy
				}
				else { // something like 1 or true. still signal event creation
					eventProps = {};
				}

				// pluck special-cased date/time properties
				startTime = eventProps.start;
				if (startTime == null) {
					startTime = eventProps.time;
				} // accept 'time' as well
				duration = eventProps.duration;
				stick = eventProps.stick;
				delete eventProps.start;
				delete eventProps.time;
				delete eventProps.duration;
				delete eventProps.stick;
			}

			// fallback to standalone attribute values for each of the date/time properties
			if (startTime == null) {
				startTime = el.data(prefix + 'start');
			}
			if (startTime == null) {
				startTime = el.data(prefix + 'time');
			} // accept 'time' as well
			if (duration == null) {
				duration = el.data(prefix + 'duration');
			}
			if (stick == null) {
				stick = el.data(prefix + 'stick');
			}

			// massage into correct data types
			startTime = startTime != null ? moment.duration(startTime) : null;
			duration = duration != null ? moment.duration(duration) : null;
			stick = Boolean(stick);

			return {eventProps: eventProps, startTime: startTime, duration: duration, stick: stick};
		}


		;
		;

		/*
		 A set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.
		 Prerequisite: the object being mixed into needs to be a *Grid*
		 */
		var DayTableMixin = FC.DayTableMixin = {

			breakOnWeeks: false, // should create a new row for each week?
			dayDates: null, // whole-day dates for each column. left to right
			dayIndices: null, // for each day from start, the offset
			daysPerRow: null,
			rowCnt: null,
			colCnt: null,
			colHeadFormat: null,


			// Populates internal variables used for date calculation and rendering
			updateDayTable: function () {
				var view = this.view;
				var date = this.start.clone();
				var dayIndex = -1;
				var dayIndices = [];
				var dayDates = [];
				var daysPerRow;
				var firstDay;
				var rowCnt;

				while (date.isBefore(this.end)) { // loop each day from start to end
					if (view.isHiddenDay(date)) {
						dayIndices.push(dayIndex + 0.5); // mark that it's between indices
					}
					else {
						dayIndex++;
						dayIndices.push(dayIndex);
						dayDates.push(date.clone());
					}
					date.add(1, 'days');
				}

				if (this.breakOnWeeks) {
					// count columns until the day-of-week repeats
					firstDay = dayDates[0].day();
					for (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {
						if (dayDates[daysPerRow].day() == firstDay) {
							break;
						}
					}
					rowCnt = Math.ceil(dayDates.length / daysPerRow);
				}
				else {
					rowCnt = 1;
					daysPerRow = dayDates.length;
				}

				this.dayDates = dayDates;
				this.dayIndices = dayIndices;
				this.daysPerRow = daysPerRow;
				this.rowCnt = rowCnt;

				this.updateDayTableCols();
			},


			// Computes and assigned the colCnt property and updates any options that may be computed from it
			updateDayTableCols: function () {
				this.colCnt = this.computeColCnt();
				this.colHeadFormat = this.view.opt('columnFormat') || this.computeColHeadFormat();
			},


			// Determines how many columns there should be in the table
			computeColCnt: function () {
				return this.daysPerRow;
			},


			// Computes the ambiguously-timed moment for the given cell
			getCellDate: function (row, col) {
				return this.dayDates[
					this.getCellDayIndex(row, col)
					].clone();
			},


			// Computes the ambiguously-timed date range for the given cell
			getCellRange: function (row, col) {
				var start = this.getCellDate(row, col);
				var end = start.clone().add(1, 'days');

				return {start: start, end: end};
			},


			// Returns the number of day cells, chronologically, from the first of the grid (0-based)
			getCellDayIndex: function (row, col) {
				return row * this.daysPerRow + this.getColDayIndex(col);
			},


			// Returns the numner of day cells, chronologically, from the first cell in *any given row*
			getColDayIndex: function (col) {
				if (this.isRTL) {
					return this.colCnt - 1 - col;
				}
				else {
					return col;
				}
			},


			// Given a date, returns its chronolocial cell-index from the first cell of the grid.
			// If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
			// If before the first offset, returns a negative number.
			// If after the last offset, returns an offset past the last cell offset.
			// Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
			getDateDayIndex: function (date) {
				var dayIndices = this.dayIndices;
				var dayOffset = date.diff(this.start, 'days');

				if (dayOffset < 0) {
					return dayIndices[0] - 1;
				}
				else if (dayOffset >= dayIndices.length) {
					return dayIndices[dayIndices.length - 1] + 1;
				}
				else {
					return dayIndices[dayOffset];
				}
			},


			/* Options
			 ------------------------------------------------------------------------------------------------------------------*/


			// Computes a default column header formatting string if `colFormat` is not explicitly defined
			computeColHeadFormat: function () {
				// if more than one week row, or if there are a lot of columns with not much space,
				// put just the day numbers will be in each cell
				if (this.rowCnt > 1 || this.colCnt > 10) {
					return 'ddd'; // "Sat"
				}
				// multiple days, so full single date string WON'T be in title text
				else if (this.colCnt > 1) {
					return this.view.opt('dayOfMonthFormat'); // "Sat 12/10"
				}
				// single day, so full single date string will probably be in title text
				else {
					return 'dddd'; // "Saturday"
				}
			},


			/* Slicing
			 ------------------------------------------------------------------------------------------------------------------*/


			// Slices up a date range into a segment for every week-row it intersects with
			sliceRangeByRow: function (range) {
				var daysPerRow = this.daysPerRow;
				var normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold
				var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
				var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
				var segs = [];
				var row;
				var rowFirst, rowLast; // inclusive day-index range for current row
				var segFirst, segLast; // inclusive day-index range for segment

				for (row = 0; row < this.rowCnt; row++) {
					rowFirst = row * daysPerRow;
					rowLast = rowFirst + daysPerRow - 1;

					// intersect segment's offset range with the row's
					segFirst = Math.max(rangeFirst, rowFirst);
					segLast = Math.min(rangeLast, rowLast);

					// deal with in-between indices
					segFirst = Math.ceil(segFirst); // in-between starts round to next cell
					segLast = Math.floor(segLast); // in-between ends round to prev cell

					if (segFirst <= segLast) { // was there any intersection with the current row?
						segs.push({
							row: row,

							// normalize to start of row
							firstRowDayIndex: segFirst - rowFirst,
							lastRowDayIndex: segLast - rowFirst,

							// must be matching integers to be the segment's start/end
							isStart: segFirst === rangeFirst,
							isEnd: segLast === rangeLast
						});
					}
				}

				return segs;
			},


			// Slices up a date range into a segment for every day-cell it intersects with.
			// TODO: make more DRY with sliceRangeByRow somehow.
			sliceRangeByDay: function (range) {
				var daysPerRow = this.daysPerRow;
				var normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold
				var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
				var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
				var segs = [];
				var row;
				var rowFirst, rowLast; // inclusive day-index range for current row
				var i;
				var segFirst, segLast; // inclusive day-index range for segment

				for (row = 0; row < this.rowCnt; row++) {
					rowFirst = row * daysPerRow;
					rowLast = rowFirst + daysPerRow - 1;

					for (i = rowFirst; i <= rowLast; i++) {

						// intersect segment's offset range with the row's
						segFirst = Math.max(rangeFirst, i);
						segLast = Math.min(rangeLast, i);

						// deal with in-between indices
						segFirst = Math.ceil(segFirst); // in-between starts round to next cell
						segLast = Math.floor(segLast); // in-between ends round to prev cell

						if (segFirst <= segLast) { // was there any intersection with the current row?
							segs.push({
								row: row,

								// normalize to start of row
								firstRowDayIndex: segFirst - rowFirst,
								lastRowDayIndex: segLast - rowFirst,

								// must be matching integers to be the segment's start/end
								isStart: segFirst === rangeFirst,
								isEnd: segLast === rangeLast
							});
						}
					}
				}

				return segs;
			},


			/* Header Rendering
			 ------------------------------------------------------------------------------------------------------------------*/


			renderHeadHtml: function () {
				var view = this.view;

				return '' +
					'<div class="fc-row ' + view.widgetHeaderClass + '">' +
					'<table>' +
					'<thead>' +
					this.renderHeadTrHtml() +
					'</thead>' +
					'</table>' +
					'</div>';
			},


			renderHeadIntroHtml: function () {
				return this.renderIntroHtml(); // fall back to generic
			},


			renderHeadTrHtml: function () {
				return '' +
					'<tr>' +
					(this.isRTL ? '' : this.renderHeadIntroHtml()) +
					this.renderHeadDateCellsHtml() +
					(this.isRTL ? this.renderHeadIntroHtml() : '') +
					'</tr>';
			},


			renderHeadDateCellsHtml: function () {
				var htmls = [];
				var col, date;

				for (col = 0; col < this.colCnt; col++) {
					date = this.getCellDate(0, col);
					htmls.push(this.renderHeadDateCellHtml(date));
				}

				return htmls.join('');
			},


			renderHeadDateCellHtml: function (date, colspan) {
				var view = this.view;

				return '' +
					'<th class="fc-day-header ' + view.widgetHeaderClass + ' fc-' + dayIDs[date.day()] + '"' +
					(colspan > 1 ? ' colspan="' + colspan + '"' : '') +
					'>' +
					htmlEscape(date.format(this.colHeadFormat)) +
					'</th>';
			},


			/* Background Rendering
			 ------------------------------------------------------------------------------------------------------------------*/


			renderBgTrHtml: function (row) {
				return '' +
					'<tr>' +
					(this.isRTL ? '' : this.renderBgIntroHtml(row)) +
					this.renderBgCellsHtml(row) +
					(this.isRTL ? this.renderBgIntroHtml(row) : '') +
					'</tr>';
			},


			renderBgIntroHtml: function (row) {
				return this.renderIntroHtml(); // fall back to generic
			},


			renderBgCellsHtml: function (row) {
				var htmls = [];
				var col, date;

				for (col = 0; col < this.colCnt; col++) {
					date = this.getCellDate(row, col);
					htmls.push(this.renderBgCellHtml(date));
				}

				return htmls.join('');
			},


			renderBgCellHtml: function (date) {
				var view = this.view;
				var classes = this.getDayClasses(date);

				classes.unshift('fc-day', view.widgetContentClass);

				return '<td class="' + classes.join(' ') + '"' +
					' data-date="' + date.format('YYYY-MM-DD') + '"' + // if date has a time, won't format it
					'></td>';
			},


			/* Generic
			 ------------------------------------------------------------------------------------------------------------------*/


			// Generates the default HTML intro for any row. User classes should override
			renderIntroHtml: function () {
			},


			/* Utils
			 ------------------------------------------------------------------------------------------------------------------*/


			// Applies the generic "intro" and "outro" HTML to the given cells.
			// Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.
			bookendCells: function (trEl) {
				var introHtml = this.renderIntroHtml();

				if (introHtml) {
					if (this.isRTL) {
						trEl.append(introHtml);
					}
					else {
						trEl.prepend(introHtml);
					}
				}
			}

		};

		;
		;

		/* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.
		 ----------------------------------------------------------------------------------------------------------------------*/

		var DayGrid = FC.DayGrid = Grid.extend(DayTableMixin, {

			numbersVisible: false, // should render a row for day/week numbers? set by outside view. TODO: make internal
			bottomCoordPadding: 0, // hack for extending the hit area for the last row of the coordinate grid

			rowEls: null, // set of fake row elements
			cellEls: null, // set of whole-day elements comprising the row's background
			helperEls: null, // set of cell skeleton elements for rendering the mock event "helper"

			rowCoordCache: null,
			colCoordCache: null,


			// Renders the rows and columns into the component's `this.el`, which should already be assigned.
			// isRigid determins whether the individual rows should ignore the contents and be a constant height.
			// Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.
			renderDates: function (isRigid) {
				var view = this.view;
				var rowCnt = this.rowCnt;
				var colCnt = this.colCnt;
				var html = '';
				var row;
				var col;

				for (row = 0; row < rowCnt; row++) {
					html += this.renderDayRowHtml(row, isRigid);
				}
				this.el.html(html);

				this.rowEls = this.el.find('.fc-row');
				this.cellEls = this.el.find('.fc-day');

				this.rowCoordCache = new CoordCache({
					els: this.rowEls,
					isVertical: true
				});
				this.colCoordCache = new CoordCache({
					els: this.cellEls.slice(0, this.colCnt), // only the first row
					isHorizontal: true
				});

				// trigger dayRender with each cell's element
				for (row = 0; row < rowCnt; row++) {
					for (col = 0; col < colCnt; col++) {
						view.trigger(
							'dayRender',
							null,
							this.getCellDate(row, col),
							this.getCellEl(row, col)
						);
					}
				}
			},


			unrenderDates: function () {
				this.removeSegPopover();
			},


			renderBusinessHours: function () {
				var events = this.view.calendar.getBusinessHoursEvents(true); // wholeDay=true
				var segs = this.eventsToSegs(events);

				this.renderFill('businessHours', segs, 'bgevent');
			},


			// Generates the HTML for a single row, which is a div that wraps a table.
			// `row` is the row number.
			renderDayRowHtml: function (row, isRigid) {
				var view = this.view;
				var classes = ['fc-row', 'fc-week', view.widgetContentClass];

				if (isRigid) {
					classes.push('fc-rigid');
				}

				return '' +
					'<div class="' + classes.join(' ') + '">' +
					'<div class="fc-bg">' +
					'<table>' +
					this.renderBgTrHtml(row) +
					'</table>' +
					'</div>' +
					'<div class="fc-content-skeleton">' +
					'<table>' +
					(this.numbersVisible ?
						'<thead>' +
						this.renderNumberTrHtml(row) +
						'</thead>' :
							''
					) +
					'</table>' +
					'</div>' +
					'</div>';
			},


			/* Grid Number Rendering
			 ------------------------------------------------------------------------------------------------------------------*/


			renderNumberTrHtml: function (row) {
				return '' +
					'<tr>' +
					(this.isRTL ? '' : this.renderNumberIntroHtml(row)) +
					this.renderNumberCellsHtml(row) +
					(this.isRTL ? this.renderNumberIntroHtml(row) : '') +
					'</tr>';
			},


			renderNumberIntroHtml: function (row) {
				return this.renderIntroHtml();
			},


			renderNumberCellsHtml: function (row) {
				var htmls = [];
				var col, date;

				for (col = 0; col < this.colCnt; col++) {
					date = this.getCellDate(row, col);
					htmls.push(this.renderNumberCellHtml(date));
				}

				return htmls.join('');
			},


			// Generates the HTML for the <td>s of the "number" row in the DayGrid's content skeleton.
			// The number row will only exist if either day numbers or week numbers are turned on.
			renderNumberCellHtml: function (date) {
				var classes;

				if (!this.view.dayNumbersVisible) { // if there are week numbers but not day numbers
					return '<td/>'; //  will create an empty space above events :(
				}

				classes = this.getDayClasses(date);
				classes.unshift('fc-day-number');

				return '' +
					'<td class="' + classes.join(' ') + '" data-date="' + date.format() + '">' +
					date.date() +
					'</td>';
			},


			/* Options
			 ------------------------------------------------------------------------------------------------------------------*/


			// Computes a default event time formatting string if `timeFormat` is not explicitly defined
			computeEventTimeFormat: function () {
				return this.view.opt('extraSmallTimeFormat'); // like "6p" or "6:30p"
			},


			// Computes a default `displayEventEnd` value if one is not expliclty defined
			computeDisplayEventEnd: function () {
				return this.colCnt == 1; // we'll likely have space if there's only one day
			},


			/* Dates
			 ------------------------------------------------------------------------------------------------------------------*/


			rangeUpdated: function () {
				this.updateDayTable();
			},


			// Slices up the given span (unzoned start/end with other misc data) into an array of segments
			spanToSegs: function (span) {
				var segs = this.sliceRangeByRow(span);
				var i, seg;

				for (i = 0; i < segs.length; i++) {
					seg = segs[i];
					if (this.isRTL) {
						seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;
						seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;
					}
					else {
						seg.leftCol = seg.firstRowDayIndex;
						seg.rightCol = seg.lastRowDayIndex;
					}
				}

				return segs;
			},


			/* Hit System
			 ------------------------------------------------------------------------------------------------------------------*/


			prepareHits: function () {
				this.colCoordCache.build();
				this.rowCoordCache.build();
				this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack
			},


			releaseHits: function () {
				this.colCoordCache.clear();
				this.rowCoordCache.clear();
			},


			queryHit: function (leftOffset, topOffset) {
				var col = this.colCoordCache.getHorizontalIndex(leftOffset);
				var row = this.rowCoordCache.getVerticalIndex(topOffset);

				if (row != null && col != null) {
					return this.getCellHit(row, col);
				}
			},


			getHitSpan: function (hit) {
				return this.getCellRange(hit.row, hit.col);
			},


			getHitEl: function (hit) {
				return this.getCellEl(hit.row, hit.col);
			},


			/* Cell System
			 ------------------------------------------------------------------------------------------------------------------*/
			// FYI: the first column is the leftmost column, regardless of date


			getCellHit: function (row, col) {
				return {
					row: row,
					col: col,
					component: this, // needed unfortunately :(
					left: this.colCoordCache.getLeftOffset(col),
					right: this.colCoordCache.getRightOffset(col),
					top: this.rowCoordCache.getTopOffset(row),
					bottom: this.rowCoordCache.getBottomOffset(row)
				};
			},


			getCellEl: function (row, col) {
				return this.cellEls.eq(row * this.colCnt + col);
			},


			/* Event Drag Visualization
			 ------------------------------------------------------------------------------------------------------------------*/
			// TODO: move to DayGrid.event, similar to what we did with Grid's drag methods


			// Renders a visual indication of an event or external element being dragged.
			// `eventLocation` has zoned start and end (optional)
			renderDrag: function (eventLocation, seg) {

				// always render a highlight underneath
				this.renderHighlight(this.eventToSpan(eventLocation));

				// if a segment from the same calendar but another component is being dragged, render a helper event
				if (seg && !seg.el.closest(this.el).length) {

					this.renderEventLocationHelper(eventLocation, seg);
					this.applyDragOpacity(this.helperEls);

					return true; // a helper has been rendered
				}
			},


			// Unrenders any visual indication of a hovering event
			unrenderDrag: function () {
				this.unrenderHighlight();
				this.unrenderHelper();
			},


			/* Event Resize Visualization
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders a visual indication of an event being resized
			renderEventResize: function (eventLocation, seg) {
				this.renderHighlight(this.eventToSpan(eventLocation));
				this.renderEventLocationHelper(eventLocation, seg);
			},


			// Unrenders a visual indication of an event being resized
			unrenderEventResize: function () {
				this.unrenderHighlight();
				this.unrenderHelper();
			},


			/* Event Helper
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders a mock "helper" event. `sourceSeg` is the associated internal segment object. It can be null.
			renderHelper: function (event, sourceSeg) {
				var helperNodes = [];
				var segs = this.eventToSegs(event);
				var rowStructs;

				segs = this.renderFgSegEls(segs); // assigns each seg's el and returns a subset of segs that were rendered
				rowStructs = this.renderSegRows(segs);

				// inject each new event skeleton into each associated row
				this.rowEls.each(function (row, rowNode) {
					var rowEl = $(rowNode); // the .fc-row
					var skeletonEl = $('<div class="fc-helper-skeleton"><table/></div>'); // will be absolutely positioned
					var skeletonTop;

					// If there is an original segment, match the top position. Otherwise, put it at the row's top level
					if (sourceSeg && sourceSeg.row === row) {
						skeletonTop = sourceSeg.el.position().top;
					}
					else {
						skeletonTop = rowEl.find('.fc-content-skeleton tbody').position().top;
					}

					skeletonEl.css('top', skeletonTop)
						.find('table')
						.append(rowStructs[row].tbodyEl);

					rowEl.append(skeletonEl);
					helperNodes.push(skeletonEl[0]);
				});

				this.helperEls = $(helperNodes); // array -> jQuery set
			},


			// Unrenders any visual indication of a mock helper event
			unrenderHelper: function () {
				if (this.helperEls) {
					this.helperEls.remove();
					this.helperEls = null;
				}
			},


			/* Fill System (highlight, background events, business hours)
			 ------------------------------------------------------------------------------------------------------------------*/


			fillSegTag: 'td', // override the default tag name


			// Renders a set of rectangles over the given segments of days.
			// Only returns segments that successfully rendered.
			renderFill: function (type, segs, className) {
				var nodes = [];
				var i, seg;
				var skeletonEl;

				segs = this.renderFillSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs

				for (i = 0; i < segs.length; i++) {
					seg = segs[i];
					skeletonEl = this.renderFillRow(type, seg, className);
					this.rowEls.eq(seg.row).append(skeletonEl);
					nodes.push(skeletonEl[0]);
				}

				this.elsByFill[type] = $(nodes);

				return segs;
			},


			// Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.
			renderFillRow: function (type, seg, className) {
				var colCnt = this.colCnt;
				var startCol = seg.leftCol;
				var endCol = seg.rightCol + 1;
				var skeletonEl;
				var trEl;

				className = className || type.toLowerCase();

				skeletonEl = $(
					'<div class="fc-' + className + '-skeleton">' +
					'<table><tr/></table>' +
					'</div>'
				);
				trEl = skeletonEl.find('tr');

				if (startCol > 0) {
					trEl.append('<td colspan="' + startCol + '"/>');
				}

				trEl.append(
					seg.el.attr('colspan', endCol - startCol)
				);

				if (endCol < colCnt) {
					trEl.append('<td colspan="' + (colCnt - endCol) + '"/>');
				}

				this.bookendCells(trEl);

				return skeletonEl;
			}

		});

		;
		;

		/* Event-rendering methods for the DayGrid class
		 ----------------------------------------------------------------------------------------------------------------------*/

		DayGrid.mixin({

			rowStructs: null, // an array of objects, each holding information about a row's foreground event-rendering


			// Unrenders all events currently rendered on the grid
			unrenderEvents: function () {
				this.removeSegPopover(); // removes the "more.." events popover
				Grid.prototype.unrenderEvents.apply(this, arguments); // calls the super-method
			},


			// Retrieves all rendered segment objects currently rendered on the grid
			getEventSegs: function () {
				return Grid.prototype.getEventSegs.call(this) // get the segments from the super-method
					.concat(this.popoverSegs || []); // append the segments from the "more..." popover
			},


			// Renders the given background event segments onto the grid
			renderBgSegs: function (segs) {

				// don't render timed background events
				var allDaySegs = $.grep(segs, function (seg) {
					return seg.event.allDay;
				});

				return Grid.prototype.renderBgSegs.call(this, allDaySegs); // call the super-method
			},


			// Renders the given foreground event segments onto the grid
			renderFgSegs: function (segs) {
				var rowStructs;

				// render an `.el` on each seg
				// returns a subset of the segs. segs that were actually rendered
				segs = this.renderFgSegEls(segs);

				rowStructs = this.rowStructs = this.renderSegRows(segs);

				// append to each row's content skeleton
				this.rowEls.each(function (i, rowNode) {
					$(rowNode).find('.fc-content-skeleton > table').append(
						rowStructs[i].tbodyEl
					);
				});

				return segs; // return only the segs that were actually rendered
			},


			// Unrenders all currently rendered foreground event segments
			unrenderFgSegs: function () {
				var rowStructs = this.rowStructs || [];
				var rowStruct;

				while ((rowStruct = rowStructs.pop())) {
					rowStruct.tbodyEl.remove();
				}

				this.rowStructs = null;
			},


			// Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.
			// Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
			// PRECONDITION: each segment shoud already have a rendered and assigned `.el`
			renderSegRows: function (segs) {
				var rowStructs = [];
				var segRows;
				var row;

				segRows = this.groupSegRows(segs); // group into nested arrays

				// iterate each row of segment groupings
				for (row = 0; row < segRows.length; row++) {
					rowStructs.push(
						this.renderSegRow(row, segRows[row])
					);
				}

				return rowStructs;
			},


			// Builds the HTML to be used for the default element for an individual segment
			fgSegHtml: function (seg, disableResizing) {
				var view = this.view;
				var event = seg.event;
				var isDraggable = view.isEventDraggable(event);
				var isResizableFromStart = !disableResizing && event.allDay &&
					seg.isStart && view.isEventResizableFromStart(event);
				var isResizableFromEnd = !disableResizing && event.allDay &&
					seg.isEnd && view.isEventResizableFromEnd(event);
				var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
				var skinCss = cssToStr(this.getEventSkinCss(event));
				var timeHtml = '';
				var timeText;
				var titleHtml;

				classes.unshift('fc-day-grid-event', 'fc-h-event');

				// Only display a timed events time if it is the starting segment
				if (seg.isStart) {
					timeText = this.getEventTimeText(event);
					if (timeText) {
						timeHtml = '<span class="fc-time">' + htmlEscape(timeText) + '</span>';
					}
				}

				titleHtml =
					'<span class="fc-title">' +
					(htmlEscape(event.title || '') || '&nbsp;') + // we always want one line of height
					'</span>';

				return '<a class="' + classes.join(' ') + '"' +
					(event.url ?
						' href="' + htmlEscape(event.url) + '"' :
							''
					) +
					(skinCss ?
						' style="' + skinCss + '"' :
							''
					) +
					'>' +
					'<div class="fc-content">' +
					(this.isRTL ?
						titleHtml + ' ' + timeHtml : // put a natural space in between
						timeHtml + ' ' + titleHtml   //
					) +
					'</div>' +
					(isResizableFromStart ?
							'<div class="fc-resizer fc-start-resizer" />' :
							''
					) +
					(isResizableFromEnd ?
							'<div class="fc-resizer fc-end-resizer" />' :
							''
					) +
					'</a>';
			},


			// Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains
			// the segments. Returns object with a bunch of internal data about how the render was calculated.
			// NOTE: modifies rowSegs
			renderSegRow: function (row, rowSegs) {
				var colCnt = this.colCnt;
				var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels
				var levelCnt = Math.max(1, segLevels.length); // ensure at least one level
				var tbody = $('<tbody/>');
				var segMatrix = []; // lookup for which segments are rendered into which level+col cells
				var cellMatrix = []; // lookup for all <td> elements of the level+col matrix
				var loneCellMatrix = []; // lookup for <td> elements that only take up a single column
				var i, levelSegs;
				var col;
				var tr;
				var j, seg;
				var td;

				// populates empty cells from the current column (`col`) to `endCol`
				function emptyCellsUntil(endCol) {
					while (col < endCol) {
						// try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
						td = (loneCellMatrix[i - 1] || [])[col];
						if (td) {
							td.attr(
								'rowspan',
								parseInt(td.attr('rowspan') || 1, 10) + 1
							);
						}
						else {
							td = $('<td/>');
							tr.append(td);
						}
						cellMatrix[i][col] = td;
						loneCellMatrix[i][col] = td;
						col++;
					}
				}

				for (i = 0; i < levelCnt; i++) { // iterate through all levels
					levelSegs = segLevels[i];
					col = 0;
					tr = $('<tr/>');

					segMatrix.push([]);
					cellMatrix.push([]);
					loneCellMatrix.push([]);

					// levelCnt might be 1 even though there are no actual levels. protect against this.
					// this single empty row is useful for styling.
					if (levelSegs) {
						for (j = 0; j < levelSegs.length; j++) { // iterate through segments in level
							seg = levelSegs[j];

							emptyCellsUntil(seg.leftCol);

							// create a container that occupies or more columns. append the event element.
							td = $('<td class="fc-event-container"/>').append(seg.el);
							if (seg.leftCol != seg.rightCol) {
								td.attr('colspan', seg.rightCol - seg.leftCol + 1);
							}
							else { // a single-column segment
								loneCellMatrix[i][col] = td;
							}

							while (col <= seg.rightCol) {
								cellMatrix[i][col] = td;
								segMatrix[i][col] = seg;
								col++;
							}

							tr.append(td);
						}
					}

					emptyCellsUntil(colCnt); // finish off the row
					this.bookendCells(tr);
					tbody.append(tr);
				}

				return { // a "rowStruct"
					row: row, // the row number
					tbodyEl: tbody,
					cellMatrix: cellMatrix,
					segMatrix: segMatrix,
					segLevels: segLevels,
					segs: rowSegs
				};
			},


			// Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
			// NOTE: modifies segs
			buildSegLevels: function (segs) {
				var levels = [];
				var i, seg;
				var j;

				// Give preference to elements with certain criteria, so they have
				// a chance to be closer to the top.
				this.sortEventSegs(segs);

				for (i = 0; i < segs.length; i++) {
					seg = segs[i];

					// loop through levels, starting with the topmost, until the segment doesn't collide with other segments
					for (j = 0; j < levels.length; j++) {
						if (!isDaySegCollision(seg, levels[j])) {
							break;
						}
					}
					// `j` now holds the desired subrow index
					seg.level = j;

					// create new level array if needed and append segment
					(levels[j] || (levels[j] = [])).push(seg);
				}

				// order segments left-to-right. very important if calendar is RTL
				for (j = 0; j < levels.length; j++) {
					levels[j].sort(compareDaySegCols);
				}

				return levels;
			},


			// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row
			groupSegRows: function (segs) {
				var segRows = [];
				var i;

				for (i = 0; i < this.rowCnt; i++) {
					segRows.push([]);
				}

				for (i = 0; i < segs.length; i++) {
					segRows[segs[i].row].push(segs[i]);
				}

				return segRows;
			}

		});


// Computes whether two segments' columns collide. They are assumed to be in the same row.
		function isDaySegCollision(seg, otherSegs) {
			var i, otherSeg;

			for (i = 0; i < otherSegs.length; i++) {
				otherSeg = otherSegs[i];

				if (
					otherSeg.leftCol <= seg.rightCol &&
					otherSeg.rightCol >= seg.leftCol
				) {
					return true;
				}
			}

			return false;
		}


// A cmp function for determining the leftmost event
		function compareDaySegCols(a, b) {
			return a.leftCol - b.leftCol;
		}

		;
		;

		/* Methods relate to limiting the number events for a given day on a DayGrid
		 ----------------------------------------------------------------------------------------------------------------------*/
// NOTE: all the segs being passed around in here are foreground segs

		DayGrid.mixin({

			segPopover: null, // the Popover that holds events that can't fit in a cell. null when not visible
			popoverSegs: null, // an array of segment objects that the segPopover holds. null when not visible


			removeSegPopover: function () {
				if (this.segPopover) {
					this.segPopover.hide(); // in handler, will call segPopover's removeElement
				}
			},


			// Limits the number of "levels" (vertically stacking layers of events) for each row of the grid.
			// `levelLimit` can be false (don't limit), a number, or true (should be computed).
			limitRows: function (levelLimit) {
				var rowStructs = this.rowStructs || [];
				var row; // row #
				var rowLevelLimit;

				for (row = 0; row < rowStructs.length; row++) {
					this.unlimitRow(row);

					if (!levelLimit) {
						rowLevelLimit = false;
					}
					else if (typeof levelLimit === 'number') {
						rowLevelLimit = levelLimit;
					}
					else {
						rowLevelLimit = this.computeRowLevelLimit(row);
					}

					if (rowLevelLimit !== false) {
						this.limitRow(row, rowLevelLimit);
					}
				}
			},


			// Computes the number of levels a row will accomodate without going outside its bounds.
			// Assumes the row is "rigid" (maintains a constant height regardless of what is inside).
			// `row` is the row number.
			computeRowLevelLimit: function (row) {
				var rowEl = this.rowEls.eq(row); // the containing "fake" row div
				var rowHeight = rowEl.height(); // TODO: cache somehow?
				var trEls = this.rowStructs[row].tbodyEl.children();
				var i, trEl;
				var trHeight;

				function iterInnerHeights(i, childNode) {
					trHeight = Math.max(trHeight, $(childNode).outerHeight());
				}

				// Reveal one level <tr> at a time and stop when we find one out of bounds
				for (i = 0; i < trEls.length; i++) {
					trEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)

					// with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,
					// so instead, find the tallest inner content element.
					trHeight = 0;
					trEl.find('> td > :first-child').each(iterInnerHeights);

					if (trEl.position().top + trHeight > rowHeight) {
						return i;
					}
				}

				return false; // should not limit at all
			},


			// Limits the given grid row to the maximum number of levels and injects "more" links if necessary.
			// `row` is the row number.
			// `levelLimit` is a number for the maximum (inclusive) number of levels allowed.
			limitRow: function (row, levelLimit) {
				var _this = this;
				var rowStruct = this.rowStructs[row];
				var moreNodes = []; // array of "more" <a> links and <td> DOM nodes
				var col = 0; // col #, left-to-right (not chronologically)
				var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right
				var cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row
				var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes
				var i, seg;
				var segsBelow; // array of segment objects below `seg` in the current `col`
				var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies
				var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)
				var td, rowspan;
				var segMoreNodes; // array of "more" <td> cells that will stand-in for the current seg's cell
				var j;
				var moreTd, moreWrap, moreLink;

				// Iterates through empty level cells and places "more" links inside if need be
				function emptyCellsUntil(endCol) { // goes from current `col` to `endCol`
					while (col < endCol) {
						segsBelow = _this.getCellSegs(row, col, levelLimit);
						if (segsBelow.length) {
							td = cellMatrix[levelLimit - 1][col];
							moreLink = _this.renderMoreLink(row, col, segsBelow);
							moreWrap = $('<div/>').append(moreLink);
							td.append(moreWrap);
							moreNodes.push(moreWrap[0]);
						}
						col++;
					}
				}

				if (levelLimit && levelLimit < rowStruct.segLevels.length) { // is it actually over the limit?
					levelSegs = rowStruct.segLevels[levelLimit - 1];
					cellMatrix = rowStruct.cellMatrix;

					limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit
						.addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array

					// iterate though segments in the last allowable level
					for (i = 0; i < levelSegs.length; i++) {
						seg = levelSegs[i];
						emptyCellsUntil(seg.leftCol); // process empty cells before the segment

						// determine *all* segments below `seg` that occupy the same columns
						colSegsBelow = [];
						totalSegsBelow = 0;
						while (col <= seg.rightCol) {
							segsBelow = this.getCellSegs(row, col, levelLimit);
							colSegsBelow.push(segsBelow);
							totalSegsBelow += segsBelow.length;
							col++;
						}

						if (totalSegsBelow) { // do we need to replace this segment with one or many "more" links?
							td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell
							rowspan = td.attr('rowspan') || 1;
							segMoreNodes = [];

							// make a replacement <td> for each column the segment occupies. will be one for each colspan
							for (j = 0; j < colSegsBelow.length; j++) {
								moreTd = $('<td class="fc-more-cell"/>').attr('rowspan', rowspan);
								segsBelow = colSegsBelow[j];
								moreLink = this.renderMoreLink(
									row,
									seg.leftCol + j,
									[seg].concat(segsBelow) // count seg as hidden too
								);
								moreWrap = $('<div/>').append(moreLink);
								moreTd.append(moreWrap);
								segMoreNodes.push(moreTd[0]);
								moreNodes.push(moreTd[0]);
							}

							td.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements
							limitedNodes.push(td[0]);
						}
					}

					emptyCellsUntil(this.colCnt); // finish off the level
					rowStruct.moreEls = $(moreNodes); // for easy undoing later
					rowStruct.limitedEls = $(limitedNodes); // for easy undoing later
				}
			},


			// Reveals all levels and removes all "more"-related elements for a grid's row.
			// `row` is a row number.
			unlimitRow: function (row) {
				var rowStruct = this.rowStructs[row];

				if (rowStruct.moreEls) {
					rowStruct.moreEls.remove();
					rowStruct.moreEls = null;
				}

				if (rowStruct.limitedEls) {
					rowStruct.limitedEls.removeClass('fc-limited');
					rowStruct.limitedEls = null;
				}
			},


			// Renders an <a> element that represents hidden event element for a cell.
			// Responsible for attaching click handler as well.
			renderMoreLink: function (row, col, hiddenSegs) {
				var _this = this;
				var view = this.view;

				return $('<a class="fc-more"/>')
					.text(
					this.getMoreLinkText(hiddenSegs.length)
				)
					.on('click', function (ev) {
						var clickOption = view.opt('eventLimitClick');
						var date = _this.getCellDate(row, col);
						var moreEl = $(this);
						var dayEl = _this.getCellEl(row, col);
						var allSegs = _this.getCellSegs(row, col);

						// rescope the segments to be within the cell's date
						var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);
						var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);

						if (typeof clickOption === 'function') {
							// the returned value can be an atomic option
							clickOption = view.trigger('eventLimitClick', null, {
								date: date,
								dayEl: dayEl,
								moreEl: moreEl,
								segs: reslicedAllSegs,
								hiddenSegs: reslicedHiddenSegs
							}, ev);
						}

						if (clickOption === 'popover') {
							_this.showSegPopover(row, col, moreEl, reslicedAllSegs);
						}
						else if (typeof clickOption === 'string') { // a view name
							view.calendar.zoomTo(date, clickOption);
						}
					});
			},


			// Reveals the popover that displays all events within a cell
			showSegPopover: function (row, col, moreLink, segs) {
				var _this = this;
				var view = this.view;
				var moreWrap = moreLink.parent(); // the <div> wrapper around the <a>
				var topEl; // the element we want to match the top coordinate of
				var options;

				if (this.rowCnt == 1) {
					topEl = view.el; // will cause the popover to cover any sort of header
				}
				else {
					topEl = this.rowEls.eq(row); // will align with top of row
				}

				options = {
					className: 'fc-more-popover',
					content: this.renderSegPopoverContent(row, col, segs),
					parentEl: this.el,
					top: topEl.offset().top,
					autoHide: true, // when the user clicks elsewhere, hide the popover
					viewportConstrain: view.opt('popoverViewportConstrain'),
					hide: function () {
						// kill everything when the popover is hidden
						_this.segPopover.removeElement();
						_this.segPopover = null;
						_this.popoverSegs = null;
					}
				};

				// Determine horizontal coordinate.
				// We use the moreWrap instead of the <td> to avoid border confusion.
				if (this.isRTL) {
					options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border
				}
				else {
					options.left = moreWrap.offset().left - 1; // -1 to be over cell border
				}

				this.segPopover = new Popover(options);
				this.segPopover.show();
			},


			// Builds the inner DOM contents of the segment popover
			renderSegPopoverContent: function (row, col, segs) {
				var view = this.view;
				var isTheme = view.opt('theme');
				var title = this.getCellDate(row, col).format(view.opt('dayPopoverFormat'));
				var content = $(
					'<div class="fc-header ' + view.widgetHeaderClass + '">' +
					'<span class="fc-close ' +
					(isTheme ? 'ui-icon ui-icon-closethick' : 'fc-icon fc-icon-x') +
					'"></span>' +
					'<span class="fc-title">' +
					htmlEscape(title) +
					'</span>' +
					'<div class="fc-clear"/>' +
					'</div>' +
					'<div class="fc-body ' + view.widgetContentClass + '">' +
					'<div class="fc-event-container"></div>' +
					'</div>'
				);
				var segContainer = content.find('.fc-event-container');
				var i;

				// render each seg's `el` and only return the visible segs
				segs = this.renderFgSegEls(segs, true); // disableResizing=true
				this.popoverSegs = segs;

				for (i = 0; i < segs.length; i++) {

					// because segments in the popover are not part of a grid coordinate system, provide a hint to any
					// grids that want to do drag-n-drop about which cell it came from
					this.prepareHits();
					segs[i].hit = this.getCellHit(row, col);
					this.releaseHits();

					segContainer.append(segs[i].el);
				}

				return content;
			},


			// Given the events within an array of segment objects, reslice them to be in a single day
			resliceDaySegs: function (segs, dayDate) {

				// build an array of the original events
				var events = $.map(segs, function (seg) {
					return seg.event;
				});

				var dayStart = dayDate.clone();
				var dayEnd = dayStart.clone().add(1, 'days');
				var dayRange = {start: dayStart, end: dayEnd};

				// slice the events with a custom slicing function
				segs = this.eventsToSegs(
					events,
					function (range) {
						var seg = intersectRanges(range, dayRange); // undefind if no intersection
						return seg ? [seg] : []; // must return an array of segments
					}
				);

				// force an order because eventsToSegs doesn't guarantee one
				this.sortEventSegs(segs);

				return segs;
			},


			// Generates the text that should be inside a "more" link, given the number of events it represents
			getMoreLinkText: function (num) {
				var opt = this.view.opt('eventLimitText');

				if (typeof opt === 'function') {
					return opt(num);
				}
				else {
					return '+' + num + ' ' + opt;
				}
			},


			// Returns segments within a given cell.
			// If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.
			getCellSegs: function (row, col, startLevel) {
				var segMatrix = this.rowStructs[row].segMatrix;
				var level = startLevel || 0;
				var segs = [];
				var seg;

				while (level < segMatrix.length) {
					seg = segMatrix[level][col];
					if (seg) {
						segs.push(seg);
					}
					level++;
				}

				return segs;
			}

		});

		;
		;

		/* A component that renders one or more columns of vertical time slots
		 ----------------------------------------------------------------------------------------------------------------------*/
// We mixin DayTable, even though there is only a single row of days

		var TimeGrid = FC.TimeGrid = Grid.extend(DayTableMixin, {

			slotDuration: null, // duration of a "slot", a distinct time segment on given day, visualized by lines
			snapDuration: null, // granularity of time for dragging and selecting
			snapsPerSlot: null,
			minTime: null, // Duration object that denotes the first visible time of any given day
			maxTime: null, // Duration object that denotes the exclusive visible end time of any given day
			labelFormat: null, // formatting string for times running along vertical axis
			labelInterval: null, // duration of how often a label should be displayed for a slot

			colEls: null, // cells elements in the day-row background
			slatEls: null, // elements running horizontally across all columns
			helperEl: null, // cell skeleton element for rendering the mock event "helper"

			colCoordCache: null,
			slatCoordCache: null,

			businessHourSegs: null,


			constructor: function () {
				Grid.apply(this, arguments); // call the super-constructor

				this.processOptions();
			},


			// Renders the time grid into `this.el`, which should already be assigned.
			// Relies on the view's colCnt. In the future, this component should probably be self-sufficient.
			renderDates: function () {
				this.el.html(this.renderHtml());
				this.colEls = this.el.find('.fc-day');
				this.slatEls = this.el.find('.fc-slats tr');

				this.colCoordCache = new CoordCache({
					els: this.colEls,
					isHorizontal: true
				});
				this.slatCoordCache = new CoordCache({
					els: this.slatEls,
					isVertical: true
				});
			},


			renderBusinessHours: function () {
				var events = this.view.calendar.getBusinessHoursEvents();
				this.businessHourSegs = this.renderFill('businessHours', this.eventsToSegs(events), 'bgevent');
			},


			// Renders the basic HTML skeleton for the grid
			renderHtml: function () {
				return '' +
					'<div class="fc-bg">' +
					'<table>' +
					this.renderBgTrHtml(0) + // row=0
					'</table>' +
					'</div>' +
					'<div class="fc-slats">' +
					'<table>' +
					this.renderSlatRowHtml() +
					'</table>' +
					'</div>';
			},


			// Generates the HTML for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
			renderSlatRowHtml: function () {
				var view = this.view;
				var isRTL = this.isRTL;
				var html = '';
				var slotTime = moment.duration(+this.minTime); // wish there was .clone() for durations
				var slotDate; // will be on the view's first day, but we only care about its time
				var isLabeled;
				var axisHtml;

				// Calculate the time for each slot
				while (slotTime < this.maxTime) {
					slotDate = this.start.clone().time(slotTime);
					isLabeled = isInt(divideDurationByDuration(slotTime, this.labelInterval));

					axisHtml =
						'<td class="fc-axis fc-time ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '>' +
						(isLabeled ?
							'<span>' + // for matchCellWidths
							htmlEscape(slotDate.format(this.labelFormat)) +
							'</span>' :
								''
						) +
						'</td>';

					html +=
						'<tr ' + (isLabeled ? '' : 'class="fc-minor"') + '>' +
						(!isRTL ? axisHtml : '') +
						'<td class="' + view.widgetContentClass + '"/>' +
						(isRTL ? axisHtml : '') +
						"</tr>";

					slotTime.add(this.slotDuration);
				}

				return html;
			},


			/* Options
			 ------------------------------------------------------------------------------------------------------------------*/


			// Parses various options into properties of this object
			processOptions: function () {
				var view = this.view;
				var slotDuration = view.opt('slotDuration');
				var snapDuration = view.opt('snapDuration');
				var input;

				slotDuration = moment.duration(slotDuration);
				snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;

				this.slotDuration = slotDuration;
				this.snapDuration = snapDuration;
				this.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?

				this.minResizeDuration = snapDuration; // hack

				this.minTime = moment.duration(view.opt('minTime'));
				this.maxTime = moment.duration(view.opt('maxTime'));

				// might be an array value (for TimelineView).
				// if so, getting the most granular entry (the last one probably).
				input = view.opt('slotLabelFormat');
				if ($.isArray(input)) {
					input = input[input.length - 1];
				}

				this.labelFormat =
					input ||
					view.opt('axisFormat') || // deprecated
					view.opt('smallTimeFormat'); // the computed default

				input = view.opt('slotLabelInterval');
				this.labelInterval = input ?
					moment.duration(input) :
					this.computeLabelInterval(slotDuration);
			},


			// Computes an automatic value for slotLabelInterval
			computeLabelInterval: function (slotDuration) {
				var i;
				var labelInterval;
				var slotsPerLabel;

				// find the smallest stock label interval that results in more than one slots-per-label
				for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {
					labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);
					slotsPerLabel = divideDurationByDuration(labelInterval, slotDuration);
					if (isInt(slotsPerLabel) && slotsPerLabel > 1) {
						return labelInterval;
					}
				}

				return moment.duration(slotDuration); // fall back. clone
			},


			// Computes a default event time formatting string if `timeFormat` is not explicitly defined
			computeEventTimeFormat: function () {
				return this.view.opt('noMeridiemTimeFormat'); // like "6:30" (no AM/PM)
			},


			// Computes a default `displayEventEnd` value if one is not expliclty defined
			computeDisplayEventEnd: function () {
				return true;
			},


			/* Hit System
			 ------------------------------------------------------------------------------------------------------------------*/


			prepareHits: function () {
				this.colCoordCache.build();
				this.slatCoordCache.build();
			},


			releaseHits: function () {
				this.colCoordCache.clear();
				// NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop
			},


			queryHit: function (leftOffset, topOffset) {
				var snapsPerSlot = this.snapsPerSlot;
				var colCoordCache = this.colCoordCache;
				var slatCoordCache = this.slatCoordCache;
				var colIndex = colCoordCache.getHorizontalIndex(leftOffset);
				var slatIndex = slatCoordCache.getVerticalIndex(topOffset);

				if (colIndex != null && slatIndex != null) {
					var slatTop = slatCoordCache.getTopOffset(slatIndex);
					var slatHeight = slatCoordCache.getHeight(slatIndex);
					var partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1
					var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat
					var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
					var snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;
					var snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;

					return {
						col: colIndex,
						snap: snapIndex,
						component: this, // needed unfortunately :(
						left: colCoordCache.getLeftOffset(colIndex),
						right: colCoordCache.getRightOffset(colIndex),
						top: snapTop,
						bottom: snapBottom
					};
				}
			},


			getHitSpan: function (hit) {
				var start = this.getCellDate(0, hit.col); // row=0
				var time = this.computeSnapTime(hit.snap); // pass in the snap-index
				var end;

				start.time(time);
				end = start.clone().add(this.snapDuration);

				return {start: start, end: end};
			},


			getHitEl: function (hit) {
				return this.colEls.eq(hit.col);
			},


			/* Dates
			 ------------------------------------------------------------------------------------------------------------------*/


			rangeUpdated: function () {
				this.updateDayTable();
			},


			// Given a row number of the grid, representing a "snap", returns a time (Duration) from its start-of-day
			computeSnapTime: function (snapIndex) {
				return moment.duration(this.minTime + this.snapDuration * snapIndex);
			},


			// Slices up the given span (unzoned start/end with other misc data) into an array of segments
			spanToSegs: function (span) {
				var segs = this.sliceRangeByTimes(span);
				var i;

				for (i = 0; i < segs.length; i++) {
					if (this.isRTL) {
						segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;
					}
					else {
						segs[i].col = segs[i].dayIndex;
					}
				}

				return segs;
			},


			sliceRangeByTimes: function (range) {
				var segs = [];
				var seg;
				var dayIndex;
				var dayDate;
				var dayRange;

				for (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {
					dayDate = this.dayDates[dayIndex].clone(); // TODO: better API for this?
					dayRange = {
						start: dayDate.clone().time(this.minTime),
						end: dayDate.clone().time(this.maxTime)
					};
					seg = intersectRanges(range, dayRange); // both will be ambig timezone
					if (seg) {
						seg.dayIndex = dayIndex;
						segs.push(seg);
					}
				}

				return segs;
			},


			/* Coordinates
			 ------------------------------------------------------------------------------------------------------------------*/


			updateSize: function (isResize) { // NOT a standard Grid method
				this.slatCoordCache.build();

				if (isResize) {
					this.updateSegVerticals();
				}
			},


			// Computes the top coordinate, relative to the bounds of the grid, of the given date.
			// A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
			computeDateTop: function (date, startOfDayDate) {
				return this.computeTimeTop(
					moment.duration(
						date - startOfDayDate.clone().stripTime()
					)
				);
			},


			// Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
			computeTimeTop: function (time) {
				var len = this.slatEls.length;
				var slatCoverage = (time - this.minTime) / this.slotDuration; // floating-point value of # of slots covered
				var slatIndex;
				var slatRemainder;

				// compute a floating-point number for how many slats should be progressed through.
				// from 0 to number of slats (inclusive)
				// constrained because minTime/maxTime might be customized.
				slatCoverage = Math.max(0, slatCoverage);
				slatCoverage = Math.min(len, slatCoverage);

				// an integer index of the furthest whole slat
				// from 0 to number slats (*exclusive*, so len-1)
				slatIndex = Math.floor(slatCoverage);
				slatIndex = Math.min(slatIndex, len - 1);

				// how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
				// could be 1.0 if slatCoverage is covering *all* the slots
				slatRemainder = slatCoverage - slatIndex;

				return this.slatCoordCache.getTopPosition(slatIndex) +
					this.slatCoordCache.getHeight(slatIndex) * slatRemainder;
			},


			/* Event Drag Visualization
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders a visual indication of an event being dragged over the specified date(s).
			// A returned value of `true` signals that a mock "helper" event has been rendered.
			renderDrag: function (eventLocation, seg) {

				if (seg) { // if there is event information for this drag, render a helper event
					this.renderEventLocationHelper(eventLocation, seg);
					this.applyDragOpacity(this.helperEl);

					return true; // signal that a helper has been rendered
				}
				else {
					// otherwise, just render a highlight
					this.renderHighlight(this.eventToSpan(eventLocation));
				}
			},


			// Unrenders any visual indication of an event being dragged
			unrenderDrag: function () {
				this.unrenderHelper();
				this.unrenderHighlight();
			},


			/* Event Resize Visualization
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders a visual indication of an event being resized
			renderEventResize: function (eventLocation, seg) {
				this.renderEventLocationHelper(eventLocation, seg);
			},


			// Unrenders any visual indication of an event being resized
			unrenderEventResize: function () {
				this.unrenderHelper();
			},


			/* Event Helper
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders a mock "helper" event. `sourceSeg` is the original segment object and might be null (an external drag)
			renderHelper: function (event, sourceSeg) {
				var segs = this.eventToSegs(event);
				var tableEl;
				var i, seg;
				var sourceEl;

				segs = this.renderFgSegEls(segs); // assigns each seg's el and returns a subset of segs that were rendered
				tableEl = this.renderSegTable(segs);

				// Try to make the segment that is in the same row as sourceSeg look the same
				for (i = 0; i < segs.length; i++) {
					seg = segs[i];
					if (sourceSeg && sourceSeg.col === seg.col) {
						sourceEl = sourceSeg.el;
						seg.el.css({
							left: sourceEl.css('left'),
							right: sourceEl.css('right'),
							'margin-left': sourceEl.css('margin-left'),
							'margin-right': sourceEl.css('margin-right')
						});
					}
				}

				this.helperEl = $('<div class="fc-helper-skeleton"/>')
					.append(tableEl)
					.appendTo(this.el);
			},


			// Unrenders any mock helper event
			unrenderHelper: function () {
				if (this.helperEl) {
					this.helperEl.remove();
					this.helperEl = null;
				}
			},


			/* Selection
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.
			renderSelection: function (span) {
				if (this.view.opt('selectHelper')) { // this setting signals that a mock helper event should be rendered

					// normally acceps an eventLocation, span has a start/end, which is good enough
					this.renderEventLocationHelper(span);
				}
				else {
					this.renderHighlight(span);
				}
			},


			// Unrenders any visual indication of a selection
			unrenderSelection: function () {
				this.unrenderHelper();
				this.unrenderHighlight();
			},


			/* Fill System (highlight, background events, business hours)
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders a set of rectangles over the given time segments.
			// Only returns segments that successfully rendered.
			renderFill: function (type, segs, className) {
				var segCols;
				var skeletonEl;
				var trEl;
				var col, colSegs;
				var tdEl;
				var containerEl;
				var dayDate;
				var i, seg;

				if (segs.length) {

					segs = this.renderFillSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs
					segCols = this.groupSegCols(segs); // group into sub-arrays, and assigns 'col' to each seg

					className = className || type.toLowerCase();
					skeletonEl = $(
						'<div class="fc-' + className + '-skeleton">' +
						'<table><tr/></table>' +
						'</div>'
					);
					trEl = skeletonEl.find('tr');

					for (col = 0; col < segCols.length; col++) {
						colSegs = segCols[col];
						tdEl = $('<td/>').appendTo(trEl);

						if (colSegs.length) {
							containerEl = $('<div class="fc-' + className + '-container"/>').appendTo(tdEl);
							dayDate = this.getCellDate(0, col); // row=0

							for (i = 0; i < colSegs.length; i++) {
								seg = colSegs[i];
								containerEl.append(
									seg.el.css({
										top: this.computeDateTop(seg.start, dayDate),
										bottom: -this.computeDateTop(seg.end, dayDate) // the y position of the bottom edge
									})
								);
							}
						}
					}

					this.bookendCells(trEl);

					this.el.append(skeletonEl);
					this.elsByFill[type] = skeletonEl;
				}

				return segs;
			}

		});

		;
		;

		/* Event-rendering methods for the TimeGrid class
		 ----------------------------------------------------------------------------------------------------------------------*/

		TimeGrid.mixin({

			eventSkeletonEl: null, // has cells with event-containers, which contain absolutely positioned event elements


			// Renders the given foreground event segments onto the grid
			renderFgSegs: function (segs) {
				segs = this.renderFgSegEls(segs); // returns a subset of the segs. segs that were actually rendered

				this.el.append(
					this.eventSkeletonEl = $('<div class="fc-content-skeleton"/>')
						.append(this.renderSegTable(segs))
				);

				return segs; // return only the segs that were actually rendered
			},


			// Unrenders all currently rendered foreground event segments
			unrenderFgSegs: function (segs) {
				if (this.eventSkeletonEl) {
					this.eventSkeletonEl.remove();
					this.eventSkeletonEl = null;
				}
			},


			// Renders and returns the <table> portion of the event-skeleton.
			// Returns an object with properties 'tbodyEl' and 'segs'.
			renderSegTable: function (segs) {
				var tableEl = $('<table><tr/></table>');
				var trEl = tableEl.find('tr');
				var segCols;
				var i, seg;
				var col, colSegs;
				var containerEl;

				segCols = this.groupSegCols(segs); // group into sub-arrays, and assigns 'col' to each seg

				this.computeSegVerticals(segs); // compute and assign top/bottom

				for (col = 0; col < segCols.length; col++) { // iterate each column grouping
					colSegs = segCols[col];
					this.placeSlotSegs(colSegs); // compute horizontal coordinates, z-index's, and reorder the array

					containerEl = $('<div class="fc-event-container"/>');

					// assign positioning CSS and insert into container
					for (i = 0; i < colSegs.length; i++) {
						seg = colSegs[i];
						seg.el.css(this.generateSegPositionCss(seg));

						// if the height is short, add a className for alternate styling
						if (seg.bottom - seg.top < 30) {
							seg.el.addClass('fc-short');
						}

						containerEl.append(seg.el);
					}

					trEl.append($('<td/>').append(containerEl));
				}

				this.bookendCells(trEl);

				return tableEl;
			},


			// Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
			// NOTE: Also reorders the given array by date!
			placeSlotSegs: function (segs) {
				var levels;
				var level0;
				var i;

				this.sortEventSegs(segs); // order by certain criteria
				levels = buildSlotSegLevels(segs);
				computeForwardSlotSegs(levels);

				if ((level0 = levels[0])) {

					for (i = 0; i < level0.length; i++) {
						computeSlotSegPressures(level0[i]);
					}

					for (i = 0; i < level0.length; i++) {
						this.computeSlotSegCoords(level0[i], 0, 0);
					}
				}
			},


			// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
			// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
			// seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
			//
			// The segment might be part of a "series", which means consecutive segments with the same pressure
			// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
			// segments behind this one in the current series, and `seriesBackwardCoord` is the starting
			// coordinate of the first segment in the series.
			computeSlotSegCoords: function (seg, seriesBackwardPressure, seriesBackwardCoord) {
				var forwardSegs = seg.forwardSegs;
				var i;

				if (seg.forwardCoord === undefined) { // not already computed

					if (!forwardSegs.length) {

						// if there are no forward segments, this segment should butt up against the edge
						seg.forwardCoord = 1;
					}
					else {

						// sort highest pressure first
						this.sortForwardSlotSegs(forwardSegs);

						// this segment's forwardCoord will be calculated from the backwardCoord of the
						// highest-pressure forward segment.
						this.computeSlotSegCoords(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
						seg.forwardCoord = forwardSegs[0].backwardCoord;
					}

					// calculate the backwardCoord from the forwardCoord. consider the series
					seg.backwardCoord = seg.forwardCoord -
						(seg.forwardCoord - seriesBackwardCoord) / // available width for series
						(seriesBackwardPressure + 1); // # of segments in the series

					// use this segment's coordinates to computed the coordinates of the less-pressurized
					// forward segments
					for (i = 0; i < forwardSegs.length; i++) {
						this.computeSlotSegCoords(forwardSegs[i], 0, seg.forwardCoord);
					}
				}
			},


			// Refreshes the CSS top/bottom coordinates for each segment element. Probably after a window resize/zoom.
			// Repositions business hours segs too, so not just for events. Maybe shouldn't be here.
			updateSegVerticals: function () {
				var allSegs = (this.segs || []).concat(this.businessHourSegs || []);
				var i;

				this.computeSegVerticals(allSegs);

				for (i = 0; i < allSegs.length; i++) {
					allSegs[i].el.css(
						this.generateSegVerticalCss(allSegs[i])
					);
				}
			},


			// For each segment in an array, computes and assigns its top and bottom properties
			computeSegVerticals: function (segs) {
				var i, seg;

				for (i = 0; i < segs.length; i++) {
					seg = segs[i];
					seg.top = this.computeDateTop(seg.start, seg.start);
					seg.bottom = this.computeDateTop(seg.end, seg.start);
				}
			},


			// Renders the HTML for a single event segment's default rendering
			fgSegHtml: function (seg, disableResizing) {
				var view = this.view;
				var event = seg.event;
				var isDraggable = view.isEventDraggable(event);
				var isResizableFromStart = !disableResizing && seg.isStart && view.isEventResizableFromStart(event);
				var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventResizableFromEnd(event);
				var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
				var skinCss = cssToStr(this.getEventSkinCss(event));
				var timeText;
				var fullTimeText; // more verbose time text. for the print stylesheet
				var startTimeText; // just the start time text

				classes.unshift('fc-time-grid-event', 'fc-v-event');

				if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day...
					// Don't display time text on segments that run entirely through a day.
					// That would appear as midnight-midnight and would look dumb.
					// Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
					if (seg.isStart || seg.isEnd) {
						timeText = this.getEventTimeText(seg);
						fullTimeText = this.getEventTimeText(seg, 'LT');
						startTimeText = this.getEventTimeText(seg, null, false); // displayEnd=false
					}
				} else {
					// Display the normal time text for the *event's* times
					timeText = this.getEventTimeText(event);
					fullTimeText = this.getEventTimeText(event, 'LT');
					startTimeText = this.getEventTimeText(event, null, false); // displayEnd=false
				}

				return '<a class="' + classes.join(' ') + '"' +
					(event.url ?
						' href="' + htmlEscape(event.url) + '"' :
							''
					) +
					(skinCss ?
						' style="' + skinCss + '"' :
							''
					) +
					'>' +
					'<div class="fc-content">' +
					(timeText ?
						'<div class="fc-time"' +
						' data-start="' + htmlEscape(startTimeText) + '"' +
						' data-full="' + htmlEscape(fullTimeText) + '"' +
						'>' +
						'<span>' + htmlEscape(timeText) + '</span>' +
						'</div>' :
							''
					) +
					(event.title ?
						'<div class="fc-title">' +
						htmlEscape(event.title) +
						'</div>' :
							''
					) +
					'</div>' +
					'<div class="fc-bg"/>' +
						/* TODO: write CSS for this
						 (isResizableFromStart ?
						 '<div class="fc-resizer fc-start-resizer" />' :
						 ''
						 ) +
						 */
					(isResizableFromEnd ?
							'<div class="fc-resizer fc-end-resizer" />' :
							''
					) +
					'</a>';
			},


			// Generates an object with CSS properties/values that should be applied to an event segment element.
			// Contains important positioning-related properties that should be applied to any event element, customized or not.
			generateSegPositionCss: function (seg) {
				var shouldOverlap = this.view.opt('slotEventOverlap');
				var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point
				var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point
				var props = this.generateSegVerticalCss(seg); // get top/bottom first
				var left; // amount of space from left edge, a fraction of the total width
				var right; // amount of space from right edge, a fraction of the total width

				if (shouldOverlap) {
					// double the width, but don't go beyond the maximum forward coordinate (1.0)
					forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
				}

				if (this.isRTL) {
					left = 1 - forwardCoord;
					right = backwardCoord;
				}
				else {
					left = backwardCoord;
					right = 1 - forwardCoord;
				}

				props.zIndex = seg.level + 1; // convert from 0-base to 1-based
				props.left = left * 100 + '%';
				props.right = right * 100 + '%';

				if (shouldOverlap && seg.forwardPressure) {
					// add padding to the edge so that forward stacked events don't cover the resizer's icon
					props[this.isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
				}

				return props;
			},


			// Generates an object with CSS properties for the top/bottom coordinates of a segment element
			generateSegVerticalCss: function (seg) {
				return {
					top: seg.top,
					bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container
				};
			},


			// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col
			groupSegCols: function (segs) {
				var segCols = [];
				var i;

				for (i = 0; i < this.colCnt; i++) {
					segCols.push([]);
				}

				for (i = 0; i < segs.length; i++) {
					segCols[segs[i].col].push(segs[i]);
				}

				return segCols;
			},


			sortForwardSlotSegs: function (forwardSegs) {
				forwardSegs.sort(proxy(this, 'compareForwardSlotSegs'));
			},


			// A cmp function for determining which forward segment to rely on more when computing coordinates.
			compareForwardSlotSegs: function (seg1, seg2) {
				// put higher-pressure first
				return seg2.forwardPressure - seg1.forwardPressure ||
						// put segments that are closer to initial edge first (and favor ones with no coords yet)
					(seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||
						// do normal sorting...
					this.compareEventSegs(seg1, seg2);
			}

		});


// Builds an array of segments "levels". The first level will be the leftmost tier of segments if the calendar is
// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.
		function buildSlotSegLevels(segs) {
			var levels = [];
			var i, seg;
			var j;

			for (i = 0; i < segs.length; i++) {
				seg = segs[i];

				// go through all the levels and stop on the first level where there are no collisions
				for (j = 0; j < levels.length; j++) {
					if (!computeSlotSegCollisions(seg, levels[j]).length) {
						break;
					}
				}

				seg.level = j;

				(levels[j] || (levels[j] = [])).push(seg);
			}

			return levels;
		}


// For every segment, figure out the other segments that are in subsequent
// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
		function computeForwardSlotSegs(levels) {
			var i, level;
			var j, seg;
			var k;

			for (i = 0; i < levels.length; i++) {
				level = levels[i];

				for (j = 0; j < level.length; j++) {
					seg = level[j];

					seg.forwardSegs = [];
					for (k = i + 1; k < levels.length; k++) {
						computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
					}
				}
			}
		}


// Figure out which path forward (via seg.forwardSegs) results in the longest path until
// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
		function computeSlotSegPressures(seg) {
			var forwardSegs = seg.forwardSegs;
			var forwardPressure = 0;
			var i, forwardSeg;

			if (seg.forwardPressure === undefined) { // not already computed

				for (i = 0; i < forwardSegs.length; i++) {
					forwardSeg = forwardSegs[i];

					// figure out the child's maximum forward path
					computeSlotSegPressures(forwardSeg);

					// either use the existing maximum, or use the child's forward pressure
					// plus one (for the forwardSeg itself)
					forwardPressure = Math.max(
						forwardPressure,
						1 + forwardSeg.forwardPressure
					);
				}

				seg.forwardPressure = forwardPressure;
			}
		}


// Find all the segments in `otherSegs` that vertically collide with `seg`.
// Append into an optionally-supplied `results` array and return.
		function computeSlotSegCollisions(seg, otherSegs, results) {
			results = results || [];

			for (var i = 0; i < otherSegs.length; i++) {
				if (isSlotSegCollision(seg, otherSegs[i])) {
					results.push(otherSegs[i]);
				}
			}

			return results;
		}


// Do these segments occupy the same vertical space?
		function isSlotSegCollision(seg1, seg2) {
			return seg1.bottom > seg2.top && seg1.top < seg2.bottom;
		}

		;
		;

		/* An abstract class from which other views inherit from
		 ----------------------------------------------------------------------------------------------------------------------*/

		var View = FC.View = Class.extend({

			type: null, // subclass' view name (string)
			name: null, // deprecated. use `type` instead
			title: null, // the text that will be displayed in the header's title

			calendar: null, // owner Calendar object
			options: null, // hash containing all options. already merged with view-specific-options
			el: null, // the view's containing element. set by Calendar

			displaying: null, // a promise representing the state of rendering. null if no render requested
			isSkeletonRendered: false,
			isEventsRendered: false,

			// range the view is actually displaying (moments)
			start: null,
			end: null, // exclusive

			// range the view is formally responsible for (moments)
			// may be different from start/end. for example, a month view might have 1st-31st, excluding padded dates
			intervalStart: null,
			intervalEnd: null, // exclusive
			intervalDuration: null,
			intervalUnit: null, // name of largest unit being displayed, like "month" or "week"

			isRTL: false,
			isSelected: false, // boolean whether a range of time is user-selected or not

			eventOrderSpecs: null, // criteria for ordering events when they have same date/time

			// subclasses can optionally use a scroll container
			scrollerEl: null, // the element that will most likely scroll when content is too tall
			scrollTop: null, // cached vertical scroll value

			// classNames styled by jqui themes
			widgetHeaderClass: null,
			widgetContentClass: null,
			highlightStateClass: null,

			// for date utils, computed from options
			nextDayThreshold: null,
			isHiddenDayHash: null,

			// document handlers, bound to `this` object
			documentMousedownProxy: null, // TODO: doesn't work with touch


			constructor: function (calendar, type, options, intervalDuration) {

				this.calendar = calendar;
				this.type = this.name = type; // .name is deprecated
				this.options = options;
				this.intervalDuration = intervalDuration || moment.duration(1, 'day');

				this.nextDayThreshold = moment.duration(this.opt('nextDayThreshold'));
				this.initThemingProps();
				this.initHiddenDays();
				this.isRTL = this.opt('isRTL');

				this.eventOrderSpecs = parseFieldSpecs(this.opt('eventOrder'));

				this.documentMousedownProxy = proxy(this, 'documentMousedown');

				this.initialize();
			},


			// A good place for subclasses to initialize member variables
			initialize: function () {
				// subclasses can implement
			},


			// Retrieves an option with the given name
			opt: function (name) {
				return this.options[name];
			},


			// Triggers handlers that are view-related. Modifies args before passing to calendar.
			trigger: function (name, thisObj) { // arguments beyond thisObj are passed along
				var calendar = this.calendar;

				return calendar.trigger.apply(
					calendar,
					[name, thisObj || this].concat(
						Array.prototype.slice.call(arguments, 2), // arguments beyond thisObj
						[this] // always make the last argument a reference to the view. TODO: deprecate
					)
				);
			},


			/* Dates
			 ------------------------------------------------------------------------------------------------------------------*/


			// Updates all internal dates to center around the given current unzoned date.
			setDate: function (date) {
				this.setRange(this.computeRange(date));
			},


			// Updates all internal dates for displaying the given unzoned range.
			setRange: function (range) {
				$.extend(this, range); // assigns every property to this object's member variables
				this.updateTitle();
			},


			// Given a single current unzoned date, produce information about what range to display.
			// Subclasses can override. Must return all properties.
			computeRange: function (date) {
				var intervalUnit = computeIntervalUnit(this.intervalDuration);
				var intervalStart = date.clone().startOf(intervalUnit);
				var intervalEnd = intervalStart.clone().add(this.intervalDuration);
				var start, end;

				// normalize the range's time-ambiguity
				if (/year|month|week|day/.test(intervalUnit)) { // whole-days?
					intervalStart.stripTime();
					intervalEnd.stripTime();
				}
				else { // needs to have a time?
					if (!intervalStart.hasTime()) {
						intervalStart = this.calendar.time(0); // give 00:00 time
					}
					if (!intervalEnd.hasTime()) {
						intervalEnd = this.calendar.time(0); // give 00:00 time
					}
				}

				start = intervalStart.clone();
				start = this.skipHiddenDays(start);
				end = intervalEnd.clone();
				end = this.skipHiddenDays(end, -1, true); // exclusively move backwards

				return {
					intervalUnit: intervalUnit,
					intervalStart: intervalStart,
					intervalEnd: intervalEnd,
					start: start,
					end: end
				};
			},


			// Computes the new date when the user hits the prev button, given the current date
			computePrevDate: function (date) {
				return this.massageCurrentDate(
					date.clone().startOf(this.intervalUnit).subtract(this.intervalDuration), -1
				);
			},


			// Computes the new date when the user hits the next button, given the current date
			computeNextDate: function (date) {
				return this.massageCurrentDate(
					date.clone().startOf(this.intervalUnit).add(this.intervalDuration)
				);
			},


			// Given an arbitrarily calculated current date of the calendar, returns a date that is ensured to be completely
			// visible. `direction` is optional and indicates which direction the current date was being
			// incremented or decremented (1 or -1).
			massageCurrentDate: function (date, direction) {
				if (this.intervalDuration.as('days') <= 1) { // if the view displays a single day or smaller
					if (this.isHiddenDay(date)) {
						date = this.skipHiddenDays(date, direction);
						date.startOf('day');
					}
				}

				return date;
			},


			/* Title and Date Formatting
			 ------------------------------------------------------------------------------------------------------------------*/


			// Sets the view's title property to the most updated computed value
			updateTitle: function () {
				this.title = this.computeTitle();
			},


			// Computes what the title at the top of the calendar should be for this view
			computeTitle: function () {
				return this.formatRange(
					{
						// in case intervalStart/End has a time, make sure timezone is correct
						start: this.calendar.applyTimezone(this.intervalStart),
						end: this.calendar.applyTimezone(this.intervalEnd)
					},
					this.opt('titleFormat') || this.computeTitleFormat(),
					this.opt('titleRangeSeparator')
				);
			},


			// Generates the format string that should be used to generate the title for the current date range.
			// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
			computeTitleFormat: function () {
				if (this.intervalUnit == 'year') {
					return 'YYYY';
				}
				else if (this.intervalUnit == 'month') {
					return this.opt('monthYearFormat'); // like "September 2014"
				}
				else if (this.intervalDuration.as('days') > 1) {
					return 'll'; // multi-day range. shorter, like "Sep 9 - 10 2014"
				}
				else {
					return 'LL'; // one day. longer, like "September 9 2014"
				}
			},


			// Utility for formatting a range. Accepts a range object, formatting string, and optional separator.
			// Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.
			// The timezones of the dates within `range` will be respected.
			formatRange: function (range, formatStr, separator) {
				var end = range.end;

				if (!end.hasTime()) { // all-day?
					end = end.clone().subtract(1); // convert to inclusive. last ms of previous day
				}

				return formatRange(range.start, end, formatStr, separator, this.opt('isRTL'));
			},


			/* Rendering
			 ------------------------------------------------------------------------------------------------------------------*/


			// Sets the container element that the view should render inside of.
			// Does other DOM-related initializations.
			setElement: function (el) {
				this.el = el;
				this.bindGlobalHandlers();
			},


			// Removes the view's container element from the DOM, clearing any content beforehand.
			// Undoes any other DOM-related attachments.
			removeElement: function () {
				this.clear(); // clears all content

				// clean up the skeleton
				if (this.isSkeletonRendered) {
					this.unrenderSkeleton();
					this.isSkeletonRendered = false;
				}

				this.unbindGlobalHandlers();

				this.el.remove();

				// NOTE: don't null-out this.el in case the View was destroyed within an API callback.
				// We don't null-out the View's other jQuery element references upon destroy,
				//  so we shouldn't kill this.el either.
			},


			// Does everything necessary to display the view centered around the given unzoned date.
			// Does every type of rendering EXCEPT rendering events.
			// Is asychronous and returns a promise.
			display: function (date) {
				var _this = this;
				var scrollState = null;

				if (this.displaying) {
					scrollState = this.queryScroll();
				}

				this.calendar.freezeContentHeight();

				return this.clear().then(function () { // clear the content first (async)
					return (
						_this.displaying =
							$.when(_this.displayView(date)) // displayView might return a promise
								.then(function () {
									_this.forceScroll(_this.computeInitialScroll(scrollState));
									_this.calendar.unfreezeContentHeight();
									_this.triggerRender();
								})
					);
				});
			},


			// Does everything necessary to clear the content of the view.
			// Clears dates and events. Does not clear the skeleton.
			// Is asychronous and returns a promise.
			clear: function () {
				var _this = this;
				var displaying = this.displaying;

				if (displaying) { // previously displayed, or in the process of being displayed?
					return displaying.then(function () { // wait for the display to finish
						_this.displaying = null;
						_this.clearEvents();
						return _this.clearView(); // might return a promise. chain it
					});
				}
				else {
					return $.when(); // an immediately-resolved promise
				}
			},


			// If the view has already been displayed, tears it down and displays it again.
			// Will re-render the events if necessary, which display/clear DO NOT do.
			// TODO: make behavior more consistent.
			redisplay: function () {
				if (this.isSkeletonRendered) {
					var wasEventsRendered = this.isEventsRendered;
					this.clearEvents(); // won't trigger handlers if events never rendered
					this.clearView();
					this.displayView();
					if (wasEventsRendered) { // only render and trigger handlers if events previously rendered
						this.displayEvents();
					}
				}
			},


			// Displays the view's non-event content, such as date-related content or anything required by events.
			// Renders the view's non-content skeleton if necessary.
			// Can be asynchronous and return a promise.
			displayView: function (date) {
				if (!this.isSkeletonRendered) {
					this.renderSkeleton();
					this.isSkeletonRendered = true;
				}
				if (date) {
					this.setDate(date);
				}
				if (this.render) {
					this.render(); // TODO: deprecate
				}
				this.renderDates();
				this.updateSize();
				this.renderBusinessHours(); // might need coordinates, so should go after updateSize()
			},


			// Unrenders the view content that was rendered in displayView.
			// Can be asynchronous and return a promise.
			clearView: function () {
				this.unselect();
				this.triggerUnrender();
				this.unrenderBusinessHours();
				this.unrenderDates();
				if (this.destroy) {
					this.destroy(); // TODO: deprecate
				}
			},


			// Renders the basic structure of the view before any content is rendered
			renderSkeleton: function () {
				// subclasses should implement
			},


			// Unrenders the basic structure of the view
			unrenderSkeleton: function () {
				// subclasses should implement
			},


			// Renders the view's date-related content.
			// Assumes setRange has already been called and the skeleton has already been rendered.
			renderDates: function () {
				// subclasses should implement
			},


			// Unrenders the view's date-related content
			unrenderDates: function () {
				// subclasses should override
			},


			// Renders business-hours onto the view. Assumes updateSize has already been called.
			renderBusinessHours: function () {
				// subclasses should implement
			},


			// Unrenders previously-rendered business-hours
			unrenderBusinessHours: function () {
				// subclasses should implement
			},


			// Signals that the view's content has been rendered
			triggerRender: function () {
				this.trigger('viewRender', this, this, this.el);
			},


			// Signals that the view's content is about to be unrendered
			triggerUnrender: function () {
				this.trigger('viewDestroy', this, this, this.el);
			},


			// Binds DOM handlers to elements that reside outside the view container, such as the document
			bindGlobalHandlers: function () {
				$(document).on('mousedown', this.documentMousedownProxy);
			},


			// Unbinds DOM handlers from elements that reside outside the view container
			unbindGlobalHandlers: function () {
				$(document).off('mousedown', this.documentMousedownProxy);
			},


			// Initializes internal variables related to theming
			initThemingProps: function () {
				var tm = this.opt('theme') ? 'ui' : 'fc';

				this.widgetHeaderClass = tm + '-widget-header';
				this.widgetContentClass = tm + '-widget-content';
				this.highlightStateClass = tm + '-state-highlight';
			},


			/* Dimensions
			 ------------------------------------------------------------------------------------------------------------------*/


			// Refreshes anything dependant upon sizing of the container element of the grid
			updateSize: function (isResize) {
				var scrollState;

				if (isResize) {
					scrollState = this.queryScroll();
				}

				this.updateHeight(isResize);
				this.updateWidth(isResize);

				if (isResize) {
					this.setScroll(scrollState);
				}
			},


			// Refreshes the horizontal dimensions of the calendar
			updateWidth: function (isResize) {
				// subclasses should implement
			},


			// Refreshes the vertical dimensions of the calendar
			updateHeight: function (isResize) {
				var calendar = this.calendar; // we poll the calendar for height information

				this.setHeight(
					calendar.getSuggestedViewHeight(),
					calendar.isHeightAuto()
				);
			},


			// Updates the vertical dimensions of the calendar to the specified height.
			// if `isAuto` is set to true, height becomes merely a suggestion and the view should use its "natural" height.
			setHeight: function (height, isAuto) {
				// subclasses should implement
			},


			/* Scroller
			 ------------------------------------------------------------------------------------------------------------------*/


			// Given the total height of the view, return the number of pixels that should be used for the scroller.
			// Utility for subclasses.
			computeScrollerHeight: function (totalHeight) {
				var scrollerEl = this.scrollerEl;
				var both;
				var otherHeight; // cumulative height of everything that is not the scrollerEl in the view (header+borders)

				both = this.el.add(scrollerEl);

				// fuckin IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
				both.css({
					position: 'relative', // cause a reflow, which will force fresh dimension recalculation
					left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll
				});
				otherHeight = this.el.outerHeight() - scrollerEl.height(); // grab the dimensions
				both.css({position: '', left: ''}); // undo hack

				return totalHeight - otherHeight;
			},


			// Computes the initial pre-configured scroll state prior to allowing the user to change it.
			// Given the scroll state from the previous rendering. If first time rendering, given null.
			computeInitialScroll: function (previousScrollState) {
				return 0;
			},


			// Retrieves the view's current natural scroll state. Can return an arbitrary format.
			queryScroll: function () {
				if (this.scrollerEl) {
					return this.scrollerEl.scrollTop(); // operates on scrollerEl by default
				}
			},


			// Sets the view's scroll state. Will accept the same format computeInitialScroll and queryScroll produce.
			setScroll: function (scrollState) {
				if (this.scrollerEl) {
					return this.scrollerEl.scrollTop(scrollState); // operates on scrollerEl by default
				}
			},


			// Sets the scroll state, making sure to overcome any predefined scroll value the browser has in mind
			forceScroll: function (scrollState) {
				var _this = this;

				this.setScroll(scrollState);
				setTimeout(function () {
					_this.setScroll(scrollState);
				}, 0);
			},


			/* Event Elements / Segments
			 ------------------------------------------------------------------------------------------------------------------*/


			// Does everything necessary to display the given events onto the current view
			displayEvents: function (events) {
				var scrollState = this.queryScroll();

				this.clearEvents();
				this.renderEvents(events);
				this.isEventsRendered = true;
				this.setScroll(scrollState);
				this.triggerEventRender();
			},


			// Does everything necessary to clear the view's currently-rendered events
			clearEvents: function () {
				if (this.isEventsRendered) {
					this.triggerEventUnrender();
					if (this.destroyEvents) {
						this.destroyEvents(); // TODO: deprecate
					}
					this.unrenderEvents();
					this.isEventsRendered = false;
				}
			},


			// Renders the events onto the view.
			renderEvents: function (events) {
				// subclasses should implement
			},


			// Removes event elements from the view.
			unrenderEvents: function () {
				// subclasses should implement
			},


			// Signals that all events have been rendered
			triggerEventRender: function () {
				this.renderedEventSegEach(function (seg) {
					this.trigger('eventAfterRender', seg.event, seg.event, seg.el);
				});
				this.trigger('eventAfterAllRender');
			},


			// Signals that all event elements are about to be removed
			triggerEventUnrender: function () {
				this.renderedEventSegEach(function (seg) {
					this.trigger('eventDestroy', seg.event, seg.event, seg.el);
				});
			},


			// Given an event and the default element used for rendering, returns the element that should actually be used.
			// Basically runs events and elements through the eventRender hook.
			resolveEventEl: function (event, el) {
				var custom = this.trigger('eventRender', event, event, el);

				if (custom === false) { // means don't render at all
					el = null;
				}
				else if (custom && custom !== true) {
					el = $(custom);
				}

				return el;
			},


			// Hides all rendered event segments linked to the given event
			showEvent: function (event) {
				this.renderedEventSegEach(function (seg) {
					seg.el.css('visibility', '');
				}, event);
			},


			// Shows all rendered event segments linked to the given event
			hideEvent: function (event) {
				this.renderedEventSegEach(function (seg) {
					seg.el.css('visibility', 'hidden');
				}, event);
			},


			// Iterates through event segments that have been rendered (have an el). Goes through all by default.
			// If the optional `event` argument is specified, only iterates through segments linked to that event.
			// The `this` value of the callback function will be the view.
			renderedEventSegEach: function (func, event) {
				var segs = this.getEventSegs();
				var i;

				for (i = 0; i < segs.length; i++) {
					if (!event || segs[i].event._id === event._id) {
						if (segs[i].el) {
							func.call(this, segs[i]);
						}
					}
				}
			},


			// Retrieves all the rendered segment objects for the view
			getEventSegs: function () {
				// subclasses must implement
				return [];
			},


			/* Event Drag-n-Drop
			 ------------------------------------------------------------------------------------------------------------------*/


			// Computes if the given event is allowed to be dragged by the user
			isEventDraggable: function (event) {
				var source = event.source || {};

				return firstDefined(
					event.startEditable,
					source.startEditable,
					this.opt('eventStartEditable'),
					event.editable,
					source.editable,
					this.opt('editable')
				);
			},


			// Must be called when an event in the view is dropped onto new location.
			// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
			reportEventDrop: function (event, dropLocation, largeUnit, el, ev) {
				var calendar = this.calendar;
				var mutateResult = calendar.mutateEvent(event, dropLocation, largeUnit);
				var undoFunc = function () {
					mutateResult.undo();
					calendar.reportEventChange();
				};

				this.triggerEventDrop(event, mutateResult.dateDelta, undoFunc, el, ev);
				calendar.reportEventChange(); // will rerender events
			},


			// Triggers event-drop handlers that have subscribed via the API
			triggerEventDrop: function (event, dateDelta, undoFunc, el, ev) {
				this.trigger('eventDrop', el[0], event, dateDelta, undoFunc, ev, {}); // {} = jqui dummy
			},


			/* External Element Drag-n-Drop
			 ------------------------------------------------------------------------------------------------------------------*/


			// Must be called when an external element, via jQuery UI, has been dropped onto the calendar.
			// `meta` is the parsed data that has been embedded into the dragging event.
			// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
			reportExternalDrop: function (meta, dropLocation, el, ev, ui) {
				var eventProps = meta.eventProps;
				var eventInput;
				var event;

				// Try to build an event object and render it. TODO: decouple the two
				if (eventProps) {
					eventInput = $.extend({}, eventProps, dropLocation);
					event = this.calendar.renderEvent(eventInput, meta.stick)[0]; // renderEvent returns an array
				}

				this.triggerExternalDrop(event, dropLocation, el, ev, ui);
			},


			// Triggers external-drop handlers that have subscribed via the API
			triggerExternalDrop: function (event, dropLocation, el, ev, ui) {

				// trigger 'drop' regardless of whether element represents an event
				this.trigger('drop', el[0], dropLocation.start, ev, ui);

				if (event) {
					this.trigger('eventReceive', null, event); // signal an external event landed
				}
			},


			/* Drag-n-Drop Rendering (for both events and external elements)
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders a visual indication of a event or external-element drag over the given drop zone.
			// If an external-element, seg will be `null`
			renderDrag: function (dropLocation, seg) {
				// subclasses must implement
			},


			// Unrenders a visual indication of an event or external-element being dragged.
			unrenderDrag: function () {
				// subclasses must implement
			},


			/* Event Resizing
			 ------------------------------------------------------------------------------------------------------------------*/


			// Computes if the given event is allowed to be resized from its starting edge
			isEventResizableFromStart: function (event) {
				return this.opt('eventResizableFromStart') && this.isEventResizable(event);
			},


			// Computes if the given event is allowed to be resized from its ending edge
			isEventResizableFromEnd: function (event) {
				return this.isEventResizable(event);
			},


			// Computes if the given event is allowed to be resized by the user at all
			isEventResizable: function (event) {
				var source = event.source || {};

				return firstDefined(
					event.durationEditable,
					source.durationEditable,
					this.opt('eventDurationEditable'),
					event.editable,
					source.editable,
					this.opt('editable')
				);
			},


			// Must be called when an event in the view has been resized to a new length
			reportEventResize: function (event, resizeLocation, largeUnit, el, ev) {
				var calendar = this.calendar;
				var mutateResult = calendar.mutateEvent(event, resizeLocation, largeUnit);
				var undoFunc = function () {
					mutateResult.undo();
					calendar.reportEventChange();
				};

				this.triggerEventResize(event, mutateResult.durationDelta, undoFunc, el, ev);
				calendar.reportEventChange(); // will rerender events
			},


			// Triggers event-resize handlers that have subscribed via the API
			triggerEventResize: function (event, durationDelta, undoFunc, el, ev) {
				this.trigger('eventResize', el[0], event, durationDelta, undoFunc, ev, {}); // {} = jqui dummy
			},


			/* Selection
			 ------------------------------------------------------------------------------------------------------------------*/


			// Selects a date span on the view. `start` and `end` are both Moments.
			// `ev` is the native mouse event that begin the interaction.
			select: function (span, ev) {
				this.unselect(ev);
				this.renderSelection(span);
				this.reportSelection(span, ev);
			},


			// Renders a visual indication of the selection
			renderSelection: function (span) {
				// subclasses should implement
			},


			// Called when a new selection is made. Updates internal state and triggers handlers.
			reportSelection: function (span, ev) {
				this.isSelected = true;
				this.triggerSelect(span, ev);
			},


			// Triggers handlers to 'select'
			triggerSelect: function (span, ev) {
				this.trigger(
					'select',
					null,
					this.calendar.applyTimezone(span.start), // convert to calendar's tz for external API
					this.calendar.applyTimezone(span.end), // "
					ev
				);
			},


			// Undoes a selection. updates in the internal state and triggers handlers.
			// `ev` is the native mouse event that began the interaction.
			unselect: function (ev) {
				if (this.isSelected) {
					this.isSelected = false;
					if (this.destroySelection) {
						this.destroySelection(); // TODO: deprecate
					}
					this.unrenderSelection();
					this.trigger('unselect', null, ev);
				}
			},


			// Unrenders a visual indication of selection
			unrenderSelection: function () {
				// subclasses should implement
			},


			// Handler for unselecting when the user clicks something and the 'unselectAuto' setting is on
			documentMousedown: function (ev) {
				var ignore;

				// is there a selection, and has the user made a proper left click?
				if (this.isSelected && this.opt('unselectAuto') && isPrimaryMouseButton(ev)) {

					// only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element
					ignore = this.opt('unselectCancel');
					if (!ignore || !$(ev.target).closest(ignore).length) {
						this.unselect(ev);
					}
				}
			},


			/* Day Click
			 ------------------------------------------------------------------------------------------------------------------*/


			// Triggers handlers to 'dayClick'
			// Span has start/end of the clicked area. Only the start is useful.
			triggerDayClick: function (span, dayEl, ev) {
				this.trigger(
					'dayClick',
					dayEl,
					this.calendar.applyTimezone(span.start), // convert to calendar's timezone for external API
					ev
				);
			},


			/* Date Utils
			 ------------------------------------------------------------------------------------------------------------------*/


			// Initializes internal variables related to calculating hidden days-of-week
			initHiddenDays: function () {
				var hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden
				var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)
				var dayCnt = 0;
				var i;

				if (this.opt('weekends') === false) {
					hiddenDays.push(0, 6); // 0=sunday, 6=saturday
				}

				for (i = 0; i < 7; i++) {
					if (
						!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)
					) {
						dayCnt++;
					}
				}

				if (!dayCnt) {
					throw 'invalid hiddenDays'; // all days were hidden? bad.
				}

				this.isHiddenDayHash = isHiddenDayHash;
			},


			// Is the current day hidden?
			// `day` is a day-of-week index (0-6), or a Moment
			isHiddenDay: function (day) {
				if (moment.isMoment(day)) {
					day = day.day();
				}
				return this.isHiddenDayHash[day];
			},


			// Incrementing the current day until it is no longer a hidden day, returning a copy.
			// If the initial value of `date` is not a hidden day, don't do anything.
			// Pass `isExclusive` as `true` if you are dealing with an end date.
			// `inc` defaults to `1` (increment one day forward each time)
			skipHiddenDays: function (date, inc, isExclusive) {
				var out = date.clone();
				inc = inc || 1;
				while (
					this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]
					) {
					out.add(inc, 'days');
				}
				return out;
			},


			// Returns the date range of the full days the given range visually appears to occupy.
			// Returns a new range object.
			computeDayRange: function (range) {
				var startDay = range.start.clone().stripTime(); // the beginning of the day the range starts
				var end = range.end;
				var endDay = null;
				var endTimeMS;

				if (end) {
					endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends
					endTimeMS = +end.time(); // # of milliseconds into `endDay`

					// If the end time is actually inclusively part of the next day and is equal to or
					// beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
					// Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
					if (endTimeMS && endTimeMS >= this.nextDayThreshold) {
						endDay.add(1, 'days');
					}
				}

				// If no end was specified, or if it is within `startDay` but not past nextDayThreshold,
				// assign the default duration of one day.
				if (!end || endDay <= startDay) {
					endDay = startDay.clone().add(1, 'days');
				}

				return {start: startDay, end: endDay};
			},


			// Does the given event visually appear to occupy more than one day?
			isMultiDayEvent: function (event) {
				var range = this.computeDayRange(event); // event is range-ish

				return range.end.diff(range.start, 'days') > 1;
			}

		});

		;
		;

		var Calendar = FC.Calendar = Class.extend({

			dirDefaults: null, // option defaults related to LTR or RTL
			langDefaults: null, // option defaults related to current locale
			overrides: null, // option overrides given to the fullCalendar constructor
			options: null, // all defaults combined with overrides
			viewSpecCache: null, // cache of view definitions
			view: null, // current View object
			header: null,
			loadingLevel: 0, // number of simultaneous loading tasks


			// a lot of this class' OOP logic is scoped within this constructor function,
			// but in the future, write individual methods on the prototype.
			constructor: Calendar_constructor,


			// Subclasses can override this for initialization logic after the constructor has been called
			initialize: function () {
			},


			// Initializes `this.options` and other important options-related objects
			initOptions: function (overrides) {
				var lang, langDefaults;
				var isRTL, dirDefaults;

				// converts legacy options into non-legacy ones.
				// in the future, when this is removed, don't use `overrides` reference. make a copy.
				overrides = massageOverrides(overrides);

				lang = overrides.lang;
				langDefaults = langOptionHash[lang];
				if (!langDefaults) {
					lang = Calendar.defaults.lang;
					langDefaults = langOptionHash[lang] || {};
				}

				isRTL = firstDefined(
					overrides.isRTL,
					langDefaults.isRTL,
					Calendar.defaults.isRTL
				);
				dirDefaults = isRTL ? Calendar.rtlDefaults : {};

				this.dirDefaults = dirDefaults;
				this.langDefaults = langDefaults;
				this.overrides = overrides;
				this.options = mergeOptions([ // merge defaults and overrides. lowest to highest precedence
					Calendar.defaults, // global defaults
					dirDefaults,
					langDefaults,
					overrides
				]);
				populateInstanceComputableOptions(this.options);

				this.viewSpecCache = {}; // somewhat unrelated
			},


			// Gets information about how to create a view. Will use a cache.
			getViewSpec: function (viewType) {
				var cache = this.viewSpecCache;

				return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));
			},


			// Given a duration singular unit, like "week" or "day", finds a matching view spec.
			// Preference is given to views that have corresponding buttons.
			getUnitViewSpec: function (unit) {
				var viewTypes;
				var i;
				var spec;

				if ($.inArray(unit, intervalUnits) != -1) {

					// put views that have buttons first. there will be duplicates, but oh well
					viewTypes = this.header.getViewsWithButtons();
					$.each(FC.views, function (viewType) { // all views
						viewTypes.push(viewType);
					});

					for (i = 0; i < viewTypes.length; i++) {
						spec = this.getViewSpec(viewTypes[i]);
						if (spec) {
							if (spec.singleUnit == unit) {
								return spec;
							}
						}
					}
				}
			},


			// Builds an object with information on how to create a given view
			buildViewSpec: function (requestedViewType) {
				var viewOverrides = this.overrides.views || {};
				var specChain = []; // for the view. lowest to highest priority
				var defaultsChain = []; // for the view. lowest to highest priority
				var overridesChain = []; // for the view. lowest to highest priority
				var viewType = requestedViewType;
				var spec; // for the view
				var overrides; // for the view
				var duration;
				var unit;

				// iterate from the specific view definition to a more general one until we hit an actual View class
				while (viewType) {
					spec = fcViews[viewType];
					overrides = viewOverrides[viewType];
					viewType = null; // clear. might repopulate for another iteration

					if (typeof spec === 'function') { // TODO: deprecate
						spec = {'class': spec};
					}

					if (spec) {
						specChain.unshift(spec);
						defaultsChain.unshift(spec.defaults || {});
						duration = duration || spec.duration;
						viewType = viewType || spec.type;
					}

					if (overrides) {
						overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level
						duration = duration || overrides.duration;
						viewType = viewType || overrides.type;
					}
				}

				spec = mergeProps(specChain);
				spec.type = requestedViewType;
				if (!spec['class']) {
					return false;
				}

				if (duration) {
					duration = moment.duration(duration);
					if (duration.valueOf()) { // valid?
						spec.duration = duration;
						unit = computeIntervalUnit(duration);

						// view is a single-unit duration, like "week" or "day"
						// incorporate options for this. lowest priority
						if (duration.as(unit) === 1) {
							spec.singleUnit = unit;
							overridesChain.unshift(viewOverrides[unit] || {});
						}
					}
				}

				spec.defaults = mergeOptions(defaultsChain);
				spec.overrides = mergeOptions(overridesChain);

				this.buildViewSpecOptions(spec);
				this.buildViewSpecButtonText(spec, requestedViewType);

				return spec;
			},


			// Builds and assigns a view spec's options object from its already-assigned defaults and overrides
			buildViewSpecOptions: function (spec) {
				spec.options = mergeOptions([ // lowest to highest priority
					Calendar.defaults, // global defaults
					spec.defaults, // view's defaults (from ViewSubclass.defaults)
					this.dirDefaults,
					this.langDefaults, // locale and dir take precedence over view's defaults!
					this.overrides, // calendar's overrides (options given to constructor)
					spec.overrides // view's overrides (view-specific options)
				]);
				populateInstanceComputableOptions(spec.options);
			},


			// Computes and assigns a view spec's buttonText-related options
			buildViewSpecButtonText: function (spec, requestedViewType) {

				// given an options object with a possible `buttonText` hash, lookup the buttonText for the
				// requested view, falling back to a generic unit entry like "week" or "day"
				function queryButtonText(options) {
					var buttonText = options.buttonText || {};
					return buttonText[requestedViewType] ||
						(spec.singleUnit ? buttonText[spec.singleUnit] : null);
				}

				// highest to lowest priority
				spec.buttonTextOverride =
					queryButtonText(this.overrides) || // constructor-specified buttonText lookup hash takes precedence
					spec.overrides.buttonText; // `buttonText` for view-specific options is a string

				// highest to lowest priority. mirrors buildViewSpecOptions
				spec.buttonTextDefault =
					queryButtonText(this.langDefaults) ||
					queryButtonText(this.dirDefaults) ||
					spec.defaults.buttonText || // a single string. from ViewSubclass.defaults
					queryButtonText(Calendar.defaults) ||
					(spec.duration ? this.humanizeDuration(spec.duration) : null) || // like "3 days"
					requestedViewType; // fall back to given view name
			},


			// Given a view name for a custom view or a standard view, creates a ready-to-go View object
			instantiateView: function (viewType) {
				var spec = this.getViewSpec(viewType);

				return new spec['class'](this, viewType, spec.options, spec.duration);
			},


			// Returns a boolean about whether the view is okay to instantiate at some point
			isValidViewType: function (viewType) {
				return Boolean(this.getViewSpec(viewType));
			},


			// Should be called when any type of async data fetching begins
			pushLoading: function () {
				if (!(this.loadingLevel++)) {
					this.trigger('loading', null, true, this.view);
				}
			},


			// Should be called when any type of async data fetching completes
			popLoading: function () {
				if (!(--this.loadingLevel)) {
					this.trigger('loading', null, false, this.view);
				}
			},


			// Given arguments to the select method in the API, returns a span (unzoned start/end and other info)
			buildSelectSpan: function (zonedStartInput, zonedEndInput) {
				var start = this.moment(zonedStartInput).stripZone();
				var end;

				if (zonedEndInput) {
					end = this.moment(zonedEndInput).stripZone();
				}
				else if (start.hasTime()) {
					end = start.clone().add(this.defaultTimedEventDuration);
				}
				else {
					end = start.clone().add(this.defaultAllDayEventDuration);
				}

				return {start: start, end: end};
			}

		});


		Calendar.mixin(Emitter);


		function Calendar_constructor(element, overrides) {
			var t = this;


			t.initOptions(overrides || {});
			var options = this.options;


			// Exports
			// -----------------------------------------------------------------------------------

			t.render = render;
			t.destroy = destroy;
			t.refetchEvents = refetchEvents;
			t.reportEvents = reportEvents;
			t.reportEventChange = reportEventChange;
			t.rerenderEvents = renderEvents; // `renderEvents` serves as a rerender. an API method
			t.changeView = renderView; // `renderView` will switch to another view
			t.select = select;
			t.unselect = unselect;
			t.prev = prev;
			t.next = next;
			t.prevYear = prevYear;
			t.nextYear = nextYear;
			t.today = today;
			t.gotoDate = gotoDate;
			t.incrementDate = incrementDate;
			t.zoomTo = zoomTo;
			t.getDate = getDate;
			t.getCalendar = getCalendar;
			t.getView = getView;
			t.option = option;
			t.trigger = trigger;


			// Language-data Internals
			// -----------------------------------------------------------------------------------
			// Apply overrides to the current language's data


			var localeData = createObject( // make a cheap copy
				getMomentLocaleData(options.lang) // will fall back to en
			);

			if (options.monthNames) {
				localeData._months = options.monthNames;
			}
			if (options.monthNamesShort) {
				localeData._monthsShort = options.monthNamesShort;
			}
			if (options.dayNames) {
				localeData._weekdays = options.dayNames;
			}
			if (options.dayNamesShort) {
				localeData._weekdaysShort = options.dayNamesShort;
			}
			if (options.firstDay != null) {
				var _week = createObject(localeData._week); // _week: { dow: # }
				_week.dow = options.firstDay;
				localeData._week = _week;
			}

			// assign a normalized value, to be used by our .week() moment extension
			localeData._fullCalendar_weekCalc = (function (weekCalc) {
				if (typeof weekCalc === 'function') {
					return weekCalc;
				}
				else if (weekCalc === 'local') {
					return weekCalc;
				}
				else if (weekCalc === 'iso' || weekCalc === 'ISO') {
					return 'ISO';
				}
			})(options.weekNumberCalculation);


			// Calendar-specific Date Utilities
			// -----------------------------------------------------------------------------------


			t.defaultAllDayEventDuration = moment.duration(options.defaultAllDayEventDuration);
			t.defaultTimedEventDuration = moment.duration(options.defaultTimedEventDuration);


			// Builds a moment using the settings of the current calendar: timezone and language.
			// Accepts anything the vanilla moment() constructor accepts.
			t.moment = function () {
				var mom;

				if (options.timezone === 'local') {
					mom = FC.moment.apply(null, arguments);

					// Force the moment to be local, because FC.moment doesn't guarantee it.
					if (mom.hasTime()) { // don't give ambiguously-timed moments a local zone
						mom.local();
					}
				}
				else if (options.timezone === 'UTC') {
					mom = FC.moment.utc.apply(null, arguments); // process as UTC
				}
				else {
					mom = FC.moment.parseZone.apply(null, arguments); // let the input decide the zone
				}

				if ('_locale' in mom) { // moment 2.8 and above
					mom._locale = localeData;
				}
				else { // pre-moment-2.8
					mom._lang = localeData;
				}

				return mom;
			};


			// Returns a boolean about whether or not the calendar knows how to calculate
			// the timezone offset of arbitrary dates in the current timezone.
			t.getIsAmbigTimezone = function () {
				return options.timezone !== 'local' && options.timezone !== 'UTC';
			};


			// Returns a copy of the given date in the current timezone. Has no effect on dates without times.
			t.applyTimezone = function (date) {
				if (!date.hasTime()) {
					return date.clone();
				}

				var zonedDate = t.moment(date.toArray());
				var timeAdjust = date.time() - zonedDate.time();
				var adjustedZonedDate;

				// Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)
				if (timeAdjust) { // is the time result different than expected?
					adjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds
					if (date.time() - adjustedZonedDate.time() === 0) { // does it match perfectly now?
						zonedDate = adjustedZonedDate;
					}
				}

				return zonedDate;
			};


			// Returns a moment for the current date, as defined by the client's computer or from the `now` option.
			// Will return an moment with an ambiguous timezone.
			t.getNow = function () {
				var now = options.now;
				if (typeof now === 'function') {
					now = now();
				}
				return t.moment(now).stripZone();
			};


			// Get an event's normalized end date. If not present, calculate it from the defaults.
			t.getEventEnd = function (event) {
				if (event.end) {
					return event.end.clone();
				}
				else {
					return t.getDefaultEventEnd(event.allDay, event.start);
				}
			};


			// Given an event's allDay status and start date, return what its fallback end date should be.
			// TODO: rename to computeDefaultEventEnd
			t.getDefaultEventEnd = function (allDay, zonedStart) {
				var end = zonedStart.clone();

				if (allDay) {
					end.stripTime().add(t.defaultAllDayEventDuration);
				}
				else {
					end.add(t.defaultTimedEventDuration);
				}

				if (t.getIsAmbigTimezone()) {
					end.stripZone(); // we don't know what the tzo should be
				}

				return end;
			};


			// Produces a human-readable string for the given duration.
			// Side-effect: changes the locale of the given duration.
			t.humanizeDuration = function (duration) {
				return (duration.locale || duration.lang).call(duration, options.lang) // works moment-pre-2.8
					.humanize();
			};


			// Imports
			// -----------------------------------------------------------------------------------


			EventManager.call(t, options);
			var isFetchNeeded = t.isFetchNeeded;
			var fetchEvents = t.fetchEvents;


			// Locals
			// -----------------------------------------------------------------------------------


			var _element = element[0];
			var header;
			var headerElement;
			var content;
			var tm; // for making theme classes
			var currentView; // NOTE: keep this in sync with this.view
			var viewsByType = {}; // holds all instantiated view instances, current or not
			var suggestedViewHeight;
			var windowResizeProxy; // wraps the windowResize function
			var ignoreWindowResize = 0;
			var events = [];
			var date; // unzoned


			// Main Rendering
			// -----------------------------------------------------------------------------------


			// compute the initial ambig-timezone date
			if (options.defaultDate != null) {
				date = t.moment(options.defaultDate).stripZone();
			}
			else {
				date = t.getNow(); // getNow already returns unzoned
			}


			function render() {
				if (!content) {
					initialRender();
				}
				else if (elementVisible()) {
					// mainly for the public API
					calcSize();
					renderView();
				}
			}


			function initialRender() {
				tm = options.theme ? 'ui' : 'fc';
				element.addClass('fc');

				if (options.isRTL) {
					element.addClass('fc-rtl');
				}
				else {
					element.addClass('fc-ltr');
				}

				if (options.theme) {
					element.addClass('ui-widget');
				}
				else {
					element.addClass('fc-unthemed');
				}

				content = $("<div class='fc-view-container'/>").prependTo(element);

				header = t.header = new Header(t, options);
				headerElement = header.render();
				if (headerElement) {
					element.prepend(headerElement);
				}

				renderView(options.defaultView);

				if (options.handleWindowResize) {
					windowResizeProxy = debounce(windowResize, options.windowResizeDelay); // prevents rapid calls
					$(window).resize(windowResizeProxy);
				}
			}


			function destroy() {

				if (currentView) {
					currentView.removeElement();

					// NOTE: don't null-out currentView/t.view in case API methods are called after destroy.
					// It is still the "current" view, just not rendered.
				}

				header.removeElement();
				content.remove();
				element.removeClass('fc fc-ltr fc-rtl fc-unthemed ui-widget');

				if (windowResizeProxy) {
					$(window).unbind('resize', windowResizeProxy);
				}
			}


			function elementVisible() {
				return element.is(':visible');
			}


			// View Rendering
			// -----------------------------------------------------------------------------------


			// Renders a view because of a date change, view-type change, or for the first time.
			// If not given a viewType, keep the current view but render different dates.
			function renderView(viewType) {
				ignoreWindowResize++;

				// if viewType is changing, remove the old view's rendering
				if (currentView && viewType && currentView.type !== viewType) {
					header.deactivateButton(currentView.type);
					freezeContentHeight(); // prevent a scroll jump when view element is removed
					currentView.removeElement();
					currentView = t.view = null;
				}

				// if viewType changed, or the view was never created, create a fresh view
				if (!currentView && viewType) {
					currentView = t.view =
						viewsByType[viewType] ||
						(viewsByType[viewType] = t.instantiateView(viewType));

					currentView.setElement(
						$("<div class='fc-view fc-" + viewType + "-view' />").appendTo(content)
					);
					header.activateButton(viewType);
				}

				if (currentView) {

					// in case the view should render a period of time that is completely hidden
					date = currentView.massageCurrentDate(date);

					// render or rerender the view
					if (
						!currentView.displaying || !date.isWithin(currentView.intervalStart, currentView.intervalEnd) // implicit date window change
					) {
						if (elementVisible()) {

							currentView.display(date); // will call freezeContentHeight
							unfreezeContentHeight(); // immediately unfreeze regardless of whether display is async

							// need to do this after View::render, so dates are calculated
							updateHeaderTitle();
							updateTodayButton();

							getAndRenderEvents();
						}
					}
				}

				unfreezeContentHeight(); // undo any lone freezeContentHeight calls
				ignoreWindowResize--;
			}


			// Resizing
			// -----------------------------------------------------------------------------------


			t.getSuggestedViewHeight = function () {
				if (suggestedViewHeight === undefined) {
					calcSize();
				}
				return suggestedViewHeight;
			};


			t.isHeightAuto = function () {
				return options.contentHeight === 'auto' || options.height === 'auto';
			};


			function updateSize(shouldRecalc) {
				if (elementVisible()) {

					if (shouldRecalc) {
						_calcSize();
					}

					ignoreWindowResize++;
					currentView.updateSize(true); // isResize=true. will poll getSuggestedViewHeight() and isHeightAuto()
					ignoreWindowResize--;

					return true; // signal success
				}
			}


			function calcSize() {
				if (elementVisible()) {
					_calcSize();
				}
			}


			function _calcSize() { // assumes elementVisible
				if (typeof options.contentHeight === 'number') { // exists and not 'auto'
					suggestedViewHeight = options.contentHeight;
				}
				else if (typeof options.height === 'number') { // exists and not 'auto'
					suggestedViewHeight = options.height - (headerElement ? headerElement.outerHeight(true) : 0);
				}
				else {
					suggestedViewHeight = Math.round(content.width() / Math.max(options.aspectRatio, .5));
				}
			}


			function windowResize(ev) {
				if (
					!ignoreWindowResize &&
					ev.target === window && // so we don't process jqui "resize" events that have bubbled up
					currentView.start // view has already been rendered
				) {
					if (updateSize(true)) {
						currentView.trigger('windowResize', _element);
					}
				}
			}


			/* Event Fetching/Rendering
			 -----------------------------------------------------------------------------*/
			// TODO: going forward, most of this stuff should be directly handled by the view


			function refetchEvents() { // can be called as an API method
				destroyEvents(); // so that events are cleared before user starts waiting for AJAX
				fetchAndRenderEvents();
			}


			function renderEvents() { // destroys old events if previously rendered
				if (elementVisible()) {
					freezeContentHeight();
					currentView.displayEvents(events);
					unfreezeContentHeight();
				}
			}


			function destroyEvents() {
				freezeContentHeight();
				currentView.clearEvents();
				unfreezeContentHeight();
			}


			function getAndRenderEvents() {
				if (!options.lazyFetching || isFetchNeeded(currentView.start, currentView.end)) {
					fetchAndRenderEvents();
				}
				else {
					renderEvents();
				}
			}


			function fetchAndRenderEvents() {
				fetchEvents(currentView.start, currentView.end);
				// ... will call reportEvents
				// ... which will call renderEvents
			}


			// called when event data arrives
			function reportEvents(_events) {
				events = _events;
				renderEvents();
			}


			// called when a single event's data has been changed
			function reportEventChange() {
				renderEvents();
			}


			/* Header Updating
			 -----------------------------------------------------------------------------*/


			function updateHeaderTitle() {
				header.updateTitle(currentView.title);
			}


			function updateTodayButton() {
				var now = t.getNow();
				if (now.isWithin(currentView.intervalStart, currentView.intervalEnd)) {
					header.disableButton('today');
				}
				else {
					header.enableButton('today');
				}
			}


			/* Selection
			 -----------------------------------------------------------------------------*/


			// this public method receives start/end dates in any format, with any timezone
			function select(zonedStartInput, zonedEndInput) {
				currentView.select(
					t.buildSelectSpan.apply(t, arguments)
				);
			}


			function unselect() { // safe to be called before renderView
				if (currentView) {
					currentView.unselect();
				}
			}


			/* Date
			 -----------------------------------------------------------------------------*/


			function prev() {
				date = currentView.computePrevDate(date);
				renderView();
			}


			function next() {
				date = currentView.computeNextDate(date);
				renderView();
			}


			function prevYear() {
				date.add(-1, 'years');
				renderView();
			}


			function nextYear() {
				date.add(1, 'years');
				renderView();
			}


			function today() {
				date = t.getNow();
				renderView();
			}


			function gotoDate(zonedDateInput) {
				date = t.moment(zonedDateInput).stripZone();
				renderView();
			}


			function incrementDate(delta) {
				date.add(moment.duration(delta));
				renderView();
			}


			// Forces navigation to a view for the given date.
			// `viewType` can be a specific view name or a generic one like "week" or "day".
			function zoomTo(newDate, viewType) {
				var spec;

				viewType = viewType || 'day'; // day is default zoom
				spec = t.getViewSpec(viewType) || t.getUnitViewSpec(viewType);

				date = newDate.clone();
				renderView(spec ? spec.type : null);
			}


			// for external API
			function getDate() {
				return t.applyTimezone(date); // infuse the calendar's timezone
			}


			/* Height "Freezing"
			 -----------------------------------------------------------------------------*/
			// TODO: move this into the view

			t.freezeContentHeight = freezeContentHeight;
			t.unfreezeContentHeight = unfreezeContentHeight;


			function freezeContentHeight() {
				content.css({
					width: '100%',
					height: content.height(),
					overflow: 'hidden'
				});
			}


			function unfreezeContentHeight() {
				content.css({
					width: '',
					height: '',
					overflow: ''
				});
			}


			/* Misc
			 -----------------------------------------------------------------------------*/


			function getCalendar() {
				return t;
			}


			function getView() {
				return currentView;
			}


			function option(name, value) {
				if (value === undefined) {
					return options[name];
				}
				if (name == 'height' || name == 'contentHeight' || name == 'aspectRatio') {
					options[name] = value;
					updateSize(true); // true = allow recalculation of height
				}
			}


			function trigger(name, thisObj) { // overrides the Emitter's trigger method :(
				var args = Array.prototype.slice.call(arguments, 2);

				thisObj = thisObj || _element;
				this.triggerWith(name, thisObj, args); // Emitter's method

				if (options[name]) {
					return options[name].apply(thisObj, args);
				}
			}

			t.initialize();
		}

		;
		;

		Calendar.defaults = {

			titleRangeSeparator: ' \u2014 ', // emphasized dash
			monthYearFormat: 'MMMM YYYY', // required for en. other languages rely on datepicker computable option

			defaultTimedEventDuration: '02:00:00',
			defaultAllDayEventDuration: {days: 1},
			forceEventDuration: false,
			nextDayThreshold: '09:00:00', // 9am

			// display
			defaultView: 'month',
			aspectRatio: 1.35,
			header: {
				left: 'title',
				center: '',
				right: 'today prev,next'
			},
			weekends: true,
			weekNumbers: false,

			weekNumberTitle: 'W',
			weekNumberCalculation: 'local',

			//editable: false,

			scrollTime: '06:00:00',

			// event ajax
			lazyFetching: true,
			startParam: 'start',
			endParam: 'end',
			timezoneParam: 'timezone',

			timezone: false,

			//allDayDefault: undefined,

			// locale
			isRTL: false,
			buttonText: {
				prev: "prev",
				next: "next",
				prevYear: "prev year",
				nextYear: "next year",
				year: 'year', // TODO: locale files need to specify this
				today: 'today',
				month: 'month',
				week: 'week',
				day: 'day'
			},

			buttonIcons: {
				prev: 'left-single-arrow',
				next: 'right-single-arrow',
				prevYear: 'left-double-arrow',
				nextYear: 'right-double-arrow'
			},

			// jquery-ui theming
			theme: false,
			themeButtonIcons: {
				prev: 'circle-triangle-w',
				next: 'circle-triangle-e',
				prevYear: 'seek-prev',
				nextYear: 'seek-next'
			},

			//eventResizableFromStart: false,
			dragOpacity: .75,
			dragRevertDuration: 500,
			dragScroll: true,

			//selectable: false,
			unselectAuto: true,

			dropAccept: '*',

			eventOrder: 'title',

			eventLimit: false,
			eventLimitText: 'more',
			eventLimitClick: 'popover',
			dayPopoverFormat: 'LL',

			handleWindowResize: true,
			windowResizeDelay: 200 // milliseconds before an updateSize happens

		};


		Calendar.englishDefaults = { // used by lang.js
			dayPopoverFormat: 'dddd, MMMM D'
		};


		Calendar.rtlDefaults = { // right-to-left defaults
			header: { // TODO: smarter solution (first/center/last ?)
				left: 'next,prev today',
				center: '',
				right: 'title'
			},
			buttonIcons: {
				prev: 'right-single-arrow',
				next: 'left-single-arrow',
				prevYear: 'right-double-arrow',
				nextYear: 'left-double-arrow'
			},
			themeButtonIcons: {
				prev: 'circle-triangle-e',
				next: 'circle-triangle-w',
				nextYear: 'seek-prev',
				prevYear: 'seek-next'
			}
		};

		;
		;

		var langOptionHash = FC.langs = {}; // initialize and expose


// TODO: document the structure and ordering of a FullCalendar lang file
// TODO: rename everything "lang" to "locale", like what the moment project did


// Initialize jQuery UI datepicker translations while using some of the translations
// Will set this as the default language for datepicker.
		FC.datepickerLang = function (langCode, dpLangCode, dpOptions) {

			// get the FullCalendar internal option hash for this language. create if necessary
			var fcOptions = langOptionHash[langCode] || (langOptionHash[langCode] = {});

			// transfer some simple options from datepicker to fc
			fcOptions.isRTL = dpOptions.isRTL;
			fcOptions.weekNumberTitle = dpOptions.weekHeader;

			// compute some more complex options from datepicker
			$.each(dpComputableOptions, function (name, func) {
				fcOptions[name] = func(dpOptions);
			});

			// is jQuery UI Datepicker is on the page?
			if ($.datepicker) {

				// Register the language data.
				// FullCalendar and MomentJS use language codes like "pt-br" but Datepicker
				// does it like "pt-BR" or if it doesn't have the language, maybe just "pt".
				// Make an alias so the language can be referenced either way.
				$.datepicker.regional[dpLangCode] =
					$.datepicker.regional[langCode] = // alias
						dpOptions;

				// Alias 'en' to the default language data. Do this every time.
				$.datepicker.regional.en = $.datepicker.regional[''];

				// Set as Datepicker's global defaults.
				$.datepicker.setDefaults(dpOptions);
			}
		};


// Sets FullCalendar-specific translations. Will set the language as the global default.
		FC.lang = function (langCode, newFcOptions) {
			var fcOptions;
			var momOptions;

			// get the FullCalendar internal option hash for this language. create if necessary
			fcOptions = langOptionHash[langCode] || (langOptionHash[langCode] = {});

			// provided new options for this language? merge them in
			if (newFcOptions) {
				fcOptions = langOptionHash[langCode] = mergeOptions([fcOptions, newFcOptions]);
			}

			// compute language options that weren't defined.
			// always do this. newFcOptions can be undefined when initializing from i18n file,
			// so no way to tell if this is an initialization or a default-setting.
			momOptions = getMomentLocaleData(langCode); // will fall back to en
			$.each(momComputableOptions, function (name, func) {
				if (fcOptions[name] == null) {
					fcOptions[name] = func(momOptions, fcOptions);
				}
			});

			// set it as the default language for FullCalendar
			Calendar.defaults.lang = langCode;
		};


// NOTE: can't guarantee any of these computations will run because not every language has datepicker
// configs, so make sure there are English fallbacks for these in the defaults file.
		var dpComputableOptions = {

			buttonText: function (dpOptions) {
				return {
					// the translations sometimes wrongly contain HTML entities
					prev: stripHtmlEntities(dpOptions.prevText),
					next: stripHtmlEntities(dpOptions.nextText),
					today: stripHtmlEntities(dpOptions.currentText)
				};
			},

			// Produces format strings like "MMMM YYYY" -> "September 2014"
			monthYearFormat: function (dpOptions) {
				return dpOptions.showMonthAfterYear ?
				'YYYY[' + dpOptions.yearSuffix + '] MMMM' :
				'MMMM YYYY[' + dpOptions.yearSuffix + ']';
			}

		};

		var momComputableOptions = {

			// Produces format strings like "ddd M/D" -> "Fri 9/15"
			dayOfMonthFormat: function (momOptions, fcOptions) {
				var format = momOptions.longDateFormat('l'); // for the format like "M/D/YYYY"

				// strip the year off the edge, as well as other misc non-whitespace chars
				format = format.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, '');

				if (fcOptions.isRTL) {
					format += ' ddd'; // for RTL, add day-of-week to end
				}
				else {
					format = 'ddd ' + format; // for LTR, add day-of-week to beginning
				}
				return format;
			},

			// Produces format strings like "h:mma" -> "6:00pm"
			mediumTimeFormat: function (momOptions) { // can't be called `timeFormat` because collides with option
				return momOptions.longDateFormat('LT')
					.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
			},

			// Produces format strings like "h(:mm)a" -> "6pm" / "6:30pm"
			smallTimeFormat: function (momOptions) {
				return momOptions.longDateFormat('LT')
					.replace(':mm', '(:mm)')
					.replace(/(\Wmm)$/, '($1)') // like above, but for foreign langs
					.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
			},

			// Produces format strings like "h(:mm)t" -> "6p" / "6:30p"
			extraSmallTimeFormat: function (momOptions) {
				return momOptions.longDateFormat('LT')
					.replace(':mm', '(:mm)')
					.replace(/(\Wmm)$/, '($1)') // like above, but for foreign langs
					.replace(/\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand
			},

			// Produces format strings like "ha" / "H" -> "6pm" / "18"
			hourFormat: function (momOptions) {
				return momOptions.longDateFormat('LT')
					.replace(':mm', '')
					.replace(/(\Wmm)$/, '') // like above, but for foreign langs
					.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
			},

			// Produces format strings like "h:mm" -> "6:30" (with no AM/PM)
			noMeridiemTimeFormat: function (momOptions) {
				return momOptions.longDateFormat('LT')
					.replace(/\s*a$/i, ''); // remove trailing AM/PM
			}

		};


// options that should be computed off live calendar options (considers override options)
// TODO: best place for this? related to lang?
// TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it
		var instanceComputableOptions = {

			// Produces format strings for results like "Mo 16"
			smallDayDateFormat: function (options) {
				return options.isRTL ?
					'D dd' :
					'dd D';
			},

			// Produces format strings for results like "Wk 5"
			weekFormat: function (options) {
				return options.isRTL ?
				'w[ ' + options.weekNumberTitle + ']' :
				'[' + options.weekNumberTitle + ' ]w';
			},

			// Produces format strings for results like "Wk5"
			smallWeekFormat: function (options) {
				return options.isRTL ?
				'w[' + options.weekNumberTitle + ']' :
				'[' + options.weekNumberTitle + ']w';
			}

		};

		function populateInstanceComputableOptions(options) {
			$.each(instanceComputableOptions, function (name, func) {
				if (options[name] == null) {
					options[name] = func(options);
				}
			});
		}


// Returns moment's internal locale data. If doesn't exist, returns English.
// Works with moment-pre-2.8
		function getMomentLocaleData(langCode) {
			var func = moment.localeData || moment.langData;
			return func.call(moment, langCode) ||
				func.call(moment, 'en'); // the newer localData could return null, so fall back to en
		}


// Initialize English by forcing computation of moment-derived options.
// Also, sets it as the default.
		FC.lang('en', Calendar.englishDefaults);

		;
		;

		/* Top toolbar area with buttons and title
		 ----------------------------------------------------------------------------------------------------------------------*/
// TODO: rename all header-related things to "toolbar"

		function Header(calendar, options) {
			var t = this;

			// exports
			t.render = render;
			t.removeElement = removeElement;
			t.updateTitle = updateTitle;
			t.activateButton = activateButton;
			t.deactivateButton = deactivateButton;
			t.disableButton = disableButton;
			t.enableButton = enableButton;
			t.getViewsWithButtons = getViewsWithButtons;

			// locals
			var el = $();
			var viewsWithButtons = [];
			var tm;


			function render() {
				var sections = options.header;

				tm = options.theme ? 'ui' : 'fc';

				if (sections) {
					el = $("<div class='fc-toolbar'/>")
						.append(renderSection('left'))
						.append(renderSection('right'))
						.append(renderSection('center'))
						.append('<div class="fc-clear"/>');

					return el;
				}
			}


			function removeElement() {
				el.remove();
				el = $();
			}


			function renderSection(position) {
				var sectionEl = $('<div class="fc-' + position + '"/>');
				var buttonStr = options.header[position];

				if (buttonStr) {
					$.each(buttonStr.split(' '), function (i) {
						var groupChildren = $();
						var isOnlyButtons = true;
						var groupEl;

						$.each(this.split(','), function (j, buttonName) {
							var customButtonProps;
							var viewSpec;
							var buttonClick;
							var overrideText; // text explicitly set by calendar's constructor options. overcomes icons
							var defaultText;
							var themeIcon;
							var normalIcon;
							var innerHtml;
							var classes;
							var button; // the element

							if (buttonName == 'title') {
								groupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height
								isOnlyButtons = false;
							}
							else {
								if ((customButtonProps = (calendar.options.customButtons || {})[buttonName])) {
									buttonClick = function (ev) {
										if (customButtonProps.click) {
											customButtonProps.click.call(button[0], ev);
										}
									};
									overrideText = ''; // icons will override text
									defaultText = customButtonProps.text;
								}
								else if ((viewSpec = calendar.getViewSpec(buttonName))) {
									buttonClick = function () {
										calendar.changeView(buttonName);
									};
									viewsWithButtons.push(buttonName);
									overrideText = viewSpec.buttonTextOverride;
									defaultText = viewSpec.buttonTextDefault;
								}
								else if (calendar[buttonName]) { // a calendar method
									buttonClick = function () {
										calendar[buttonName]();
									};
									overrideText = (calendar.overrides.buttonText || {})[buttonName];
									defaultText = options.buttonText[buttonName]; // everything else is considered default
								}

								if (buttonClick) {

									themeIcon =
										customButtonProps ?
											customButtonProps.themeIcon :
											options.themeButtonIcons[buttonName];

									normalIcon =
										customButtonProps ?
											customButtonProps.icon :
											options.buttonIcons[buttonName];

									if (overrideText) {
										innerHtml = htmlEscape(overrideText);
									}
									else if (themeIcon && options.theme) {
										innerHtml = "<span class='ui-icon ui-icon-" + themeIcon + "'></span>";
									}
									else if (normalIcon && !options.theme) {
										innerHtml = "<span class='fc-icon fc-icon-" + normalIcon + "'></span>";
									}
									else {
										innerHtml = htmlEscape(defaultText);
									}

									classes = [
										'fc-' + buttonName + '-button',
										tm + '-button',
										tm + '-state-default'
									];

									button = $( // type="button" so that it doesn't submit a form
										'<button type="button" class="' + classes.join(' ') + '">' +
										innerHtml +
										'</button>'
									)
										.click(function (ev) {
											// don't process clicks for disabled buttons
											if (!button.hasClass(tm + '-state-disabled')) {

												buttonClick(ev);

												// after the click action, if the button becomes the "active" tab, or disabled,
												// it should never have a hover class, so remove it now.
												if (
													button.hasClass(tm + '-state-active') ||
													button.hasClass(tm + '-state-disabled')
												) {
													button.removeClass(tm + '-state-hover');
												}
											}
										})
										.mousedown(function () {
											// the *down* effect (mouse pressed in).
											// only on buttons that are not the "active" tab, or disabled
											button
												.not('.' + tm + '-state-active')
												.not('.' + tm + '-state-disabled')
												.addClass(tm + '-state-down');
										})
										.mouseup(function () {
											// undo the *down* effect
											button.removeClass(tm + '-state-down');
										})
										.hover(
										function () {
											// the *hover* effect.
											// only on buttons that are not the "active" tab, or disabled
											button
												.not('.' + tm + '-state-active')
												.not('.' + tm + '-state-disabled')
												.addClass(tm + '-state-hover');
										},
										function () {
											// undo the *hover* effect
											button
												.removeClass(tm + '-state-hover')
												.removeClass(tm + '-state-down'); // if mouseleave happens before mouseup
										}
									);

									groupChildren = groupChildren.add(button);
								}
							}
						});

						if (isOnlyButtons) {
							groupChildren
								.first().addClass(tm + '-corner-left').end()
								.last().addClass(tm + '-corner-right').end();
						}

						if (groupChildren.length > 1) {
							groupEl = $('<div/>');
							if (isOnlyButtons) {
								groupEl.addClass('fc-button-group');
							}
							groupEl.append(groupChildren);
							sectionEl.append(groupEl);
						}
						else {
							sectionEl.append(groupChildren); // 1 or 0 children
						}
					});
				}

				return sectionEl;
			}


			function updateTitle(text) {
				el.find('h2').text(text);
			}


			function activateButton(buttonName) {
				el.find('.fc-' + buttonName + '-button')
					.addClass(tm + '-state-active');
			}


			function deactivateButton(buttonName) {
				el.find('.fc-' + buttonName + '-button')
					.removeClass(tm + '-state-active');
			}


			function disableButton(buttonName) {
				el.find('.fc-' + buttonName + '-button')
					.attr('disabled', 'disabled')
					.addClass(tm + '-state-disabled');
			}


			function enableButton(buttonName) {
				el.find('.fc-' + buttonName + '-button')
					.removeAttr('disabled')
					.removeClass(tm + '-state-disabled');
			}


			function getViewsWithButtons() {
				return viewsWithButtons;
			}

		}

		;
		;

		FC.sourceNormalizers = [];
		FC.sourceFetchers = [];

		var ajaxDefaults = {
			dataType: 'json',
			cache: false
		};

		var eventGUID = 1;


		function EventManager(options) { // assumed to be a calendar
			var t = this;


			// exports
			t.isFetchNeeded = isFetchNeeded;
			t.fetchEvents = fetchEvents;
			t.addEventSource = addEventSource;
			t.removeEventSource = removeEventSource;
			t.updateEvent = updateEvent;
			t.renderEvent = renderEvent;
			t.removeEvents = removeEvents;
			t.clientEvents = clientEvents;
			t.mutateEvent = mutateEvent;
			t.normalizeEventDates = normalizeEventDates;
			t.normalizeEventTimes = normalizeEventTimes;


			// imports
			var reportEvents = t.reportEvents;


			// locals
			var stickySource = {events: []};
			var sources = [stickySource];
			var rangeStart, rangeEnd;
			var currentFetchID = 0;
			var pendingSourceCnt = 0;
			var cache = []; // holds events that have already been expanded


			$.each(
				(options.events ? [options.events] : []).concat(options.eventSources || []),
				function (i, sourceInput) {
					var source = buildEventSource(sourceInput);
					if (source) {
						sources.push(source);
					}
				}
			);


			/* Fetching
			 -----------------------------------------------------------------------------*/


			// start and end are assumed to be unzoned
			function isFetchNeeded(start, end) {
				return !rangeStart || // nothing has been fetched yet?
					start < rangeStart || end > rangeEnd; // is part of the new range outside of the old range?
			}


			function fetchEvents(start, end) {
				rangeStart = start;
				rangeEnd = end;
				cache = [];
				var fetchID = ++currentFetchID;
				var len = sources.length;
				pendingSourceCnt = len;
				for (var i = 0; i < len; i++) {
					fetchEventSource(sources[i], fetchID);
				}
			}


			function fetchEventSource(source, fetchID) {
				_fetchEventSource(source, function (eventInputs) {
					var isArraySource = $.isArray(source.events);
					var i, eventInput;
					var abstractEvent;

					if (fetchID == currentFetchID) {

						if (eventInputs) {
							for (i = 0; i < eventInputs.length; i++) {
								eventInput = eventInputs[i];

								if (isArraySource) { // array sources have already been convert to Event Objects
									abstractEvent = eventInput;
								}
								else {
									abstractEvent = buildEventFromInput(eventInput, source);
								}

								if (abstractEvent) { // not false (an invalid event)
									cache.push.apply(
										cache,
										expandEvent(abstractEvent) // add individual expanded events to the cache
									);
								}
							}
						}

						pendingSourceCnt--;
						if (!pendingSourceCnt) {
							reportEvents(cache);
						}
					}
				});
			}


			function _fetchEventSource(source, callback) {
				var i;
				var fetchers = FC.sourceFetchers;
				var res;

				for (i = 0; i < fetchers.length; i++) {
					res = fetchers[i].call(
						t, // this, the Calendar object
						source,
						rangeStart.clone(),
						rangeEnd.clone(),
						options.timezone,
						callback
					);

					if (res === true) {
						// the fetcher is in charge. made its own async request
						return;
					}
					else if (typeof res == 'object') {
						// the fetcher returned a new source. process it
						_fetchEventSource(res, callback);
						return;
					}
				}

				var events = source.events;
				if (events) {
					if ($.isFunction(events)) {
						t.pushLoading();
						events.call(
							t, // this, the Calendar object
							rangeStart.clone(),
							rangeEnd.clone(),
							options.timezone,
							function (events) {
								callback(events);
								t.popLoading();
							}
						);
					}
					else if ($.isArray(events)) {
						callback(events);
					}
					else {
						callback();
					}
				} else {
					var url = source.url;
					if (url) {
						var success = source.success;
						var error = source.error;
						var complete = source.complete;

						// retrieve any outbound GET/POST $.ajax data from the options
						var customData;
						if ($.isFunction(source.data)) {
							// supplied as a function that returns a key/value object
							customData = source.data();
						}
						else {
							// supplied as a straight key/value object
							customData = source.data;
						}

						// use a copy of the custom data so we can modify the parameters
						// and not affect the passed-in object.
						var data = $.extend({}, customData || {});

						var startParam = firstDefined(source.startParam, options.startParam);
						var endParam = firstDefined(source.endParam, options.endParam);
						var timezoneParam = firstDefined(source.timezoneParam, options.timezoneParam);

						if (startParam) {
							data[startParam] = rangeStart.format();
						}
						if (endParam) {
							data[endParam] = rangeEnd.format();
						}
						if (options.timezone && options.timezone != 'local') {
							data[timezoneParam] = options.timezone;
						}

						t.pushLoading();
						$.ajax($.extend({}, ajaxDefaults, source, {
							data: data,
							success: function (events) {
								events = events || [];
								var res = applyAll(success, this, arguments);
								if ($.isArray(res)) {
									events = res;
								}
								callback(events);
							},
							error: function () {
								applyAll(error, this, arguments);
								callback();
							},
							complete: function () {
								applyAll(complete, this, arguments);
								t.popLoading();
							}
						}));
					} else {
						callback();
					}
				}
			}


			/* Sources
			 -----------------------------------------------------------------------------*/


			function addEventSource(sourceInput) {
				var source = buildEventSource(sourceInput);
				if (source) {
					sources.push(source);
					pendingSourceCnt++;
					fetchEventSource(source, currentFetchID); // will eventually call reportEvents
				}
			}


			function buildEventSource(sourceInput) { // will return undefined if invalid source
				var normalizers = FC.sourceNormalizers;
				var source;
				var i;

				if ($.isFunction(sourceInput) || $.isArray(sourceInput)) {
					source = {events: sourceInput};
				}
				else if (typeof sourceInput === 'string') {
					source = {url: sourceInput};
				}
				else if (typeof sourceInput === 'object') {
					source = $.extend({}, sourceInput); // shallow copy
				}

				if (source) {

					// TODO: repeat code, same code for event classNames
					if (source.className) {
						if (typeof source.className === 'string') {
							source.className = source.className.split(/\s+/);
						}
						// otherwise, assumed to be an array
					}
					else {
						source.className = [];
					}

					// for array sources, we convert to standard Event Objects up front
					if ($.isArray(source.events)) {
						source.origArray = source.events; // for removeEventSource
						source.events = $.map(source.events, function (eventInput) {
							return buildEventFromInput(eventInput, source);
						});
					}

					for (i = 0; i < normalizers.length; i++) {
						normalizers[i].call(t, source);
					}

					return source;
				}
			}


			function removeEventSource(source) {
				sources = $.grep(sources, function (src) {
					return !isSourcesEqual(src, source);
				});
				// remove all client events from that source
				cache = $.grep(cache, function (e) {
					return !isSourcesEqual(e.source, source);
				});
				reportEvents(cache);
			}


			function isSourcesEqual(source1, source2) {
				return source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);
			}


			function getSourcePrimitive(source) {
				return (
						(typeof source === 'object') ? // a normalized event source?
							(source.origArray || source.googleCalendarId || source.url || source.events) : // get the primitive
							null
					) ||
					source; // the given argument *is* the primitive
			}


			/* Manipulation
			 -----------------------------------------------------------------------------*/


			// Only ever called from the externally-facing API
			function updateEvent(event) {

				// massage start/end values, even if date string values
				event.start = t.moment(event.start);
				if (event.end) {
					event.end = t.moment(event.end);
				}
				else {
					event.end = null;
				}

				mutateEvent(event, getMiscEventProps(event)); // will handle start/end/allDay normalization
				reportEvents(cache); // reports event modifications (so we can redraw)
			}


			// Returns a hash of misc event properties that should be copied over to related events.
			function getMiscEventProps(event) {
				var props = {};

				$.each(event, function (name, val) {
					if (isMiscEventPropName(name)) {
						if (val !== undefined && isAtomic(val)) { // a defined non-object
							props[name] = val;
						}
					}
				});

				return props;
			}

			// non-date-related, non-id-related, non-secret
			function isMiscEventPropName(name) {
				return !/^_|^(id|allDay|start|end)$/.test(name);
			}


			// returns the expanded events that were created
			function renderEvent(eventInput, stick) {
				var abstractEvent = buildEventFromInput(eventInput);
				var events;
				var i, event;

				if (abstractEvent) { // not false (a valid input)
					events = expandEvent(abstractEvent);

					for (i = 0; i < events.length; i++) {
						event = events[i];

						if (!event.source) {
							if (stick) {
								stickySource.events.push(event);
								event.source = stickySource;
							}
							cache.push(event);
						}
					}

					reportEvents(cache);

					return events;
				}

				return [];
			}


			function removeEvents(filter) {
				var eventID;
				var i;

				if (filter == null) { // null or undefined. remove all events
					filter = function () {
						return true;
					}; // will always match
				}
				else if (!$.isFunction(filter)) { // an event ID
					eventID = filter + '';
					filter = function (event) {
						return event._id == eventID;
					};
				}

				// Purge event(s) from our local cache
				cache = $.grep(cache, filter, true); // inverse=true

				// Remove events from array sources.
				// This works because they have been converted to official Event Objects up front.
				// (and as a result, event._id has been calculated).
				for (i = 0; i < sources.length; i++) {
					if ($.isArray(sources[i].events)) {
						sources[i].events = $.grep(sources[i].events, filter, true);
					}
				}

				reportEvents(cache);
			}


			function clientEvents(filter) {
				if ($.isFunction(filter)) {
					return $.grep(cache, filter);
				}
				else if (filter != null) { // not null, not undefined. an event ID
					filter += '';
					return $.grep(cache, function (e) {
						return e._id == filter;
					});
				}
				return cache; // else, return all
			}


			/* Event Normalization
			 -----------------------------------------------------------------------------*/


			// Given a raw object with key/value properties, returns an "abstract" Event object.
			// An "abstract" event is an event that, if recurring, will not have been expanded yet.
			// Will return `false` when input is invalid.
			// `source` is optional
			function buildEventFromInput(input, source) {
				var out = {};
				var start, end;
				var allDay;

				if (options.eventDataTransform) {
					input = options.eventDataTransform(input);
				}
				if (source && source.eventDataTransform) {
					input = source.eventDataTransform(input);
				}

				// Copy all properties over to the resulting object.
				// The special-case properties will be copied over afterwards.
				$.extend(out, input);

				if (source) {
					out.source = source;
				}

				out._id = input._id || (input.id === undefined ? '_fc' + eventGUID++ : input.id + '');

				if (input.className) {
					if (typeof input.className == 'string') {
						out.className = input.className.split(/\s+/);
					}
					else { // assumed to be an array
						out.className = input.className;
					}
				}
				else {
					out.className = [];
				}

				start = input.start || input.date; // "date" is an alias for "start"
				end = input.end;

				// parse as a time (Duration) if applicable
				if (isTimeString(start)) {
					start = moment.duration(start);
				}
				if (isTimeString(end)) {
					end = moment.duration(end);
				}

				if (input.dow || moment.isDuration(start) || moment.isDuration(end)) {

					// the event is "abstract" (recurring) so don't calculate exact start/end dates just yet
					out.start = start ? moment.duration(start) : null; // will be a Duration or null
					out.end = end ? moment.duration(end) : null; // will be a Duration or null
					out._recurring = true; // our internal marker
				}
				else {

					if (start) {
						start = t.moment(start);
						if (!start.isValid()) {
							return false;
						}
					}

					if (end) {
						end = t.moment(end);
						if (!end.isValid()) {
							end = null; // let defaults take over
						}
					}

					allDay = input.allDay;
					if (allDay === undefined) { // still undefined? fallback to default
						allDay = firstDefined(
							source ? source.allDayDefault : undefined,
							options.allDayDefault
						);
						// still undefined? normalizeEventDates will calculate it
					}

					assignDatesToEvent(start, end, allDay, out);
				}

				return out;
			}


			// Normalizes and assigns the given dates to the given partially-formed event object.
			// NOTE: mutates the given start/end moments. does not make a copy.
			function assignDatesToEvent(start, end, allDay, event) {
				event.start = start;
				event.end = end;
				event.allDay = allDay;
				normalizeEventDates(event);
				backupEventDates(event);
			}


			// Ensures proper values for allDay/start/end. Accepts an Event object, or a plain object with event-ish properties.
			// NOTE: Will modify the given object.
			function normalizeEventDates(eventProps) {

				normalizeEventTimes(eventProps);

				if (eventProps.end && !eventProps.end.isAfter(eventProps.start)) {
					eventProps.end = null;
				}

				if (!eventProps.end) {
					if (options.forceEventDuration) {
						eventProps.end = t.getDefaultEventEnd(eventProps.allDay, eventProps.start);
					}
					else {
						eventProps.end = null;
					}
				}
			}


			// Ensures the allDay property exists and the timeliness of the start/end dates are consistent
			function normalizeEventTimes(eventProps) {
				if (eventProps.allDay == null) {
					eventProps.allDay = !(eventProps.start.hasTime() || (eventProps.end && eventProps.end.hasTime()));
				}

				if (eventProps.allDay) {
					eventProps.start.stripTime();
					if (eventProps.end) {
						// TODO: consider nextDayThreshold here? If so, will require a lot of testing and adjustment
						eventProps.end.stripTime();
					}
				}
				else {
					if (!eventProps.start.hasTime()) {
						eventProps.start = t.applyTimezone(eventProps.start.time(0)); // will assign a 00:00 time
					}
					if (eventProps.end && !eventProps.end.hasTime()) {
						eventProps.end = t.applyTimezone(eventProps.end.time(0)); // will assign a 00:00 time
					}
				}
			}


			// If the given event is a recurring event, break it down into an array of individual instances.
			// If not a recurring event, return an array with the single original event.
			// If given a falsy input (probably because of a failed buildEventFromInput call), returns an empty array.
			// HACK: can override the recurring window by providing custom rangeStart/rangeEnd (for businessHours).
			function expandEvent(abstractEvent, _rangeStart, _rangeEnd) {
				var events = [];
				var dowHash;
				var dow;
				var i;
				var date;
				var startTime, endTime;
				var start, end;
				var event;

				_rangeStart = _rangeStart || rangeStart;
				_rangeEnd = _rangeEnd || rangeEnd;

				if (abstractEvent) {
					if (abstractEvent._recurring) {

						// make a boolean hash as to whether the event occurs on each day-of-week
						if ((dow = abstractEvent.dow)) {
							dowHash = {};
							for (i = 0; i < dow.length; i++) {
								dowHash[dow[i]] = true;
							}
						}

						// iterate through every day in the current range
						date = _rangeStart.clone().stripTime(); // holds the date of the current day
						while (date.isBefore(_rangeEnd)) {

							if (!dowHash || dowHash[date.day()]) { // if everyday, or this particular day-of-week

								startTime = abstractEvent.start; // the stored start and end properties are times (Durations)
								endTime = abstractEvent.end; // "
								start = date.clone();
								end = null;

								if (startTime) {
									start = start.time(startTime);
								}
								if (endTime) {
									end = date.clone().time(endTime);
								}

								event = $.extend({}, abstractEvent); // make a copy of the original
								assignDatesToEvent(
									start, end,
									!startTime && !endTime, // allDay?
									event
								);
								events.push(event);
							}

							date.add(1, 'days');
						}
					}
					else {
						events.push(abstractEvent); // return the original event. will be a one-item array
					}
				}

				return events;
			}


			/* Event Modification Math
			 -----------------------------------------------------------------------------------------*/


			// Modifies an event and all related events by applying the given properties.
			// Special date-diffing logic is used for manipulation of dates.
			// If `props` does not contain start/end dates, the updated values are assumed to be the event's current start/end.
			// All date comparisons are done against the event's pristine _start and _end dates.
			// Returns an object with delta information and a function to undo all operations.
			// For making computations in a granularity greater than day/time, specify largeUnit.
			// NOTE: The given `newProps` might be mutated for normalization purposes.
			function mutateEvent(event, newProps, largeUnit) {
				var miscProps = {};
				var oldProps;
				var clearEnd;
				var startDelta;
				var endDelta;
				var durationDelta;
				var undoFunc;

				// diffs the dates in the appropriate way, returning a duration
				function diffDates(date1, date0) { // date1 - date0
					if (largeUnit) {
						return diffByUnit(date1, date0, largeUnit);
					}
					else if (newProps.allDay) {
						return diffDay(date1, date0);
					}
					else {
						return diffDayTime(date1, date0);
					}
				}

				newProps = newProps || {};

				// normalize new date-related properties
				if (!newProps.start) {
					newProps.start = event.start.clone();
				}
				if (newProps.end === undefined) {
					newProps.end = event.end ? event.end.clone() : null;
				}
				if (newProps.allDay == null) { // is null or undefined?
					newProps.allDay = event.allDay;
				}
				normalizeEventDates(newProps);

				// create normalized versions of the original props to compare against
				// need a real end value, for diffing
				oldProps = {
					start: event._start.clone(),
					end: event._end ? event._end.clone() : t.getDefaultEventEnd(event._allDay, event._start),
					allDay: newProps.allDay // normalize the dates in the same regard as the new properties
				};
				normalizeEventDates(oldProps);

				// need to clear the end date if explicitly changed to null
				clearEnd = event._end !== null && newProps.end === null;

				// compute the delta for moving the start date
				startDelta = diffDates(newProps.start, oldProps.start);

				// compute the delta for moving the end date
				if (newProps.end) {
					endDelta = diffDates(newProps.end, oldProps.end);
					durationDelta = endDelta.subtract(startDelta);
				}
				else {
					durationDelta = null;
				}

				// gather all non-date-related properties
				$.each(newProps, function (name, val) {
					if (isMiscEventPropName(name)) {
						if (val !== undefined) {
							miscProps[name] = val;
						}
					}
				});

				// apply the operations to the event and all related events
				undoFunc = mutateEvents(
					clientEvents(event._id), // get events with this ID
					clearEnd,
					newProps.allDay,
					startDelta,
					durationDelta,
					miscProps
				);

				return {
					dateDelta: startDelta,
					durationDelta: durationDelta,
					undo: undoFunc
				};
			}


			// Modifies an array of events in the following ways (operations are in order):
			// - clear the event's `end`
			// - convert the event to allDay
			// - add `dateDelta` to the start and end
			// - add `durationDelta` to the event's duration
			// - assign `miscProps` to the event
			//
			// Returns a function that can be called to undo all the operations.
			//
			// TODO: don't use so many closures. possible memory issues when lots of events with same ID.
			//
			function mutateEvents(events, clearEnd, allDay, dateDelta, durationDelta, miscProps) {
				var isAmbigTimezone = t.getIsAmbigTimezone();
				var undoFunctions = [];

				// normalize zero-length deltas to be null
				if (dateDelta && !dateDelta.valueOf()) {
					dateDelta = null;
				}
				if (durationDelta && !durationDelta.valueOf()) {
					durationDelta = null;
				}

				$.each(events, function (i, event) {
					var oldProps;
					var newProps;

					// build an object holding all the old values, both date-related and misc.
					// for the undo function.
					oldProps = {
						start: event.start.clone(),
						end: event.end ? event.end.clone() : null,
						allDay: event.allDay
					};
					$.each(miscProps, function (name) {
						oldProps[name] = event[name];
					});

					// new date-related properties. work off the original date snapshot.
					// ok to use references because they will be thrown away when backupEventDates is called.
					newProps = {
						start: event._start,
						end: event._end,
						allDay: allDay // normalize the dates in the same regard as the new properties
					};
					normalizeEventDates(newProps); // massages start/end/allDay

					// strip or ensure the end date
					if (clearEnd) {
						newProps.end = null;
					}
					else if (durationDelta && !newProps.end) { // the duration translation requires an end date
						newProps.end = t.getDefaultEventEnd(newProps.allDay, newProps.start);
					}

					if (dateDelta) {
						newProps.start.add(dateDelta);
						if (newProps.end) {
							newProps.end.add(dateDelta);
						}
					}

					if (durationDelta) {
						newProps.end.add(durationDelta); // end already ensured above
					}

					// if the dates have changed, and we know it is impossible to recompute the
					// timezone offsets, strip the zone.
					if (
						isAmbigTimezone && !newProps.allDay &&
						(dateDelta || durationDelta)
					) {
						newProps.start.stripZone();
						if (newProps.end) {
							newProps.end.stripZone();
						}
					}

					$.extend(event, miscProps, newProps); // copy over misc props, then date-related props
					backupEventDates(event); // regenerate internal _start/_end/_allDay

					undoFunctions.push(function () {
						$.extend(event, oldProps);
						backupEventDates(event); // regenerate internal _start/_end/_allDay
					});
				});

				return function () {
					for (var i = 0; i < undoFunctions.length; i++) {
						undoFunctions[i]();
					}
				};
			}


			/* Business Hours
			 -----------------------------------------------------------------------------------------*/

			t.getBusinessHoursEvents = getBusinessHoursEvents;


			// Returns an array of events as to when the business hours occur in the given view.
			// Abuse of our event system :(
			function getBusinessHoursEvents(wholeDay) {
				var optionVal = options.businessHours;
				var defaultVal = {
					className: 'fc-nonbusiness',
					start: '09:00',
					end: '17:00',
					dow: [1, 2, 3, 4, 5], // monday - friday
					rendering: 'inverse-background'
				};
				var view = t.getView();
				var eventInput;

				if (optionVal) { // `true` (which means "use the defaults") or an override object
					eventInput = $.extend(
						{}, // copy to a new object in either case
						defaultVal,
						typeof optionVal === 'object' ? optionVal : {} // override the defaults
					);
				}

				if (eventInput) {

					// if a whole-day series is requested, clear the start/end times
					if (wholeDay) {
						eventInput.start = null;
						eventInput.end = null;
					}

					return expandEvent(
						buildEventFromInput(eventInput),
						view.start,
						view.end
					);
				}

				return [];
			}


			/* Overlapping / Constraining
			 -----------------------------------------------------------------------------------------*/

			t.isEventSpanAllowed = isEventSpanAllowed;
			t.isExternalSpanAllowed = isExternalSpanAllowed;
			t.isSelectionSpanAllowed = isSelectionSpanAllowed;


			// Determines if the given event can be relocated to the given span (unzoned start/end with other misc data)
			function isEventSpanAllowed(span, event) {
				var source = event.source || {};
				var constraint = firstDefined(
					event.constraint,
					source.constraint,
					options.eventConstraint
				);
				var overlap = firstDefined(
					event.overlap,
					source.overlap,
					options.eventOverlap
				);
				return isSpanAllowed(span, constraint, overlap, event);
			}


			// Determines if an external event can be relocated to the given span (unzoned start/end with other misc data)
			function isExternalSpanAllowed(eventSpan, eventLocation, eventProps) {
				var eventInput;
				var event;

				// note: very similar logic is in View's reportExternalDrop
				if (eventProps) {
					eventInput = $.extend({}, eventProps, eventLocation);
					event = expandEvent(buildEventFromInput(eventInput))[0];
				}

				if (event) {
					return isEventSpanAllowed(eventSpan, event);
				}
				else { // treat it as a selection

					return isSelectionSpanAllowed(eventSpan);
				}
			}


			// Determines the given span (unzoned start/end with other misc data) can be selected.
			function isSelectionSpanAllowed(span) {
				return isSpanAllowed(span, options.selectConstraint, options.selectOverlap);
			}


			// Returns true if the given span (caused by an event drop/resize or a selection) is allowed to exist
			// according to the constraint/overlap settings.
			// `event` is not required if checking a selection.
			function isSpanAllowed(span, constraint, overlap, event) {
				var constraintEvents;
				var anyContainment;
				var peerEvents;
				var i, peerEvent;
				var peerOverlap;

				// the range must be fully contained by at least one of produced constraint events
				if (constraint != null) {

					// not treated as an event! intermediate data structure
					// TODO: use ranges in the future
					constraintEvents = constraintToEvents(constraint);

					anyContainment = false;
					for (i = 0; i < constraintEvents.length; i++) {
						if (eventContainsRange(constraintEvents[i], span)) {
							anyContainment = true;
							break;
						}
					}

					if (!anyContainment) {
						return false;
					}
				}

				peerEvents = t.getPeerEvents(span, event);

				for (i = 0; i < peerEvents.length; i++) {
					peerEvent = peerEvents[i];

					// there needs to be an actual intersection before disallowing anything
					if (eventIntersectsRange(peerEvent, span)) {

						// evaluate overlap for the given range and short-circuit if necessary
						if (overlap === false) {
							return false;
						}
						// if the event's overlap is a test function, pass the peer event in question as the first param
						else if (typeof overlap === 'function' && !overlap(peerEvent, event)) {
							return false;
						}

						// if we are computing if the given range is allowable for an event, consider the other event's
						// EventObject-specific or Source-specific `overlap` property
						if (event) {
							peerOverlap = firstDefined(
								peerEvent.overlap,
								(peerEvent.source || {}).overlap
								// we already considered the global `eventOverlap`
							);
							if (peerOverlap === false) {
								return false;
							}
							// if the peer event's overlap is a test function, pass the subject event as the first param
							if (typeof peerOverlap === 'function' && !peerOverlap(event, peerEvent)) {
								return false;
							}
						}
					}
				}

				return true;
			}


			// Given an event input from the API, produces an array of event objects. Possible event inputs:
			// 'businessHours'
			// An event ID (number or string)
			// An object with specific start/end dates or a recurring event (like what businessHours accepts)
			function constraintToEvents(constraintInput) {

				if (constraintInput === 'businessHours') {
					return getBusinessHoursEvents();
				}

				if (typeof constraintInput === 'object') {
					return expandEvent(buildEventFromInput(constraintInput));
				}

				return clientEvents(constraintInput); // probably an ID
			}


			// Does the event's date range fully contain the given range?
			// start/end already assumed to have stripped zones :(
			function eventContainsRange(event, range) {
				var eventStart = event.start.clone().stripZone();
				var eventEnd = t.getEventEnd(event).stripZone();

				return range.start >= eventStart && range.end <= eventEnd;
			}


			// Does the event's date range intersect with the given range?
			// start/end already assumed to have stripped zones :(
			function eventIntersectsRange(event, range) {
				var eventStart = event.start.clone().stripZone();
				var eventEnd = t.getEventEnd(event).stripZone();

				return range.start < eventEnd && range.end > eventStart;
			}


			t.getEventCache = function () {
				return cache;
			};

		}


// Returns a list of events that the given event should be compared against when being considered for a move to
// the specified span. Attached to the Calendar's prototype because EventManager is a mixin for a Calendar.
		Calendar.prototype.getPeerEvents = function (span, event) {
			var cache = this.getEventCache();
			var peerEvents = [];
			var i, otherEvent;

			for (i = 0; i < cache.length; i++) {
				otherEvent = cache[i];
				if (
					!event ||
					event._id !== otherEvent._id // don't compare the event to itself or other related [repeating] events
				) {
					peerEvents.push(otherEvent);
				}
			}

			return peerEvents;
		};


// updates the "backup" properties, which are preserved in order to compute diffs later on.
		function backupEventDates(event) {
			event._allDay = event.allDay;
			event._start = event.start.clone();
			event._end = event.end ? event.end.clone() : null;
		}

		;
		;

		/* An abstract class for the "basic" views, as well as month view. Renders one or more rows of day cells.
		 ----------------------------------------------------------------------------------------------------------------------*/
// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.
// It is responsible for managing width/height.

		var BasicView = FC.BasicView = View.extend({

			dayGridClass: DayGrid, // class the dayGrid will be instantiated from (overridable by subclasses)
			dayGrid: null, // the main subcomponent that does most of the heavy lifting

			dayNumbersVisible: false, // display day numbers on each day cell?
			weekNumbersVisible: false, // display week numbers along the side?

			weekNumberWidth: null, // width of all the week-number cells running down the side

			headContainerEl: null, // div that hold's the dayGrid's rendered date header
			headRowEl: null, // the fake row element of the day-of-week header


			initialize: function () {
				this.dayGrid = this.instantiateDayGrid();
			},


			// Generates the DayGrid object this view needs. Draws from this.dayGridClass
			instantiateDayGrid: function () {
				// generate a subclass on the fly with BasicView-specific behavior
				// TODO: cache this subclass
				var subclass = this.dayGridClass.extend(basicDayGridMethods);

				return new subclass(this);
			},


			// Sets the display range and computes all necessary dates
			setRange: function (range) {
				View.prototype.setRange.call(this, range); // call the super-method

				this.dayGrid.breakOnWeeks = /year|month|week/.test(this.intervalUnit); // do before setRange
				this.dayGrid.setRange(range);
			},


			// Compute the value to feed into setRange. Overrides superclass.
			computeRange: function (date) {
				var range = View.prototype.computeRange.call(this, date); // get value from the super-method

				// year and month views should be aligned with weeks. this is already done for week
				if (/year|month/.test(range.intervalUnit)) {
					range.start.startOf('week');
					range.start = this.skipHiddenDays(range.start);

					// make end-of-week if not already
					if (range.end.weekday()) {
						range.end.add(1, 'week').startOf('week');
						range.end = this.skipHiddenDays(range.end, -1, true); // exclusively move backwards
					}
				}

				return range;
			},


			// Renders the view into `this.el`, which should already be assigned
			renderDates: function () {

				this.dayNumbersVisible = this.dayGrid.rowCnt > 1; // TODO: make grid responsible
				this.weekNumbersVisible = this.opt('weekNumbers');
				this.dayGrid.numbersVisible = this.dayNumbersVisible || this.weekNumbersVisible;

				this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());
				this.renderHead();

				this.scrollerEl = this.el.find('.fc-day-grid-container');

				this.dayGrid.setElement(this.el.find('.fc-day-grid'));
				this.dayGrid.renderDates(this.hasRigidRows());
			},


			// render the day-of-week headers
			renderHead: function () {
				this.headContainerEl =
					this.el.find('.fc-head-container')
						.html(this.dayGrid.renderHeadHtml());
				this.headRowEl = this.headContainerEl.find('.fc-row');
			},


			// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
			// always completely kill the dayGrid's rendering.
			unrenderDates: function () {
				this.dayGrid.unrenderDates();
				this.dayGrid.removeElement();
			},


			renderBusinessHours: function () {
				this.dayGrid.renderBusinessHours();
			},


			// Builds the HTML skeleton for the view.
			// The day-grid component will render inside of a container defined by this HTML.
			renderSkeletonHtml: function () {
				return '' +
					'<table>' +
					'<thead class="fc-head">' +
					'<tr>' +
					'<td class="fc-head-container ' + this.widgetHeaderClass + '"></td>' +
					'</tr>' +
					'</thead>' +
					'<tbody class="fc-body">' +
					'<tr>' +
					'<td class="' + this.widgetContentClass + '">' +
					'<div class="fc-day-grid-container">' +
					'<div class="fc-day-grid"/>' +
					'</div>' +
					'</td>' +
					'</tr>' +
					'</tbody>' +
					'</table>';
			},


			// Generates an HTML attribute string for setting the width of the week number column, if it is known
			weekNumberStyleAttr: function () {
				if (this.weekNumberWidth !== null) {
					return 'style="width:' + this.weekNumberWidth + 'px"';
				}
				return '';
			},


			// Determines whether each row should have a constant height
			hasRigidRows: function () {
				var eventLimit = this.opt('eventLimit');
				return eventLimit && typeof eventLimit !== 'number';
			},


			/* Dimensions
			 ------------------------------------------------------------------------------------------------------------------*/


			// Refreshes the horizontal dimensions of the view
			updateWidth: function () {
				if (this.weekNumbersVisible) {
					// Make sure all week number cells running down the side have the same width.
					// Record the width for cells created later.
					this.weekNumberWidth = matchCellWidths(
						this.el.find('.fc-week-number')
					);
				}
			},


			// Adjusts the vertical dimensions of the view to the specified values
			setHeight: function (totalHeight, isAuto) {
				var eventLimit = this.opt('eventLimit');
				var scrollerHeight;

				// reset all heights to be natural
				unsetScroller(this.scrollerEl);
				uncompensateScroll(this.headRowEl);

				this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed

				// is the event limit a constant level number?
				if (eventLimit && typeof eventLimit === 'number') {
					this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after
				}

				scrollerHeight = this.computeScrollerHeight(totalHeight);
				this.setGridHeight(scrollerHeight, isAuto);

				// is the event limit dynamically calculated?
				if (eventLimit && typeof eventLimit !== 'number') {
					this.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set
				}

				if (!isAuto && setPotentialScroller(this.scrollerEl, scrollerHeight)) { // using scrollbars?

					compensateScroll(this.headRowEl, getScrollbarWidths(this.scrollerEl));

					// doing the scrollbar compensation might have created text overflow which created more height. redo
					scrollerHeight = this.computeScrollerHeight(totalHeight);
					this.scrollerEl.height(scrollerHeight);
				}
			},


			// Sets the height of just the DayGrid component in this view
			setGridHeight: function (height, isAuto) {
				if (isAuto) {
					undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding
				}
				else {
					distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows
				}
			},


			/* Hit Areas
			 ------------------------------------------------------------------------------------------------------------------*/
			// forward all hit-related method calls to dayGrid


			prepareHits: function () {
				this.dayGrid.prepareHits();
			},


			releaseHits: function () {
				this.dayGrid.releaseHits();
			},


			queryHit: function (left, top) {
				return this.dayGrid.queryHit(left, top);
			},


			getHitSpan: function (hit) {
				return this.dayGrid.getHitSpan(hit);
			},


			getHitEl: function (hit) {
				return this.dayGrid.getHitEl(hit);
			},


			/* Events
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders the given events onto the view and populates the segments array
			renderEvents: function (events) {
				this.dayGrid.renderEvents(events);

				this.updateHeight(); // must compensate for events that overflow the row
			},


			// Retrieves all segment objects that are rendered in the view
			getEventSegs: function () {
				return this.dayGrid.getEventSegs();
			},


			// Unrenders all event elements and clears internal segment data
			unrenderEvents: function () {
				this.dayGrid.unrenderEvents();

				// we DON'T need to call updateHeight() because:
				// A) a renderEvents() call always happens after this, which will eventually call updateHeight()
				// B) in IE8, this causes a flash whenever events are rerendered
			},


			/* Dragging (for both events and external elements)
			 ------------------------------------------------------------------------------------------------------------------*/


			// A returned value of `true` signals that a mock "helper" event has been rendered.
			renderDrag: function (dropLocation, seg) {
				return this.dayGrid.renderDrag(dropLocation, seg);
			},


			unrenderDrag: function () {
				this.dayGrid.unrenderDrag();
			},


			/* Selection
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders a visual indication of a selection
			renderSelection: function (span) {
				this.dayGrid.renderSelection(span);
			},


			// Unrenders a visual indications of a selection
			unrenderSelection: function () {
				this.dayGrid.unrenderSelection();
			}

		});


// Methods that will customize the rendering behavior of the BasicView's dayGrid
		var basicDayGridMethods = {


			// Generates the HTML that will go before the day-of week header cells
			renderHeadIntroHtml: function () {
				var view = this.view;

				if (view.weekNumbersVisible) {
					return '' +
						'<th class="fc-week-number ' + view.widgetHeaderClass + '" ' + view.weekNumberStyleAttr() + '>' +
						'<span>' + // needed for matchCellWidths
						htmlEscape(view.opt('weekNumberTitle')) +
						'</span>' +
						'</th>';
				}

				return '';
			},


			// Generates the HTML that will go before content-skeleton cells that display the day/week numbers
			renderNumberIntroHtml: function (row) {
				var view = this.view;

				if (view.weekNumbersVisible) {
					return '' +
						'<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '>' +
						'<span>' + // needed for matchCellWidths
						this.getCellDate(row, 0).format('w') +
						'</span>' +
						'</td>';
				}

				return '';
			},


			// Generates the HTML that goes before the day bg cells for each day-row
			renderBgIntroHtml: function () {
				var view = this.view;

				if (view.weekNumbersVisible) {
					return '<td class="fc-week-number ' + view.widgetContentClass + '" ' +
						view.weekNumberStyleAttr() + '></td>';
				}

				return '';
			},


			// Generates the HTML that goes before every other type of row generated by DayGrid.
			// Affects helper-skeleton and highlight-skeleton rows.
			renderIntroHtml: function () {
				var view = this.view;

				if (view.weekNumbersVisible) {
					return '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '></td>';
				}

				return '';
			}

		};

		;
		;

		/* A month view with day cells running in rows (one-per-week) and columns
		 ----------------------------------------------------------------------------------------------------------------------*/

		var MonthView = FC.MonthView = BasicView.extend({

			// Produces information about what range to display
			computeRange: function (date) {
				var range = BasicView.prototype.computeRange.call(this, date); // get value from super-method
				var rowCnt;

				// ensure 6 weeks
				if (this.isFixedWeeks()) {
					rowCnt = Math.ceil(range.end.diff(range.start, 'weeks', true)); // could be partial weeks due to hiddenDays
					range.end.add(6 - rowCnt, 'weeks');
				}

				return range;
			},


			// Overrides the default BasicView behavior to have special multi-week auto-height logic
			setGridHeight: function (height, isAuto) {

				isAuto = isAuto || this.opt('weekMode') === 'variable'; // LEGACY: weekMode is deprecated

				// if auto, make the height of each row the height that it would be if there were 6 weeks
				if (isAuto) {
					height *= this.rowCnt / 6;
				}

				distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows
			},


			isFixedWeeks: function () {
				var weekMode = this.opt('weekMode'); // LEGACY: weekMode is deprecated
				if (weekMode) {
					return weekMode === 'fixed'; // if any other type of weekMode, assume NOT fixed
				}

				return this.opt('fixedWeekCount');
			}

		});

		;
		;

		fcViews.basic = {
			'class': BasicView
		};

		fcViews.basicDay = {
			type: 'basic',
			duration: {days: 1}
		};

		fcViews.basicWeek = {
			type: 'basic',
			duration: {weeks: 1}
		};

		fcViews.month = {
			'class': MonthView,
			duration: {months: 1}, // important for prev/next
			defaults: {
				fixedWeekCount: true
			}
		};
		;
		;

		/* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.
		 ----------------------------------------------------------------------------------------------------------------------*/
// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).
// Responsible for managing width/height.

		var AgendaView = FC.AgendaView = View.extend({

			timeGridClass: TimeGrid, // class used to instantiate the timeGrid. subclasses can override
			timeGrid: null, // the main time-grid subcomponent of this view

			dayGridClass: DayGrid, // class used to instantiate the dayGrid. subclasses can override
			dayGrid: null, // the "all-day" subcomponent. if all-day is turned off, this will be null

			axisWidth: null, // the width of the time axis running down the side

			headContainerEl: null, // div that hold's the timeGrid's rendered date header
			noScrollRowEls: null, // set of fake row elements that must compensate when scrollerEl has scrollbars

			// when the time-grid isn't tall enough to occupy the given height, we render an <hr> underneath
			bottomRuleEl: null,
			bottomRuleHeight: null,


			initialize: function () {
				this.timeGrid = this.instantiateTimeGrid();

				if (this.opt('allDaySlot')) { // should we display the "all-day" area?
					this.dayGrid = this.instantiateDayGrid(); // the all-day subcomponent of this view
				}
			},


			// Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass
			instantiateTimeGrid: function () {
				var subclass = this.timeGridClass.extend(agendaTimeGridMethods);

				return new subclass(this);
			},


			// Instantiates the DayGrid object this view might need. Draws from this.dayGridClass
			instantiateDayGrid: function () {
				var subclass = this.dayGridClass.extend(agendaDayGridMethods);

				return new subclass(this);
			},


			/* Rendering
			 ------------------------------------------------------------------------------------------------------------------*/


			// Sets the display range and computes all necessary dates
			setRange: function (range) {
				View.prototype.setRange.call(this, range); // call the super-method

				this.timeGrid.setRange(range);
				if (this.dayGrid) {
					this.dayGrid.setRange(range);
				}
			},


			// Renders the view into `this.el`, which has already been assigned
			renderDates: function () {

				this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());
				this.renderHead();

				// the element that wraps the time-grid that will probably scroll
				this.scrollerEl = this.el.find('.fc-time-grid-container');

				this.timeGrid.setElement(this.el.find('.fc-time-grid'));
				this.timeGrid.renderDates();

				// the <hr> that sometimes displays under the time-grid
				this.bottomRuleEl = $('<hr class="fc-divider ' + this.widgetHeaderClass + '"/>')
					.appendTo(this.timeGrid.el); // inject it into the time-grid

				if (this.dayGrid) {
					this.dayGrid.setElement(this.el.find('.fc-day-grid'));
					this.dayGrid.renderDates();

					// have the day-grid extend it's coordinate area over the <hr> dividing the two grids
					this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();
				}

				this.noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)'); // fake rows not within the scroller
			},


			// render the day-of-week headers
			renderHead: function () {
				this.headContainerEl =
					this.el.find('.fc-head-container')
						.html(this.timeGrid.renderHeadHtml());
			},


			// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
			// always completely kill each grid's rendering.
			unrenderDates: function () {
				this.timeGrid.unrenderDates();
				this.timeGrid.removeElement();

				if (this.dayGrid) {
					this.dayGrid.unrenderDates();
					this.dayGrid.removeElement();
				}
			},


			renderBusinessHours: function () {
				this.timeGrid.renderBusinessHours();

				if (this.dayGrid) {
					this.dayGrid.renderBusinessHours();
				}
			},


			// Builds the HTML skeleton for the view.
			// The day-grid and time-grid components will render inside containers defined by this HTML.
			renderSkeletonHtml: function () {
				return '' +
					'<table>' +
					'<thead class="fc-head">' +
					'<tr>' +
					'<td class="fc-head-container ' + this.widgetHeaderClass + '"></td>' +
					'</tr>' +
					'</thead>' +
					'<tbody class="fc-body">' +
					'<tr>' +
					'<td class="' + this.widgetContentClass + '">' +
					(this.dayGrid ?
						'<div class="fc-day-grid"/>' +
						'<hr class="fc-divider ' + this.widgetHeaderClass + '"/>' :
							''
					) +
					'<div class="fc-time-grid-container">' +
					'<div class="fc-time-grid"/>' +
					'</div>' +
					'</td>' +
					'</tr>' +
					'</tbody>' +
					'</table>';
			},


			// Generates an HTML attribute string for setting the width of the axis, if it is known
			axisStyleAttr: function () {
				if (this.axisWidth !== null) {
					return 'style="width:' + this.axisWidth + 'px"';
				}
				return '';
			},


			/* Dimensions
			 ------------------------------------------------------------------------------------------------------------------*/


			updateSize: function (isResize) {
				this.timeGrid.updateSize(isResize);

				View.prototype.updateSize.call(this, isResize); // call the super-method
			},


			// Refreshes the horizontal dimensions of the view
			updateWidth: function () {
				// make all axis cells line up, and record the width so newly created axis cells will have it
				this.axisWidth = matchCellWidths(this.el.find('.fc-axis'));
			},


			// Adjusts the vertical dimensions of the view to the specified values
			setHeight: function (totalHeight, isAuto) {
				var eventLimit;
				var scrollerHeight;

				if (this.bottomRuleHeight === null) {
					// calculate the height of the rule the very first time
					this.bottomRuleHeight = this.bottomRuleEl.outerHeight();
				}
				this.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary

				// reset all dimensions back to the original state
				this.scrollerEl.css('overflow', '');
				unsetScroller(this.scrollerEl);
				uncompensateScroll(this.noScrollRowEls);

				// limit number of events in the all-day area
				if (this.dayGrid) {
					this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed

					eventLimit = this.opt('eventLimit');
					if (eventLimit && typeof eventLimit !== 'number') {
						eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure "auto" goes to a real number
					}
					if (eventLimit) {
						this.dayGrid.limitRows(eventLimit);
					}
				}

				if (!isAuto) { // should we force dimensions of the scroll container, or let the contents be natural height?

					scrollerHeight = this.computeScrollerHeight(totalHeight);
					if (setPotentialScroller(this.scrollerEl, scrollerHeight)) { // using scrollbars?

						// make the all-day and header rows lines up
						compensateScroll(this.noScrollRowEls, getScrollbarWidths(this.scrollerEl));

						// the scrollbar compensation might have changed text flow, which might affect height, so recalculate
						// and reapply the desired height to the scroller.
						scrollerHeight = this.computeScrollerHeight(totalHeight);
						this.scrollerEl.height(scrollerHeight);
					}
					else { // no scrollbars
						// still, force a height and display the bottom rule (marks the end of day)
						this.scrollerEl.height(scrollerHeight).css('overflow', 'hidden'); // in case <hr> goes outside
						this.bottomRuleEl.show();
					}
				}
			},


			// Computes the initial pre-configured scroll state prior to allowing the user to change it
			computeInitialScroll: function () {
				var scrollTime = moment.duration(this.opt('scrollTime'));
				var top = this.timeGrid.computeTimeTop(scrollTime);

				// zoom can give weird floating-point values. rather scroll a little bit further
				top = Math.ceil(top);

				if (top) {
					top++; // to overcome top border that slots beyond the first have. looks better
				}

				return top;
			},


			/* Hit Areas
			 ------------------------------------------------------------------------------------------------------------------*/
			// forward all hit-related method calls to the grids (dayGrid might not be defined)


			prepareHits: function () {
				this.timeGrid.prepareHits();
				if (this.dayGrid) {
					this.dayGrid.prepareHits();
				}
			},


			releaseHits: function () {
				this.timeGrid.releaseHits();
				if (this.dayGrid) {
					this.dayGrid.releaseHits();
				}
			},


			queryHit: function (left, top) {
				var hit = this.timeGrid.queryHit(left, top);

				if (!hit && this.dayGrid) {
					hit = this.dayGrid.queryHit(left, top);
				}

				return hit;
			},


			getHitSpan: function (hit) {
				// TODO: hit.component is set as a hack to identify where the hit came from
				return hit.component.getHitSpan(hit);
			},


			getHitEl: function (hit) {
				// TODO: hit.component is set as a hack to identify where the hit came from
				return hit.component.getHitEl(hit);
			},


			/* Events
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders events onto the view and populates the View's segment array
			renderEvents: function (events) {
				var dayEvents = [];
				var timedEvents = [];
				var daySegs = [];
				var timedSegs;
				var i;

				// separate the events into all-day and timed
				for (i = 0; i < events.length; i++) {
					if (events[i].allDay) {
						dayEvents.push(events[i]);
					}
					else {
						timedEvents.push(events[i]);
					}
				}

				// render the events in the subcomponents
				timedSegs = this.timeGrid.renderEvents(timedEvents);
				if (this.dayGrid) {
					daySegs = this.dayGrid.renderEvents(dayEvents);
				}

				// the all-day area is flexible and might have a lot of events, so shift the height
				this.updateHeight();
			},


			// Retrieves all segment objects that are rendered in the view
			getEventSegs: function () {
				return this.timeGrid.getEventSegs().concat(
					this.dayGrid ? this.dayGrid.getEventSegs() : []
				);
			},


			// Unrenders all event elements and clears internal segment data
			unrenderEvents: function () {

				// unrender the events in the subcomponents
				this.timeGrid.unrenderEvents();
				if (this.dayGrid) {
					this.dayGrid.unrenderEvents();
				}

				// we DON'T need to call updateHeight() because:
				// A) a renderEvents() call always happens after this, which will eventually call updateHeight()
				// B) in IE8, this causes a flash whenever events are rerendered
			},


			/* Dragging (for events and external elements)
			 ------------------------------------------------------------------------------------------------------------------*/


			// A returned value of `true` signals that a mock "helper" event has been rendered.
			renderDrag: function (dropLocation, seg) {
				if (dropLocation.start.hasTime()) {
					return this.timeGrid.renderDrag(dropLocation, seg);
				}
				else if (this.dayGrid) {
					return this.dayGrid.renderDrag(dropLocation, seg);
				}
			},


			unrenderDrag: function () {
				this.timeGrid.unrenderDrag();
				if (this.dayGrid) {
					this.dayGrid.unrenderDrag();
				}
			},


			/* Selection
			 ------------------------------------------------------------------------------------------------------------------*/


			// Renders a visual indication of a selection
			renderSelection: function (span) {
				if (span.start.hasTime() || span.end.hasTime()) {
					this.timeGrid.renderSelection(span);
				}
				else if (this.dayGrid) {
					this.dayGrid.renderSelection(span);
				}
			},


			// Unrenders a visual indications of a selection
			unrenderSelection: function () {
				this.timeGrid.unrenderSelection();
				if (this.dayGrid) {
					this.dayGrid.unrenderSelection();
				}
			}

		});


// Methods that will customize the rendering behavior of the AgendaView's timeGrid
		var agendaTimeGridMethods = {


			// Generates the HTML that will go before the day-of week header cells
			renderHeadIntroHtml: function () {
				var view = this.view;
				var weekText;

				if (view.opt('weekNumbers')) {
					weekText = this.start.format(view.opt('smallWeekFormat'));

					return '' +
						'<th class="fc-axis fc-week-number ' + view.widgetHeaderClass + '" ' + view.axisStyleAttr() + '>' +
						'<span>' + // needed for matchCellWidths
						htmlEscape(weekText) +
						'</span>' +
						'</th>';
				}
				else {
					return '<th class="fc-axis ' + view.widgetHeaderClass + '" ' + view.axisStyleAttr() + '></th>';
				}
			},


			// Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.
			renderBgIntroHtml: function () {
				var view = this.view;

				return '<td class="fc-axis ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '></td>';
			},


			// Generates the HTML that goes before all other types of cells.
			// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
			renderIntroHtml: function () {
				var view = this.view;

				return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
			}

		};


// Methods that will customize the rendering behavior of the AgendaView's dayGrid
		var agendaDayGridMethods = {


			// Generates the HTML that goes before the all-day cells
			renderBgIntroHtml: function () {
				var view = this.view;

				return '' +
					'<td class="fc-axis ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '>' +
					'<span>' + // needed for matchCellWidths
					(view.opt('allDayHtml') || htmlEscape(view.opt('allDayText'))) +
					'</span>' +
					'</td>';
			},


			// Generates the HTML that goes before all other types of cells.
			// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
			renderIntroHtml: function () {
				var view = this.view;

				return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
			}

		};

		;
		;

		var AGENDA_ALL_DAY_EVENT_LIMIT = 5;

// potential nice values for the slot-duration and interval-duration
// from largest to smallest
		var AGENDA_STOCK_SUB_DURATIONS = [
			{hours: 1},
			{minutes: 30},
			{minutes: 15},
			{seconds: 30},
			{seconds: 15}
		];

		fcViews.agenda = {
			'class': AgendaView,
			defaults: {
				allDaySlot: true,
				allDayText: 'all-day',
				slotDuration: '00:30:00',
				minTime: '00:00:00',
				maxTime: '24:00:00',
				slotEventOverlap: true // a bad name. confused with overlap/constraint system
			}
		};

		fcViews.agendaDay = {
			type: 'agenda',
			duration: {days: 1}
		};

		fcViews.agendaWeek = {
			type: 'agenda',
			duration: {weeks: 1}
		};
		;
		;

		return FC; // export for Node/CommonJS
	});var MyConfig = 
{
	name: "v7-web-config",
	ver: "7.54.2.08131800",
	root: "../../web/",  // 网管的静态URL的根目录，即web目录
	path: "/v3",  // Ajax请求一级路由
	v2path:"/v3/ace/o2oportal", // Ajax请求一级路由 v2路由
	username:"",//摘要认证的用户名 密码
	password:"",
	httperror:"HTTP或HTTPS请求错误服务器内部错误" ,//ajax error http请求错错误
	responseWidth: 800, // if the window width is less it, the layout of the page will be changed.
	Layout:
	{
		enable: false,
		width1: 768,
		width2: 980,
		width3: 1100
	},
	titleSeperator: " | ",
	config:
	{
		//debuger: false,
		keepAlive: 5000, // 心跳时间间隔, 毫秒
		checkTimeout: 1000, // 检查是否超时的时间间隔
		menuDelay: 200,     // 点击菜单、后退、前进、跳转超链接等后页面开始响应的时间间隔
		cachePage: true, // 是否缓存静态HTML和JS文件
		effect:true
	},
	helpPanel:
	{
		size: "75%"
	},
	Dialog:
	{
		DEFAULT:{height:"auto", width:400},
		INFO:    // 提示框配置
		{
			width: 500, 
			height: 40,
			visibleTime:2000,        //自动关闭的时间 ms
			position:"center-center" //位置: 可以支持 top|center|bottom - left|center|right 的任意组合
		},
		ALERT:{},
		CONFIRM:{},
		ERROR:{},
		PROMPT:{},
		FORM: {height:"auto", width:"auto"}
	},
	Plot:
	{
		maxPoint: 100,
		width: 250
	},
	Syslog:
	{
		severity: ["Emergency","Alert","Critical","Error","Warning","Notification","Informational","Debugging"], // 日志级别定义
		lastestCount: 5
	},
	MList:
	{
		errorVisible: 2000, // 行编辑时错误提示信息可见的时间
		smallWidth: 600,
		subRowHeight: 43
		,searchDelay: 500  // ms, delay for gloable search
		,selectMode: "pc"  // pc or mobile
		,rowHeight: 23
		,ROW_MARGIN: 20   // include margin top and bottom
		,pageBar: true
		,statusBar: true

		,EditList: "cell" // Display mode of EditList, the value is "block" or "cell"
	},
	jDate:
	{
		DEFAULT:
		{
			// Default regional settings
			numberOfMonths: 1,
			stepMonths: 2,
			showOtherMonths: true,
			selectOtherMonths: true,
			changeMonth: true,
			changeYear: true,
			yearRange: '2000:2035',
			dateFormat:	'yy-mm-dd',
			isRTL: false,
			showMonthAfterYear:	true,
			//showOptions:{direction:"up"},
			showButtonPanel: true
		},
		INLINE:
		{
			numberOfMonths: 1,
			stepMonths: 1,
			altFormat: 'yy-mm-dd',
			showButtonPanel: false
		}
	},
	PageRefresh:    // 单位: 秒
	{
		SysInfo: 1,
		IfStat: 1
	}
}
var Frame = {};
var Utils = {};

$.MyLocale = {};

function getPageWidth()
{
    return $("body").width();
}

/*****************************************************************************
@FuncName, Class, menuBar
@DateCreated: 2013-06-08
@Author: 
@Description: process menu
@Usage:
@ParaIn:
@Return: 
@Caution:
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
function MenuBar()
{
    this.initMenu = initMenu;
	this.resizeMenu = resize;

    var resizeCount = 0;
    var oTimer  = null;

    function onMenuClick(e)
    {
        var sMenuId = $(this).attr("href");
        var hasChanged = !!$("#tabContent .app-box .form-actions:visible").length;
        if(hasChanged && sMenuId.search(Frame.NewMenu.getCurMenuId()) == -1)
        {
            Frame.Msg.confirm($.MyLocale.SKIP_CONFIRM, {
                onOK : function(){window.location = sMenuId;},
                sId : "form_modify_confirm"
            });
        }

        return !hasChanged;
    }

    function onFlowMenu(e)
    {
        var jContent = $('#side_menu');
        var jMenu = $('.page-sidebar-menu',jContent);
        var nTop = jMenu.css('marginTop').replace('px',"")*1;
        var bIsUp = $(this).hasClass('down');
        var nGap = jContent.height()-jMenu.height();

        nGap = nGap > 0 ? 0 : nGap;
        bIsUp ? (nTop -= 78*2) : (nTop += 78*2);
        nTop  = nTop > 0 ? 0 : (nTop < nGap ? nGap : nTop);

        jMenu.animate({marginTop:nTop+'px'},200);
    }

    function resize()
    {
        var jContent = $('#side_menu');
        var jMenu = $('.page-sidebar-menu',jContent);

        if(jMenu.children('li').css("marginBottom") != '40px' && resizeCount < 10)
        {
            oTimer && clearTimeout(this.oTimer);
            oTimer = setTimeout(resize,200);
            resizeCount ++;
            return false;
        }
        resizeCount = 0;

        if(jMenu.height() < jContent.height())
        {
            $('.menu-ctrl').fadeOut(100);
            jContent.css({bottom:0});
            jMenu.animate({marginTop:0+'px'},200);
        }
        else
        {
            $('.menu-ctrl').fadeIn(100);
            jContent.css({bottom:'12px'});
        }
    }

	function initMenu()
	{
        // add events
        $('#side_menu .page-sidebar-menu')
            .on('click', 'li > a', onMenuClick);
        $('.menu-ctrl').off('click.menuCtrl').on('click.menuCtrl',onFlowMenu);
    }
}

var Tablet = {
    resize: function()
    {
        //summary view
        var jPageCont = $("#tabContent");
        //echart
        $(".myEchart", jPageCont).each(function(index,item){
            var jEle = $(this);
            if(jEle.is(":visible"))
            {
                jEle = $(this).data("instance");
                jEle && jEle.chart && jEle.resize();
            }
        });

    },
    init: function (bOpened)
    {
        
    },
    openNewPage: function()
    {
        
    },
    closeNewPage: function()
    {
        
    },
    onBodyClick: function(e)
    {

    }
}

var DeskPC = {
    resize: function()
    {
        var nScreenWidth = getPageWidth();
        var w = 200;
        $("#menu_div").width(w);
        var w2 = (nScreenWidth - w)/2;
        $("#edit_div").width(w2);
        $("#summary_div").width(w2);
    },
    init: function ()
    {
        $("#menu_div").show();
        $("#summary_div").show();
        $("#edit_div").show();

        MyConfig.MList.selectMode = "pc";
    },
    openNewPage: function()
    {
        $("#edit_div").show();
    },
    closeNewPage: function()
    {
        $("#edit_div").hide();
    },
    onBodyClick: function(e)
    {
        
    }
}

function UserBar()
{
    function onLogout()
    {
        $.cookie("current_menu","");
        Frame.Msg.confirm($.MyLocale.LOGOUT_CONFIRM, function(){ window.location ="/v3/logout";});
        return false;
    }

    function onPassWord()
    {
        Utils.Base.openDlg("dashboard.changepassword", {}, {className:"modal-large"});
        return false;
    }

    function backHome()
    {
        $.cookie("current_menu","");
        window.location.href ="http://lvzhou.h3c.com/o2o/o2omng/homePage/homePage.xhtml";
        return false;
    }

    function backSystem()
    {
        $.cookie("current_menu","");
        window.location.href ="http://lvzhou.h3c.com/o2o/o2omng/shop/shopList.jsf?faces-redirect=true";
        return false;
    }
    function toForum()
    {
        window.open("http://bbswlan.h3c.com/forum.php?mod=forumdisplay&fid=58");
        return false;
    }

    function onItemClick(e)
    {
        var sIndex = $(this).attr("index");
        var pfMap = [onPassWord,backHome,onLogout,backSystem,toForum];
        pfMap[sIndex]();
    }

    function toggleUserMenu(e)
    {
        function show()
        {
            jMenu.slideDown(200);
            $('body').on('click.usermenu',hide);
        }
        function hide()
        {
            jMenu.slideUp(200);
            jMenu.prev().removeClass("active");
            $('body').off('click.usermenu');
        }
        
        var jMenu = $("#drop_list");
        $(this).toggleClass('active');
        jMenu.is(':visible') ? hide() : show();

        e.stopPropagation();
    }

    function initUser()
    {
        $("#user_menu").unbind('click').bind('click',toggleUserMenu);
       /* $("#chat_html").unbind('click').bind('click','li',onService);*/
        $("#drop_list").off('click').on('click','li',onItemClick);
        //headImg and chatImg
       // alert( FrameInfo.g_user.JSESSIONID);
        var chat = $("#chat_html").xiaoBeiChat({xiaobeiPath:"../../web/chat/cn/chat.html",sessionId:FrameInfo.g_user.JSESSIONID})
        chat.bind("newMsg",function(e, data){
            if(data){
                $("#chat_html").removeClass();
                $("#chat_html").addClass("message_icon_get");
            }else{
                $("#chat_html").removeClass();
                $("#chat_html").addClass("message_icon");
            }
        })
        chat.bind("chatHeadImg",function(e, data){
            if(data){
                //  设置自己的头像
                $("#headerimg").attr("src", data);
            }
        })
    }

    this.initUser = initUser;

}

/*****************************************************************************
@FuncName, Class, MainFrame
@DateCreated: 2013-06-08
@Author: 
@Description: process main MainFrame
@Usage:
@ParaIn:
@Return: 
@Caution:
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
function MainFrame()
{

	var _oMenuBar = new MenuBar();
    var _oUsetrBar = new UserBar();
    var _oCurDevice = false;
    var _bOpened = false;
    function getuserSession(){
        $.ajax({
                url: MyConfig.v2path+"/getDeviceInfo",
                type: "POST",
                headers:{Accept:"application/json"},
                contentType: "application/json",
                data: JSON.stringify({"tenant_name": FrameInfo.g_user.attributes.name, "dev_snlist":[]}),
                dataType: "json",
                success: function(data){
                    getAcInfo(data.dev_list);
                },
                error:function(err){
                    //alert(err);
                }
            });
    }
    getuserSession();
    changeAC();

    function getAcInfo(aclist){
        var XbeiACModel = ["H3C WAC350","H3C WAC360","H3C WAC360V2","H3C WAC361V2","H3C WAC365"];
        var XXbeiACModel = ["WAP422","WAP422S"];
        var AcInfo = [];
        var opShtmlTemple = "<option value=vals data-value=datas sel>palce</option>";
       /* var opShtml="<option value='";
        var opVhtml="' data-value='";
        var opHhtml="'>";
        var opEhtml="</option> ";
        var ophtml="";*/
        for(var i = 0 ;i<aclist.length; i++){
            if(aclist[i].shop_name){
                AcInfo.push({
                    cs: aclist[i].shop_name,
                    sn:aclist[i].dev_sn,
                    dev_model:aclist[i].dev_model
                });
            }
           /* AcInfo.push({
                cs: aclist[i].shop_name||aclist[i].dev_sn,
                sn:aclist[i].dev_sn,
                dev_model:aclist[i].dev_model
            });*/
        }
        if(!AcInfo){
            var ophtml="<option></option>"
            $("#station").append(ophtml);

        }else{
            for(var i =0;i<AcInfo.length;i++){
                var newHtmTemple=opShtmlTemple.replace(/vals/g,AcInfo[i].sn).replace(/palce/g,AcInfo[i].cs);
                var newHtmlTemple_1="";
                if(FrameInfo.ACSN==AcInfo[i].sn){
                    newHtmlTemple_1=newHtmTemple.replace(/sel/g,"selected");
                }else{
                    newHtmlTemple_1 =newHtmTemple.replace(/sel/g,"");
                }
                var finalHtmTemplet  = "";
                if(AcInfo[i].dev_model&&$.inArray(AcInfo[i].dev_model.toUpperCase(),XbeiACModel)!= -1){
                    finalHtmTemplet = newHtmlTemple_1.replace(/datas/g,"0");
                }else if(AcInfo[i].dev_model&&$.inArray(AcInfo[i].dev_model.toUpperCase(),XXbeiACModel)!= -1){
                    finalHtmTemplet = newHtmlTemple_1.replace(/datas/g,"1");
                }else if(AcInfo[i].sn=="15810819002"){
                    finalHtmTemplet = newHtmlTemple_1.replace(/datas/g,"3");
                }else{
                    finalHtmTemplet = newHtmlTemple_1.replace(/datas/g,"2");
                }
                $("#station").append(finalHtmTemplet);
               /* if(FrameInfo.ACSN==AcInfo[i].sn){
                    opHhtml= "' selected >"
                }else{
                    opHhtml="'>"
                }
                //ophtml +=opShtml+AcInfo[i].sn+opHhtml+AcInfo[i].cs+opEhtml;
                var  model = null;
                if(AcInfo[i].dev_model&&$.inArray(AcInfo[i].dev_model.toUpperCase(),XbeiACModel)!= -1){
                    model = 0;
                }else if(AcInfo[i].dev_model&&$.inArray(AcInfo[i].dev_model.toUpperCase(),XXbeiACModel)!= -1){
                    model = 1;
                }else{
                    model = 2;
                }

                ophtml +=opShtml+AcInfo[i].sn+opVhtml+model+opHhtml+AcInfo[i].cs+opEhtml;*/
            }
            //$("#station").append(ophtml);
        }

    }
    function changeAC(){
        $("#station").bind("change",function(){
            $.cookie("current_menu","");
            var desn= $("#station option:selected").attr("value");
           // window.location="/v3/web/frame/index.html?model=0&sn="+desn;
            var model= $("#station option:selected").attr("data-value");
            if(model==0){
                window.location="/v3/web/frame/index.html?model=0&sn="+desn;
            }else if(model == 1){
                window.location="/v3/web/frame/miniBeiIndex.html?model=1&sn="+desn;
            }else if(model == 3){
                window.location="/v3/web/frame/business.html?model=3&sn="+desn;
            }else {
                window.location="/v3/web/frame/businessAcIndex.html?model=2&sn="+desn;
            }
            //window.location="/v3/web/frame/index.html?sn="+desn;
        });
    }

    function onNewPageOpen()
    {
        _bOpened = true;
        _oCurDevice.openNewPage();
    }

    function onNewPageClose()
    {
        _bOpened = false;
        _oCurDevice.closeNewPage();
    }

    function onNewPageResize()
    {
        _oCurDevice.resize();
    }

    function onBodyClick(e)
    {
        _oCurDevice.onBodyClick(e);
    }

    function onMenuReady()
    {
       _oMenuBar.initMenu();
       _oUsetrBar.initUser();
    }

    function onMenuResize()
    {
        _oMenuBar.resizeMenu();
    }

    function getDeviceByWidth()
    {
        var oDevice;
        var nScreenWidth = getPageWidth();

        /*if(nScreenWidth >= MyConfig.Layout.width2)
        {
        }
        else if(nScreenWidth >= MyConfig.Layout.width1)
        {
            oDevice = Mobile; // Tablet
        }
        else
        {
            oDevice = Mobile;
        }*/

        oDevice = Tablet; //DeskPC;
        if(_oCurDevice != oDevice)
        {
          //  oDevice.init(_bOpened);
            _oCurDevice = oDevice;
        }

        return oDevice;
    }

    function doResize()
    {
        getDeviceByWidth();
        _oCurDevice.resize($(window).height());
        Frame.notify("all", "resize");
    }

    function initResize()
    {
        var oTimer;
        var oScrn = document.documentElement;
        var oOldScrn = {"width": oScrn.clientWidth, "height": oScrn.clientHeight};

        $(window).resize(function() 
        {
            if((oOldScrn.height == oScrn.clientHeight) && (oOldScrn.width == oScrn.clientWidth))
            {
                return;
            }

            oOldScrn = {"width": oScrn.clientWidth, "height": oScrn.clientHeight};

            if (oTimer) 
            {
                clearTimeout(oTimer);
            }
            oTimer = setTimeout(function() {doResize();}, 200);
        });
    }

    function initFrameCenter()
    {
        var _jFrame = $('.page-sidebar-fixed ');
        var bIsIE8 = isIE8Browser();
        if(bIsIE8)
        {
            _jFrame.addClass("ie8");
        }

        function isIE8Browser()
        {
            var bIE8 = false;
            if($.browser.msie && (parseInt($.browser.version) == 8))
            {
                bIE8 = true;
            }
            return bIE8;
        }    
    }

    Frame.regNotify("newPage", "open", onNewPageOpen);
    Frame.regNotify("newPage", "close", onNewPageClose);
    Frame.regNotify("newPage", "resize", onNewPageResize);
    Frame.regNotify("menu", "resize", onMenuResize);

    $("body").addClass("page-header-fixed page-sidebar-fixed page-footer-fixed");
    $(".header").removeClass("navbar-static-top").addClass("navbar-fixed-top");

    initFrameCenter();
    initResize();
    doResize();

    $("body").on("click", onBodyClick);
    //menu 切换到不同的模块处理
    /*if(FrameInfo.Model==0&&$.cookie("current_menu")=="summary"){
        $.cookie("current_menu","");
    }*/
    
    $(".xb-layout-north ul").delegate("li","click",function(){ 
        var dvalue = $(this).children("a").attr("data-value");
        window.location.hash="#";//
        $(".xb-layout-north ul li a[data-value="+$.cookie("current_menu")+"]").removeClass("active");
        $(this).children("a").addClass("active")
        $("#dirText").text($(this).children("a").text());
        $.cookie("current_menu",dvalue);
        $("#frame_nav").children(".breadcrumb").remove();
        createMenu($("#side_menu"), $("#frame_tablist"), $("#frame_nav"), onMenuReady,dvalue);
    });
    if($.cookie("current_menu")){
        $(".xb-layout-north ul li a[data-value="+$.cookie("current_menu")+"]").addClass("active");
        var cokText = $(".xb-layout-north ul li a[data-value="+$.cookie("current_menu")+"]").text();
        $("#dirText").text(cokText);
        $("#frame_nav").children(".breadcrumb").remove();
        createMenu($("#side_menu"), $("#frame_tablist"), $("#frame_nav"), onMenuReady,$.cookie("current_menu"));
    }else{
        var firstVale=$(".xb-layout-north ul li:last-child").children("a").attr("data-value")
        $.cookie("current_menu",firstVale);
        $(".xb-layout-north ul li a[data-value='"+firstVale+"']").addClass("active");
        $("#frame_nav").children(".breadcrumb").remove();
        createMenu($("#side_menu"), $("#frame_tablist"),$("#frame_nav"), onMenuReady,firstVale);
    }
    Frame.init();
}


var g_oMainFrame;
var local  = false;

/*****************************************************************************
@FuncName, private, documentReady
@DateCreated: 2013-06-08
@Author: 
@Description: main entry
@Usage:
@ParaIn:
@Return: 
@Caution:
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
jQuery(document).ready(function() 
{

    if(!window.location.search||window.location.search.split("sn=")<=0){
        window.location=window.host+"/v3";
        return false
    };
    if(!window.location.search||window.location.search.split("model=")<=0){
        window.location=window.host+"/v3";
        return false
    }
    var searchData  = window.location.search.split("&");
    FrameInfo.ACSN =  searchData[1].split("sn=")[1].toLocaleUpperCase();
    //alert(FrameInfo.ACSN);
    FrameInfo.Model =   searchData[0].split("model=")[1];
   // alert(FrameInfo.Model);
    $.get("/v3/web/cas_session?refresh="+Math.random(),function(data){
        FrameInfo.g_user= data;
        if(data.attributes&&data.attributes.name.toLocaleLowerCase()=="demovistor"){
            $("#username").text("访客");
        }else{
            $("#username").text(data.user);
        }
        g_oMainFrame = new MainFrame();
    });

});


function createMenu(_jContainer, _jTabUl, oNav, pfReadyNotify,modelName)
{
    var _aMenuArray = false;
    var _oTabContent = $("#tabContent");
    var _aActive = [];
    var _oNav = $("<ul class='breadcrumb'></ul>").prependTo(oNav);
    var _aUrlTable = false;
    var _sDefaultMenuId = false;
    var _jActivePage = _oTabContent;
    var _bUseTab = true;
    var _sCustomUrl = false;
    var _TimeDelay  = null;
 //   var _hTimer = false;
 //   var _sQuickUrl = "#I_QuickNav";

    var _IconMap = {
        M_System: "icon-menu-system",
        M_QuickNav: "icon-menu-quick",
        M_YinYunPeiZhi: "icon-menu-network",
        M_YinYunGuanLi: "icon-menu-wireless",
        M_UserManager: "icon-menu-user",
        M_SecurityPolicy: "icon-menu-security",
        M_AppManager: "icon-menu-app",
        M_SystemCfg: "icon-menu-syscfg"
        
    };
    var _MenuXmlMap ={
        0:{
            network : "../init/xiaobei/system.xml",
            auth:"../init/xiaobei/auth.xml",
            manage:"../init/xiaobei/manage.xml",
            total : "../init/xiaobei/total.xml"
        },
        1:{
            network : "../init/xiaoxiaobei/system.xml",
            //auth:"../init/xiaoxiaobei/auth.xml",
            manage:"../init/xiaoxiaobei/manage.xml",
            total : "../init/xiaoxiaobei/total.xml" ,
            summary:"../init/xiaoxiaobei/summary.xml"
        },
        2:{
            network : "../init/businessac/network.xml",
            // manage:"../init/businessac/manage.xml",/*0316 fujiajia zhushidiao*/
            summary:"../init/businessac/summary.xml",
            operation:"../init/businessac/operation.xml"
        },
        3:{
            network : "../init/businesswifi/network.xml",
            dataanalysis:"../init/businesswifi/dataanalysis.xml",
            manage:"../init/businesswifi/manage.xml",
            maintain:"../init/businesswifi/maintain.xml"
        }
    };
/***************************************************************************************/
/* interval methods */
    function _getUrlById(sMenuId)
    {
        return _aUrlTable[sMenuId||_sDefaultMenuId];
    }
    function _loadModule(oUrlInfo)
    {
        // oUrlInfo.url is "ModuleName/[lang]/Page.html"
        var sUrl = _sCustomUrl || oUrlInfo.url;
        var aModId = sUrl.split(/[/.]/);

        sUrl = (aModId.length>3) ? (aModId[0]+"."+aModId[2]) : sUrl;
        Utils.Pages.loadModule(sUrl, null, _jActivePage);
    }

    function _updateModule(oUrlInfo)
    {
        // oUrlInfo.url is "ModuleName/[lang]/Page.html"
        var aModId = oUrlInfo.url.split(/[/.]/);
        var sUrl = (aModId.length>3) ? (aModId[0]+"."+aModId[2]) : oUrlInfo.url;
        Utils.Pages.updateModule(sUrl, {type:"update"}, _jActivePage);
    }

    function _isNewMenuItem(sMenuId)
    {
        var bNewItem = true;
        $.each($("a",_jTabUl), function(i, item)
        {
            if("#"+sMenuId == $(this).attr("href"))
            {
                bNewItem = false;
                return false;
            }
        });

        return bNewItem;
    }

    function _getRcText(oItem, type)
    {
        //type:"Menu","mainFrame" ...
        var oRcMsg = $.MyLocale[type];
        var sId = oItem.id || oItem;
        if(_isHelpId(sId))
        {
            sId = "HELP";
        }

        return oItem.desc || oRcMsg[sId];
    }
    
    function _makeUrlTable(oParent, aMenuData, aUrlInfo)
    {
        if(!aMenuData || aMenuData.length == 0)
        {
            return ;
        }

        for(var i=0; i<aMenuData.length; i++)
        {
            var oData = aMenuData[i];
            oData.parent = oParent;
            
            if(oData.submenu)
            {
                _makeUrlTable(oData, oData.submenu, aUrlInfo);
            }
            else if(oData.tabs)
            {
                _makeUrlTable(oData, oData.tabs, aUrlInfo);
            }
            else
            {
                aUrlInfo[oData.id] = oData;
                if(!_sDefaultMenuId)
                {
                     _sDefaultMenuId = oData.id;
                }
            }
        }
    }

/***************************************************************************************/
/* plugin: menu path */

    function _setWindowTitle (sTitle)
    {
	//var aTitle = [Frame.get("devname")];
        var aTitle = [_getRcText("Device_Name","Menu")];

        var jMenuItems = _jContainer.find("li.active>a");
        for (var i=0; i<jMenuItems.length; i++)
        {
            aTitle.push ($(jMenuItems[i]).text());
        }

        if(sTitle)
        {
            aTitle.push(sTitle);
        }

        document.title = aTitle.join(MyConfig.titleSeperator || " | ");
    }
/***************************************************************************************/
/* menu */

    function _activeMenuItems(oMenuItem)
    {
        while (_aActive.length)
        {
            _aActive.pop().removeClass("active");
        }
        
        var jLink = $("a[href=#"+oMenuItem.id+"]");

        if(jLink.length == 0 )
        {
            var sMenuId = oMenuItem.parent.tabs || [];
            sMenuId = sMenuId[0] || {};
            sMenuId = sMenuId.id || "";

            jLink = $("a[href=#"+sMenuId+"]");
        }

        var jParent = jLink.parent();
        while ((jParent.length>0) && !jParent.is(_jContainer))
        {
            if(jParent.is("li"))
            {
                jParent.addClass("active");
                _aActive.push(jParent);
            }
            jParent  = jParent.parent();
        }
    }

    function _makeSubMenu(aArray, iLevel)
    {
        if(!aArray || aArray.length == 0)
        {
            return ;
        }
        var aClass = ["page-sidebar-menu","first sub-menu","sub-menu","sub-menu","sub-menu"];
        var jUL = $('<ul class=' + '"' + aClass[iLevel] + '"' +'></ul>');

        for (var i = 0; i<aArray.length; i++)
        {
            var oCurItem = aArray[i];
            var jItem = $('<li></li>');
            var jLink = $('<a href="#' + oCurItem.id + '" title="'+_getRcText(oCurItem, "Menu")+'"></a>');

            //TODO:  is need icon ?
           // var sIcon = _IconMap[oCurItem.id];
            //var sIcon = "noIcon";

           /* if (sIcon)
            {
                // add custom menu icon
                $('<i class="menu-icon ' + sIcon + '"></i>').appendTo(jLink);
            }*/
            $('<i class="menu-icon icon-menu-system"></i>').appendTo(jLink);
            // menu node
            if ((oCurItem.submenu) || (oCurItem.tabs && !_bUseTab))
            {
                // add arrow icon
                $('<span class="menu-icon-arrow arrow"></span>').appendTo(jLink);
            }

            // add menu text
            $('<span class="menu-item"></span>')
                .text(_getRcText(oCurItem, "Menu"))
                .appendTo(jLink);

            jItem.append(jLink);

            if (oCurItem.submenu)
            {
                jItem.append(_makeSubMenu(oCurItem.submenu, iLevel+1));
            }

            else if (oCurItem.tabs)
            {
                if ( _bUseTab )
                {
                    // set the last menu-item link to the first tab item
                    jLink.attr("href", '#'+oCurItem.tabs[0].id);
                    jItem.data("tabs", oCurItem.tabs);
                }
                else
                {
                    jItem.append(_makeSubMenu(oCurItem.tabs, iLevel+1));
                }
            }
            jUL.append(jItem);
        }

        return jUL;
    }

    // main entry
    function _makeMenuMain()
    {
        var aMenuArry =  _aMenuArray;
        _jContainer.empty();
        _jContainer.append(_makeSubMenu(aMenuArry, 0));

        _aUrlTable = {};
        _makeUrlTable(null, aMenuArry, _aUrlTable);

        pfReadyNotify && pfReadyNotify();

       /* if(FrameInfo.isRunningCfg == "false")
        {
            window.location = _sQuickUrl;
        }*/
        _onUrlChanged();
    }

/***************************************************************************************/
/* tabs */

    function _createTabs(oUrlData)
    {
        if(!oUrlData)
        {
            return;
        }
        function _makeTabHtml(oTab)
        {
            var jItem = $('<li class="tab-item"></li>');
            var jLink = $('<a href="#' + oTab.id + '"><span></span></a>');

            jLink.find("span").text(_getRcText(oTab, "Menu"));
            jItem.append(jLink);
            _jTabUl.append(jItem);

            if(_isHelpId(oTab.id))
            {
                jLink.on("click", _onHelpClick);
            }
        }

        // remove the old tabs
        _jTabUl.empty();

        if (oUrlData.tabs && oUrlData.tabs.length > 1)
        {
            var aTabs = oUrlData.tabs;
            for (var i=0; i < aTabs.length; i++)
            {
                _makeTabHtml(aTabs[i]);
            }
            $("#layout_center .xb-center-panel").removeClass('no-nav');
            _jTabUl.parent().show();
        }
        else
        {
            _jTabUl.parent().hide();
            $("#layout_center .xb-center-panel").addClass('no-nav');
        }
    }

    function _activeTab(oUrlInfo)
    {
        if (_bUseTab)
        {
            // deActive the old tab
            $(".active", _jTabUl).removeClass("active");

            // active the new tab
            var sMenuId = oUrlInfo.id;
            var jLink = $('a[href="#'+sMenuId+'"]', _jTabUl);
            jLink.parent().addClass("active");
        }

        // load the new page
        _loadModule(oUrlInfo);
        _setWindowTitle ();
    }

function _isHelpId(sMenuId)
{
    return sMenuId.indexOf("_Help") > 0;
}

function _onHelpClick()
{
    var aTemp = this.href.split("#");
    var sMenuId = aTemp[1];
    _showHelp(sMenuId);
    return false;
}

function _showHelp(sMenuId)
{
    var jHelp = $("#help_content");
    var oUrlInfo = _getUrlById(sMenuId);

    sUrl = Frame.Util.getPathUrl(oUrlInfo.url);
    jHelp.load(sUrl, '', function(){jHelp.modal();});

    return false;
}

function _processSpecialUrl(sMenuId)
{
    if(sMenuId.indexOf("debug") == 0)
    {
        if("debug" == sMenuId) sMenuId = "debug.index";
        var sUrl = sMenuId.replace(".", "/") + ".html";
        Utils.Pages.loadModule(sUrl, null, _jActivePage);
        return true;
    }

    if(sMenuId.indexOf("_Help") > 0)
    {
        _showHelp(sMenuId);
        return true;
    }
    
    if (("" == sMenuId ) || ("M_Dashboard"==sMenuId))
    {
    	$("#page_container,#menu_div").addClass("dashboard");
        $("#side_menu ul li").has("a[href=#M_Dashboard]").addClass("active");
    }
    else
    {
    	$("#page_container,#menu_div").removeClass("dashboard");
    }

    return false;
}

/***************************************************************************************/
/* public methods */

    function _init()
    {
        
    }

    function _updatePage(sMenuId)
    {
        var oUrlInfo = _getUrlById(sMenuId);
        if(!oUrlInfo)
        {
            return false;
        }

        // menu-header
        if(oUrlInfo.submenu)
        {
            return true;
        }

        // menu-item
        if(oUrlInfo.tabs)
        {
            oUrlInfo = oUrlInfo.tabs[0];
        }

        _updateModule (oUrlInfo);
        return true;
    }

    function _loadPage(sMenuId)
    {
        if(_processSpecialUrl(sMenuId))
        {
            return true;
        }

        var oUrlInfo = _getUrlById(sMenuId);
        if(!oUrlInfo)
        {
            return false;
        }

        // menu-header
        if(oUrlInfo.submenu)
        {
            return true;
        }

        if (!_bUseTab)
        {
            _activeMenuItems(oUrlInfo);
            _activeTab(oUrlInfo);
            return true;
        }

        // menu-item
        if(oUrlInfo.tabs)
        {
            _activeMenuItems(oUrlInfo);
            _createTabs(oUrlInfo);
            _activeTab(oUrlInfo.tabs[0]);
        }
        else
        {
            // tab-item
            if(_isNewMenuItem(oUrlInfo.id))
            {
                _activeMenuItems(oUrlInfo);
                _createTabs(oUrlInfo.parent || oUrlInfo);
            }
            else if(oUrlInfo.parent)
            {
                _activeMenuItems(oUrlInfo.parent.tabs[0]);
            }

            _activeTab(oUrlInfo);
        }

        _jTabUl.find("li:last").addClass("lastitem");
        $("#global_btns").empty();

        return true;
    }
    
    var g_sCurMenuId = false;
    function parseCurMenuId()
    {
        var sHash  =window.location.hash;
        var sMenuId = sHash.split('?')[0];

        if(sMenuId != "")
        {
            // skip the first char "#"
            sMenuId = sMenuId.substring(1);
        }

        return sMenuId;
    }

    function getCurMenuId()
    {
        if(false === g_sCurMenuId)
        {
            g_sCurMenuId = parseCurMenuId();
        }

        return g_sCurMenuId;
    }

    function isSupport(sMenuId)
    {
        return _aUrlTable[sMenuId] ? true : false;
    }
    function getMenuPath (sMenuId)
	{
		var aPath = [];
		
		// menu is not loaded
		if (!_aUrlTable)
		{
			return "FRAME";
		}
		
		sMenuId = sMenuId || getCurMenuId() || _sDefaultMenuId;
		var oItem = _aUrlTable[sMenuId];
		while (oItem)
		{
			aPath.push(oItem.id);
			
			oItem = oItem.parent;
		}
		aPath.reverse();
		return aPath.join('/');
	}

    function _reFresh()
    {
        _onUrlChanged();
        return;
    }

    function _onUrlChanged()
    {
        var oUrlPara = Utils.Base.parseUrlPara ();
        var sOldMenuId = g_sCurMenuId;
        var sPage = oUrlPara.np;
        g_sCurMenuId = parseCurMenuId();

        if (0 == g_sCurMenuId.indexOf("M_Help."))
        {
            g_sCurMenuId = sOldMenuId;
            return;
        }
        
        Frame.getHelpPanel().close();
        if (sPage)
        {
            $("#page_container,#menu_div").removeClass("dashboard");
            _sCustomUrl = sPage;
        }
               
        _loadPage(g_sCurMenuId);
        _sCustomUrl = false;

        $(window).resize();
    }

/***************************************************************************************/
/* static code */

    Frame.NewMenu = {
        init: _init,
        loadPage: _loadPage,
        getCurMenuId: getCurMenuId,
        isSupport: isSupport,
        getMenuPath: getMenuPath,
        refreshPage: _reFresh
    };

    // Process BACK/FORWORD button on browser, not support IE6/7

    function delayUrlChange(){
        if(null != _TimeDelay){
            clearTimeout(_TimeDelay);
            _TimeDelay = null;
        }
        _TimeDelay=setTimeout(_onUrlChanged , 1000);
    }
      window.onhashchange = delayUrlChange;

    Frame.regNotify("Menu", "language.changed", function()
    {
        if (!_aMenuArray || _aMenuArray.length == 0)
        {
            return;
        }

        initContainer();
    });

    function initContainer()
    {
        Utils.Base.lockScreen();
        Frame.Signal.waitVar (
            function ()
            {
                return $.MyLocale.Lang ? true : false;
            },
            function ()
            {
                _makeMenuMain();
                Utils.Base.unlockScreen();
            }
        );
    }

    ////{{ local start
    function getFirstChild(xmlNode)
    {
        // node.ELEMENT_NODE == node.nodeType
        return xmlNode.firstElementChild || xmlNode.firstChild;
    }

    function getSibling (xmlNode)
    {
        xmlNode = xmlNode.nextSibling;
        while (xmlNode && (xmlNode.nodeType != xmlNode.ELEMENT_NODE))
        {
            xmlNode = xmlNode.nextSibling;
        }
        return xmlNode;
    }

    function parseNode (node)
    {
        var aMenuData = [];
        while (node)
        {
            // {"id":"M_Dashboard","read":"true","write":"false","execute":"true","url":"sysinfo/[lang]/summary.html"}
            var oNode = {
                "id": node.getAttribute("id"),
                "desc": node.getAttribute($.MyLocale.Lang)
            }

            var sAccess = node.getAttribute("access");
            if (sAccess)
            {
                sAccess = "|" + sAccess + "|";
                oNode["read"] = (-1!=sAccess.indexOf("|read|")) ? "true" : "false";
                oNode["write"] = (-1!=sAccess.indexOf("|write|")) ? "true" : "false";
                oNode["execute"] = (-1!=sAccess.indexOf("|execute|")) ? "true" : "false";
            }

            var sUrl = node.getAttribute("url");
            if (sUrl)
            {
                oNode["url"] = sUrl;
            }
            else
            {
                var aSubData = parseNode (getFirstChild(node));
                var sKey = (aSubData[0]["url"]) ? "tabs" : "submenu";
                oNode[sKey] = aSubData;
            }

            node = getSibling (node);

            aMenuData.push (oNode);
        }
        return aMenuData;
    }

    function toMenuJson (aMenuData)
    {
        var aJsonText = [];

        function makeItemJson (oItem, sIndent, sComma)
        {
            var sFormat = '{"id":"%s", "desc":"%s", "url":"%s"}';
            var sText = Utils.Base.sprintf(sFormat, oItem.id, oItem.desc||"", oItem.url);
            aJsonText.push (sIndent + sText + sComma);
        }

        function makeSubMenuJson (aData, sIndent)
        {
            for (var i=0; i<aData.length; i++)
            {
                var sComma = (i==aData.length-1) ? "" : ",";
                var oItem = aData[i];
                if (oItem.url)
                {
                    makeItemJson (oItem, sIndent, sComma);
                }
                else if (oItem.submenu)
                {
                    var sFormat = '{"id":"%s", "desc":"%s", "submenu":[';
                    var sText = Utils.Base.sprintf(sFormat, oItem.id, oItem.desc||"");
                    aJsonText.push (sIndent + sText);
                    makeSubMenuJson (oItem.submenu, "    "+sIndent);
                    aJsonText.push (sIndent + "]}"+sComma);
                }
                else if (oItem.tabs)
                {
                    var sFormat = '{"id":"%s", "desc":"%s", "tabs":[';
                    var sText = Utils.Base.sprintf(sFormat, oItem.id, oItem.desc||"");
                    aJsonText.push (sIndent + sText);
                    makeSubMenuJson (oItem.tabs, "    "+sIndent);
                    aJsonText.push (sIndent + "]}"+sComma);
                }
            }
        }

        aJsonText.push ("[");
        makeSubMenuJson (aMenuData, "");
        aJsonText.push ("]");

        console.info(aJsonText.join('\r\n'));
    }

    function parseXmlMenu (xmlDoc)
    {
        // xmlDoc.firstChild.firstElementChild.nextElementSibling
        var root = getFirstChild (xmlDoc); // menu-root
        var node = getFirstChild (root);
        var aMenuData = parseNode (node);

        // toMenuJson (aMenuData);

        return aMenuData;
    }
    function arrToObj(arry)
    {
        var obj = {};
        for(var i=0;i<arry.length;i++)
        {
            obj[arry[i].id] = arry[i].tabs || arry[i].submenu;
        }

        // checkNode(obj,"M_ApNode");
        //  checkNode(obj,"M_ApGroup");
        return obj;
    }
    function checkAndMakeMenu()
    {
        Frame.Signal.waitVar (
            function ()
            {
                return $.MyLocale.Lang ? true : false;
            },
            function ()
            {
                _aMenuArray = parseXmlMenu (_aMenuArray);
                initContainer();
            });
    }
  /*  alert(_MenuXmlMap.network);
    alert(typeof (modelName));
    alert(_MenuXmlMap.modelName);*/
    /*alert(FrameInfo.Model);
    alert(_MenuXmlMap[FrameInfo.Model][modelName]);*/
    var sMenuUrl = Frame.Util.getPathUrl(_MenuXmlMap[FrameInfo.Model][modelName]);
    $.get(sMenuUrl, null, function(aMenuData)
    {
        _aMenuArray = aMenuData;
        checkAndMakeMenu();
    }, "xml");


   /* if (true === MyConfig.config.local)
    {
        var bUseXml = true;
        if (bUseXml)
        {
            var sMenuUrl = Frame.Util.getPathUrl("../init/xiaobei/system.xml");
            $.get(sMenuUrl, null, function(aMenuData)
            {
                _aMenuArray = aMenuData;
                checkAndMakeMenu();
            }, "xml");
            return;
        }
        else
        {
            var sMenuUrl = Frame.Util.getDynUrl("menu.php");
            $.getJSON(sMenuUrl, function(aMenuData)
            {
                _aMenuArray = aMenuData;
                if ($.MyLocale.Menu)
                {
                    initContainer();
                }
            });
            return;
        }
    }*/

   // var sMenuUrl = Frame.Util.getDynUrl("menu.j");
   /* $.getJSON(sMenuUrl, function(aMenuData)
    {
        _aMenuArray = aMenuData;
        if ($.MyLocale.Menu)
        {
            initContainer();
        }
    });*/
}
/*******************************************************************************
 Copyright (c) 2007, Hangzhou H3C Technologies Co., Ltd. All rights reserved.
--------------------------------------------------------------------------------
@FileName:libs/frame/debugger.js
@ProjectCode: Comware v7
@ModuleName: Frame.Debuger
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: 
    ����ҳ���ĵ�����Ϣ�ӿ�, ��װ���������Ĳ�ͬ. ʹҳ���з����Ĵ�ӡ������Ϣ
@Modification:
*******************************************************************************/

;(function($F)
{


if(!window.console)
{
    var _oConsole = null;
    function _createConsole()
    {
        if(_oConsole) return true;
        
        var sConId = "_frame_console";
        //_oConsole = window.open();        //$("#_console_msg");
        return false;
    }
    window.console = {
        log: function(sMsg)
        {
            if(!_createConsole()) return;

            _oConsole.document.write("<div>"+sMsg+"</div>");
        },
        warn:function(sMsg)
        {
            if(!_createConsole()) return;
            
            _oConsole.document.write("<div style='color:blue'>"+sMsg+"</div>");
        },
        error:function(sMsg)
        {
            if(!_createConsole()) return;
            
            _oConsole.document.write("<div style='color:red'>"+sMsg+"</div>");
        } 
    }
}

function checkLevel(sType)
{
    var level = Debuger.level;
    if("none" == level) return false;

    if("all" == level)
    {
        level = "log|warn|error";
    }
    var aLevel = level.split("|");
    for(var i=0; i<aLevel.length; i++)
    {
        if(sType == aLevel[i])
        {
            return true;
        }
    }

    return false;
}

function _showLog(sType, sMsg)
{
    if(false === checkLevel(sType))
    {
        return false;
    }

    var filter = Debuger.filter;
    if(true === filter) return false;

    if(false === filter)
    {
        window.console[sType](sType + ": " + sMsg);
        return;
    }

    var aFilter = filter.split('|');
    for(var i=0; i<aFilter.length; i++)
    {
        if(sMsg.indexOf(aFilter[i]) != -1)
        {
            window.console[sType](sType + ": " + sMsg);
            break;
        }
    }
}

var Debuger = {
    filter: false,   // false-show all msg; true-show none msg, or a group filter string seperate by "|"
    level: "warn|error",  // "none"-no debug msg; "all"-all the debug msg; or one or more of the "log|warn|error"

/*****************************************************************************
@FuncName: public,Frame.Debuger.info
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ��ʾ������Ϣ
@Usage: Frame.Debuger.info("start make xml string");
@ParaIn: 
    * sMsg - string, ������Ϣ�ַ�����
@Return: ��
@Caution: 
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
	info: function(sMsg)
	{
        _showLog("log", sMsg);
	},

/*****************************************************************************
@FuncName: public,Frame.Debuger.warning
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ��ʾ�澯��Ϣ
@Usage: Frame.Debuger.warning("The flash usage is more then 60%");
@ParaIn: 
    * sMsg - string, ������Ϣ�ַ�����
@Return: ��
@Caution: 
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
	warning: function(sMsg)
	{
        _showLog("warn", sMsg);
	},

/*****************************************************************************
@FuncName: public,Frame.Debuger.error
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ����������Ϣ, �����̽������ش�����֧ʱӦ������һ��������Ϣ
@Usage: Frame.Debuger.error("The flash usage is more then 95%");
@ParaIn: 
    * sMsg - string, ������Ϣ�ַ�����
@Return: ��
@Caution: 
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
	error: function(sMsg)
	{
        _showLog("error", sMsg);
	},

/*****************************************************************************
@FuncName: public,Frame.Debuger.assert
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ������Ϣ����. assert���ܵ��Կ��ص�Ӱ��. ������Ϣ�н�������Ψһ�Եı�ʾ��, ���㶨λ����
@Usage: 
var a = 1;
var b = 2;
var c = a + b;
Frame.Debuger.assert(c!=3, "start make xml string");
@ParaIn: 
    * bExp - boolean, ������Ϣ�����Ŀ���, ������������ʱ����������sMsg��
    * sMsg - string, ������Ϣ�ַ�����
@Return: ��
@Caution: 
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
	assert: function(bExp, sMsg)
	{
		if(bExp){return;}

		if(undefined === sMsg)
		{
			sMsg = "Check your code, please";
		}

		window.console.error("ASSERT: "+sMsg);
	},

    dumpArray: function(aObjArr)
    {
        var jDiv = $("#_dump_obj");
        if (!aObjArr || aObjArr.length == 0)
        {
            jDiv.remove ();
            return ;
        }

        var aTh = [], aHtml=[];
        var obj = aObjArr[0];

        aHtml = ["<table width=100% border=1>"];
        aHtml.push ("<tr>")
        for (var key in obj)
        {
            aTh.push (key);
            aHtml.push ("<th>"+key+"</th>");
        }
        aHtml.push ("</tr>")

        for (var i=0; i<aObjArr.length; i++)
        {
            obj = aObjArr[i];
            aHtml.push ("<tr>")
            for(var k=0; k<aTh.length; k++)
            {
                aHtml.push ("<td>" + obj[aTh[k]] + "</td>");
            }
            aHtml.push ("</tr>")
        }

        aHtml.push ("</table>");

        if (jDiv.length == 0)
        {
            jDiv = $("<div id=_dump_obj style='position:fixed;left:20px;right:20px;top:20px;background-color:#008;z-index:999;'></div>").appendTo("body");
        }
        jDiv.html (aHtml.join(''));
    }
} //// end of Debuger
$F.Debuger = Debuger;


})(Frame);
/*******************************************************************************
 Copyright (c) 2011, Hangzhou H3C Technologies Co., Ltd. All rights reserved.
--------------------------------------------------------------------------------
@FileName:frame.js
@ProjectCode: Comware v7
@ModuleName: Frame.Core
@DateCreated: 2011-08-09
@Author: huangdongxiao 02807
@Description:���ܴ��������塣
@Modification:
*******************************************************************************/

(function($F){

function getRandomStr()
{
    var str = Math.random()+"";
    return str.substring(2);
}
var _rid;

var _jsCache = {
    _list:{},
    get: function(sJsFile)
    {
        var sKey = sJsFile.replace(/\.\.\//g, "");
        return _jsCache._list[sKey];
    },
    add: function(sJsFile, cb)
    {
        var sKey = sJsFile.replace(/\.\.\//g, "");
        var oCache = {
            status: "loading", 
            file: sJsFile,
            cb:[]
        };

        cb && oCache.cb.push(cb);
        _jsCache._list[sKey] = oCache;
        return oCache;
    },
    addCb: function(oCache, cb)
    {
        oCache.cb.push(cb);
    },
    exec: function(oCache)
    {
        var aFunc = oCache.cb;
        oCache.status = "ok";
        oCache.cb = [];
        for(var i=0; i<aFunc.length; i++)
        {
            aFunc[i](oCache.file);
        }

        Frame.Debuger.info("loaded of " + oCache.file);
    },
    remove: function(sJsFile)
    {
        if(_jsCache._list[sJsFile])
        {
            delete _jsCache._list[sJsFile];
        }
    }
};

function _loadScript(sJsFile, cb)
{
    var oJsCache = _jsCache.get(sJsFile);
    if(oJsCache)
    {
        _jsCache.addCb(oJsCache, cb);
        if("ok" == oJsCache.status)
        {
            Frame.OS.thread("_loadScript", function(){_jsCache.exec(oJsCache);});
        }
        // has been loaded
        Frame.Debuger.info("loadjs: cache of " + sJsFile);
        
        return ;
    }

    oJsCache = _jsCache.add(sJsFile, cb);

    var obj = document.body ? document.body : document.getElementsByTagName('head')[0];
    var script = document.createElement('script');
    script.setAttribute('src', sJsFile);
    obj.appendChild(script);

    if(document.all) 
    {
        script.onreadystatechange = function() 
        {
            if(this.readyState == 'complete' || this.readyState == 'loaded') 
            {
                _jsCache.exec(oJsCache);
            }
        };
    }
    else 
    {
        script.onload = function() 
        {
            _jsCache.exec(oJsCache);
        };
    }
}
// $.getScript = _loadScript;
$.loadScript = _loadScript;

/*
key="init", "destroy", ...
_fnList = {
	module1:
	{
		init: [fn1, fn2],
		destroy: [fn1, fn2]
	}
	module2:
	{
		init: [fn1, fn2],
		destroy: [fn1, fn2]
	}
}
*/
var EM = 
{
	_fnList: {},
	reg: function(module, key, fn)
	{
		var oModule = this._fnList[module]||{};
		oModule[key] = oModule[key] || [];
		oModule[key].push(fn);
		
		this._fnList[module] = oModule;
	},

	unreg: function(module, key)
	{
		if(!key)
		{
			delete this._fnList[module];
		}
		else
		{
			delete this._fnList[module][key];
		}
	},
	notify: function(module, key, options)
	{
		var oThis = this;
		if("all" == module)
		{
			$.each(this._fnList, function(m)
			{
				oThis.notify(m,key,options);
			});
			return;
		}
		
		var oModule = this._fnList[module] || {};

		if(!key)
		{
			for(var key in oModule)
			{
				this.notify(module, key, options);
			}
			return;
		}

		var list = oModule[key] || [];
		var fnList = [];
		$.merge(fnList, list);

		$.each(fnList, function(i,fn)
		{
			if(false === fn(options))
			{
				return false;
			}
			return true;
		});
	}
};

var Cookie = 
{
    get: function (sName)
    {
        // cookies are separated by semicolons
        var aCookie = document.cookie.split("; ");
        for (var i=0; i < aCookie.length; i++)
        {
            // a name/value pair (a crumb) is separated by an equal sign
            var aCrumb = aCookie[i].split("=");
            if (sName == aCrumb[0]) 
              return unescape(aCrumb[1]||"");
        }
        
        // a cookie with the requested name does not exist
        return null;
    },
    set: function (oPara, retentionDuration)
    {
        var sExpres = "";
        var n = parseInt(retentionDuration);
        if(-1 == n)
        {
            // ���ϻ�
            var date = new Date(2099,12,31);
            sExpres = "expires=" + date.toGMTString();
        }
        else if(n>0)
        {
            var date = new Date();
            date.setTime(date.getTime() + n*60000);
            sExpres = "expires=" + date.toGMTString();
        }

        for (var sName in oPara)
        {
            var sCookie = sName+"="+escape(oPara[sName])+"; path=/;" + sExpres;
            document.cookie = sCookie;
        }
    },
    del: function(sName)
    {
        var date = new Date();
        date.setTime(date.getTime() - 10000);

        var aTemp = sName.split(",");
        for(var i=0; i<aTemp.length; i++)
        {
            var sCookie = aTemp[i] + "=d; path=/; expires=" + date.toGMTString();
            document.cookie = sCookie;
        }
    },
    clear: function()
    {
        var date = new Date();
        date.setTime(date.getTime() - 10000);

        // cookies are separated by semicolons
        var aCookie = document.cookie.split("; ");
        for (var i=0; i < aCookie.length; i++)
        {
            // a name/value pair (a crumb) is separated by an equal sign
            var aCrumb = aCookie[i].split("=");
            var sCookie = aCrumb[0] + "=d; path=/; expires=" + date.toGMTString();
            document.cookie = sCookie;
        }
    }
}
Frame.Cookie = Cookie;



$.extend(Frame,
{
	ver: "7.0.0",
	name: "Frame",


/*****************************************************************************
@FuncName: public, Frame.include
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: �����ṩ�İ���JS�Ľӿڣ�����HTML�е�script��ǩ��
    �ýӿ�ʹ�ñ��Σ���һ������Ϊģ������������JS LIB���ƣ���JS�ļ����ڵ�Ŀ¼�ĵ��ֱ�ʾ������
    ����������JS�ļ�ʱ���������е�JS�ļ������ڵڶ���������ʹ�÷ֺŷֿ���Ҳ����ʹ�ö���������
    ÿ������Ϊһ��JS�ļ���������ͬһ�����ļ�����һ�������У�����ά����
    <P>�ýӿڻ���������������ָ����JS�ļ��������е�JS�ļ��������ɹ��󣬻���������ģ�鷢��init�¼�֪ͨ��
    ��ҳ������ע���Լ���init�¼���������ʼ���Լ���ҳ�档
@Usage: 
    ��ֻ��һ��JS�ļ�ʱ��ʹ���ļ�����Ϊģ����,��ʱֻ��һ���������ɣ�
    Frame.include("Pages.Systime.Summary")
    ��ʱģ����ΪPages.Systime.Summary��������JSΪPages/Systime/Summary.js
    
    ģ�������ļ�����ͬ��������
    Frame.include("Systime.Summary", "Pages.Systime.Summary");
    ��ʱģ����ΪSystime.Summary��������JSΪPages/Systime/Summary.js
    
    ��������JS�ļ���������
    Frame.include("Systime.Summary", "Pages.Systime.Summary;Pages.Systime.Create;Libs.Frame.Dialog");
    ��ʱģ����ΪSystime.Summary������������JS�ļ����ֱ�Ϊ
    pages/systime/summary.js
    pages/systime/creaet.js
    libs/frame/dialog.js
    
    ���������ļ�Ҳ����ʹ�ö��������ķ���, �ӵڶ���������ʼ, ÿһ����������һ��������JS:
    Frame.include("Frame.Menu",
        "Libs.Plugin.Layout",
        "Libs.Plugin.Validate",
        "Libs.Plugin.SpinBtn",
        "Libs.Plugin.Tooltip",
        "Libs.Plugin.Flot.Flot;Libs.Plugin.Flot.Pie",
        "Libs.Plugin.JqGrid",
        "Libs.Frame.Menu;Libs.Frame.Effect;Libs.Frame.Dialog",
        "Libs.Frame.Debuger",
        "Oem.Default.Config");
@ParaIn: 
    * sModuleName - string, ģ�����������Լ����壬 �����ܺ������˵��ظ�������ʹ��·������Ϊģ������
    ���Ա�֤�϶��������������ظ���
    * libs - string, LIB·��, ��JS�ļ���·����������libsĿ¼�µģ� Ҳ�������Լ�Ŀ¼�µ��ļ���
    ��Libs.Frame.Dialog��Pages.Vlan.Summary������������JS�ļ�ʱ��ʹ�÷ֺŸ���
@Return: void.
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    include: function(opt, libs)
    {
        var aLibs = [];
        var iIndex = 0;

        // ���������˱�̬�ļ�������ʱ��Ҫ��URL������һ��������
        var sCachPara = (true===MyConfig.config.cachePage) ? "" : "?u="+Frame.get("rid");

        if(typeof(opt)=="string")
        {
            opt = {module: opt, para:{}};
        }

        var sModuleName = opt.module;
        var oPara = opt.para;

        function end()
        {
            EM.notify(sModuleName, "loaded", oPara);
            opt.cb && opt.cb();
        }

        // get JS files;
        function loadOneJs()
        {
            if(aJsFiles.length == iIndex)
            {
                end();
                return;
            }

            var sJsFile = aJsFiles[iIndex];
            Frame.Debuger.info("loadjs - "+sJsFile);
            $.loadScript(sJsFile, loadOneJs);
            
            // for next JS file
            iIndex ++;
        }
        
        function _loadJs(aJsFiles)
        {
            var nCount = aJsFiles.length;
            function loadEnd()
            {
                nCount --;
                if(nCount==0)
                {
                    end();
                }
            }
            
            for(var i=0; i<aJsFiles.length; i++)
            {
                var sJsFile = aJsFiles[iIndex];
                Frame.Debuger.info("loadjs - "+sJsFile);
                $.loadScript(sJsFile, loadEnd);
            }
        }

        // ׼��JS�ļ��б�
        if(!libs)
        {
            libs = sModuleName;
            aLibs = libs.split(";");
        }
        else for(var i=1; i< arguments.length; i++)
        {
            $.merge(aLibs, arguments[i].split(";"));
        };

        var aJsFiles = [];
        for(var i=0; i<aLibs.length; i++)
        {
            var sLib = aLibs[i];
            var sRoot = MyConfig.root||"/"; // ���������Ǻ��Ĵ���, ����ʹ��Frame.Util.getUrlPath��װȫ·��
            var sPath = sLib.replace(/^Libs\./,"frame/libs/").replace(/\./g, "/")+".js"+sCachPara;
            var sJsFile = sRoot + sPath;
            aJsFiles.push(sJsFile.toLowerCase());
        }

         loadOneJs(); // ͬ��load
        // _loadJs(aJsFiles); // �첽load
    },

/*****************************************************************************
@FuncName: public, Frame.regNotify
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: �¼�֪ͨע���ӿڡ�V7������ʹ���¼����ƴ���ϵͳ�е��첽������
	��ҳ������ע���Լ����ĵ��¼����д������õ��¼�����ҳ���ĳ�ʼ��init��
	ҳ������destroy��ҳ��������JS�ļ���ע���������¼���
@Usage: 
	���ο� Frame.notify
@ParaIn: 
	* sModule - string, ģ�����������Լ����壬 �����ܺ������˵��ظ�������ʹ��·������Ϊģ������
	���Ա�֤�϶��������������ظ���
	* sEvent, string, �¼�����
	* fn, Function, �¼�������
@Return: boolean, �ɹ�ʱ����true�����򷵻�false
@Caution: 
@Modification:
	* yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
	regNotify: function(sModule, sEvent, fn)
	{
		return EM.reg(sModule, sEvent, fn);
	},

/*****************************************************************************
@FuncName: public, Frame.unregNotify
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ȡ���¼�ע�ᣬ ��Frame.regNotify�෵��
@Usage: ȡ����ģ�������е�ע�᣺
	var MODULE_NAME = "Pages.Systime.Summary";
	Frame.unregNotify(MODULE_NAME);
	
	ȡ����ʼ����ע�᣺
	Frame.unregNotify(MODULE_NAME, "init");
@ParaIn: 
	* sModule - string, ģ������
	* sEvent - string, �¼����ơ�
	* fn - Function, �¼��Ĵ�������������ָ������ע�����¼�������ע���Ĵ�������
		�ݲ�֧�ָò���
@Return: boolean, �ɹ�ʱ����true�����򷵻�false
@Caution: 
@Modification:
	* yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
	unregNotify: function(sModule, sEvent, fn)
	{
		return EM.unreg(sModule, sEvent, fn);
	},

/*****************************************************************************
@FuncName: public, Frame.notify
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: �¼��첽֪ͨ�ӿڡ�����֪ͨ���������ء�һ���ɿ��ܻ��ؼ����ã���ģ��ע����Ӧ����
@Usage: �ڿؼ��е��ã�
	var oPara = {para1:true,para2:"abc"};
	Frame.notify("Libs.Frame.Dialog", "close", oPara);
	
	����ҳ����Ҫ��֪�Ի����رգ��Ϳ�����ע���Ի�����close�¼���
	Frame.regNotify("Libs.Frame.Dialog", "close", function(oPara)
	{
		var p1 = oPara.para1;   // true
		var p2 = oPara.para2;   // "abc";
	});

	�ڲ�ʹ�õ�ʱ��ע��ȡ����
	Frame.unregNotify("Libs.Frame.Dialog", "close", function(){});
@ParaIn: 
	* sModule - string, ģ������
	* sEvent - string, �¼����ơ�
	* opt - JSON, ֪ͨ������
@Return: ��
@Caution: 
@Modification:
	* yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
	notify: function(sModule, sEvent, opt)
	{
		EM.notify(sModule, sEvent, opt);
		return true;
	},
	
/*****************************************************************************
@FuncName: public, Frame.notifyAndWait
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: �¼�ͬ��֪ͨ�ӿڡ�����֪ͨ���ȴ����д����ߴ������ɺ��ٷ��ء�һ���ɿ��ܻ��ؼ����ã���ģ��ע����Ӧ����
@Usage: �ڿؼ��е��ã�
	var oPara = {para1:true,para2:"abc"};
	Frame.notify("Libs.Frame.Dialog", "close", oPara);
	
	����ҳ����Ҫ��֪�Ի����رգ��Ϳ�����ע���Ի�����close�¼���
	Frame.regNotify("Libs.Frame.Dialog", "close", function(oPara)
	{
		var p1 = oPara.para1;   // true
		var p2 = oPara.para2;   // "abc";
	});

	�ڲ�ʹ�õ�ʱ��ע��ȡ����
	Frame.unregNotify("Libs.Frame.Dialog", "close", function(){});
@ParaIn: 
	* sModule - string, ģ������
	* sEvent - string, �¼����ơ�
	* opt - JSON, ֪ͨ������
@Return: ��
@Caution: 
@Modification:
	* yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
	notifyAndWait: function(sModule, sEvent, opt)
	{
		return EM.notify(sModule, sEvent, opt);
	},

/*****************************************************************************
@FuncName: public, Frame.init
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: Called by frame
@Usage: 
@ParaIn: 
@Return: ��
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    init: function()
    {
        // �ж��Ƿ��ǺϷ���¼������
       /* if(!FrameInfo || ("true" != Cookie.get(FrameInfo.sessionid)))
        {
            //alert(FrameInfo.sessionid);
            window.location = MyConfig.root;
            return false;
        }*/
        this.loadTheme();
        //w11273
        //Frame.Custom.onLanguageChanged(Cookie.get("lang")||"en");
        Frame.Custom.onLanguageChanged("cn");
    },
    loadTheme:function()
    {
        var sCss = Frame.Util.getPathUrl("frame/css/index.css");
        $("#mytheme").attr("href", sCss);
        var sConfig = Frame.Util.getPathUrl("frame/css/config.js");
        $.getScript(sConfig, function(){ThemeConfig.init()});
    },
    logout: function()
    {
        Frame.Ajax.disable();
        $.ajax({
            cache: false,
            dataType: "json",
            type: "POST",
            url: Frame.Util.getDynUrl("logout.j"),
            success: function(oJson, sCode)
            {
				var sUrl = ("true" === oJson.autoLogin) ? "../" : "../../../";
				window.location = Frame.Util.getPathUrl(sUrl);
            },
            error: function(oHttp, sDesc, oExcept)
            {
				var sUrl = "../../../";
				window.location = Frame.Util.getPathUrl(sUrl);
            },
            complete: function()
            {
				Cookie.del(Frame.get("sessionid"));
			}
        });
    },

    getHelpPanel: function(para)
    {
        NewPage.init(para);
        return NewPage;
    },

    resize: function()
    {
        Frame.notify("all", "resize");
    },

/*****************************************************************************
@FuncName: public, Frame.get
@DateCreated: 2011-07-26
@Author: huangdongxiao 02807
@Description: ��ȡȫ����Ϣ
@Usage:
    Frame.get("sessionid");
    Frame.get("lang", "en");
    Frame.get("username");
    Frame.get("password");
@ParaIn:
    * sKey - string, �����֣�֧�����¼���
        <li>sessionid����ȡ�û�ID�ַ���
        <li>rid����ȡ��������ÿ�ε�¼�󶼻���������һ���ַ������ô��ڱ��ε�¼�ڼ䲻�䡣
            ��Ҫ����׷�ӵ���̬URL���棬��ֹ�����󻺴档��ҳ��һ�㲻��Ҫ�õ�
        <li>lang����ȡ��ǰ�����ַ���
        <li>username����ȡ��ǰ��¼�û����û���
        <li>product����ȡ��ǰ��Ʒ����
        <li>sysoid����ȡ��ǰ��ƷOID
        <li>theme����ȡ��ǰ��Ƥ������
        <li>idletime����ȡ��ǰ��web��ʱʱ��
    * default - void, ȱʡ����ֵ, ����ȡ�Ĳ���������ʱ���ظ�ֵ�����Բ�ָ����
@Return: void, ��ȡ����ֵ�����ص����͸��������ֵĲ�ͬ����ͬ.
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    get: function(sKey, defvalue)
    {
        switch(sKey)
        {
        case "sessionid":
            return FrameInfo.sessionid;
        case "mdcid":
            return FrameInfo.vid || defvalue;
        case "rid":
            return _rid||(_rid=getRandomStr());
        case "lang":
            return $.MyLocale.Lang;
        case "username":
            return FrameInfo.uname;
        case "theme":
            return ThemeConfig.name;
        case "SkinPath":
            return Frame.Util.getPathUrl("frame/libs/css/");
        case "mainheight":
            return $("#maincontent").height();
        case "devname":
            return FrameInfo.devname;
        case "sysoid":
            return Server._cach["entity"]["VendorType"] || defvalue;
        case "SerialNumber":
            return Server._cach["entity"][sKey] || defvalue;
        case "DeviceType":
            return Server._cach["entity"]["Model"] || Server._cach["entity"]["Name"] || defvalue;
        case "sysname":
        case "idletime":
            return Server._cach[sKey] || defvalue;
        case "oem":
            return FrameInfo.oem;
        /*case "isRunningCfg":
            return FrameInfo.isRunningCfg;*/
       /* case "WorkMode":
            return FrameInfo.WorkMode;*/
        default:
            return (defvalue===undefined) ? "not-support" : defvalue ;
        }
    },
    set: function (sKey, val)
    {
        var bRet = false;
        switch(sKey)
        {
        case "sysname":
            $("#sysname").html(val).attr("title", val);
            Server._cach[sKey] = val;
            break;
        case "idletime":
            Server._cach[sKey] = val;
            break;
        /*case "WorkMode":
            FrameInfo.WorkMode = val;
            break;*/
       /* case "isRunningCfg":
            FrameInfo.isRunningCfg = val;
            break;*/
        default:
            bRet = false;
            break;
        }
        return bRet;
    }
});

/*****************************************************************************
@typedef: ListString
@DateCreated: 2012-05-09
@Author: huangdongxiao 02807
@Description: �б��ַ������Զ��ŷָ���ö���ַ���������һ�����顣�����б���ö��ֵ������0��ʼ��������
    ������ʹ�����������壬��������ʽΪ[{value:value1, text: text1},{}]������{value1:text1,value2:text2}��
    Ҳ������һ��js��������ʱ��Ҫ���ط�������������ö���ַ����������顣
    <p>�б��ַ������ڶ����б���ö���е����򣬿������б༭���߸߼���ѯʱ������������ʽ��ʾ�����������û�ѡ����
    <h3>�����б�</h3>
    <li><a href="#Frame.ListString.format">format</a>
    <li><a href="#Frame.ListString.getTextByValue">getTextByValue</a>
@Usage:
//�ַ�����ʽ
var sList = "Up,Down";

//����������ʽ
var aList = ["emergencies","alerts","critical","errors","warnings","notifications","informational","debugging"];

//�Զ���������ʽ��ע��isDefault����Ĭ����false��һ��������ֻ����һ����true
var aList = [{value:4, text:"Down", isDefault:true}, {value:2, text:"Up"}];
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*******************************************************************************/
var ListString =
{

/*****************************************************************************
@FuncName, public, Frame.ListString.format
@DateCreated: 2013-06-08
@Author: huangdongxiao 02807
@Description: �����б����б༭������
@Usage:
//�ַ�����ʽ���м��Զ��ŷָ��������ڴ�0��ʼ��ö��ֵ
var sList = "emergencies,alerts,critical,errors,warnings,notifications,informational,debugging";
Frame.ListString.format(sList);

//����������ʽ��ʵ��ֵ��1��ʼ��ö��ֵ
var aList = ["emergencies","alerts","critical","errors","warnings","notifications","informational","debugging"];
Frame.ListString.format(aList, {start:1});

//�Զ���������ʽ���������������е�ö��ֵ
var aList = {"0":"emergencies", "1":"alerts", "2":"critical", "3":"errors", "4":"warnings",
             "5":"notifications", "6":"informational", "7":"debugging"};
Frame.ListString.format(aList);

//��׼��ʽ��
var aList = [
    {value:0, text:"emergencies"},
    {value:1, text:"alerts"},
    {value:2, text:"critical"},
    {value:3, text:"errors"},
    {value:4, text:"warnings"},
    {value:5, text:"notifications"},
    {value:6, text:"informational"},
    {value:7, text:"debugging"}
];
Frame.ListString.format(aList);
@ParaIn:
    * listStr, String, ��Ҫ��ʽ�����ַ���
@Return: Array, ����һ����׼��ʽ������
@Caution:
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
    format: function(listStr, opt)
    {
        var listData = listStr;

        opt = $.extend({}, {displayField: "text", valueField: "value"}, opt);

        if($.isFunction(listStr))
        {
            listData = listStr();
        }

        var nStart=0, listItems=listData;
        var sValKey = opt.valueField;
        var sDispKey = opt.displayField;

        if ( $.isPlainObject(listData) && (listData.items))
        {
            nStart = listData.start || nStart;
            listItems = listData.items;
        }

        if("string"==typeof(listItems))
        {
            listItems = listItems.split(",");  //.split(/[,;]/);
        }

        // �ַ����±���ʽת��Ϊ�����±��ĸ�ʽ
        // {value1: text1, value2:text2} -> [{value:value1,text:text1},{value:value2, text:text2}].
        if($.isPlainObject(listItems))
        {
            var aList = [];
            for(var k in listItems)
            {
                var oData = {}
                oData[sValKey] = k;
                oData[sDispKey] = listItems[k];
                aList.push(oData);
            }
            return aList;
        }

        // listStr�϶�������
        var nLen = listItems.length;

        // û������, ֱ�ӷ���
        if(0 == nLen)
        {
            return listItems;
        }

        // �Ѿ�����ȷ�ĸ�ʽ, ֱ�ӷ���
        if($.isPlainObject(listItems[0]))
        {
            return listItems;
        }

        // �������ַ�������, ��Ҫת��Ϊ {value: xx, text: xxx}
        // �����豸�Ϸ��ص����ݶ����ַ������ͣ�����valueҲ��Ҫ���ַ������͡�
        var aList = [];
        for(var i=0; i<listItems.length; i++)
        {
            var oData = {}
            oData[sValKey] = i+nStart+"";
            oData[sDispKey] = listItems[i];
            aList[i] = oData;
        }
        return aList;
    }

/*****************************************************************************
@FuncName, public, Frame.ListString.getTextByValue
@DateCreated: 2013-06-08
@Author: huangdongxiao 02807
@Description: �����б����б༭������
@Usage:
//�Զ���������ʽ���������������е�ö��ֵ
var aList = {"0":"emergencies", "1":"alerts", "2":"critical", "3":"errors"};
var aData = Frame.ListString.format(aList);
Frame.ListString.getTextByValue(aData, "2"); // return "critical"
@ParaIn:
    * listStr, String, ��Ҫ��ʽ�����ַ���
@Return: Array, ����һ����׼��ʽ������
@Caution:
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
    ,getTextByValue: function (aData, value)
    {
        for(var i=0; i<aData.length; i++)
        {
            if(aData[i].value == value)
            {
                return aData[i].text;
            }
        }

        return "";
    }

/*****************************************************************************
@FuncName, public, Frame.ListString.each
@DateCreated: 2013-06-08
@Author: huangdongxiao 02807
@Description: �����б����б༭������
@Usage:
var sList = "emergencies,alerts,critical,errors,warnings,notifications,informational,debugging";
Frame.ListString.each(sList, function(val, text)
{
    aHtml.push(Frame.Util.sprintf("<option value='%d'>%s</option>", val, text));
});
@ParaIn:
    * listStr, String, ��Ҫ��ʽ�����ַ���
    * para1, Function/Object, ����ֻ���������������ò���Ϊ�ص��������������������������ò���Ϊ����ѡ��
    * para2, �ص�����
@Return: Array, ����һ����׼��ʽ������
@Caution:
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
    ,each: function (aData, para1/*optional*/, para2)
    {
        var opt={displayField: "text", valueField: "value"}, cb=para1;

        if(para2)
        {
            $.extend(opt, para1);
            cb = para2;
        }

        var aList = this.format(aData, opt);
        for(var i=0; i<aList.length; i++)
        {
            cb(aList[i][opt.valueField], aList[i][opt.displayField]);
        }

        return i;
    }
}
Frame.ListString = ListString;

/*****************************************************************************
@FuncName: class, Frame.Server
@DateCreated: 2012-02-09
@Author: huangdongxiao 02807
@Description:  ��������(�豸)����������. ���ڴӷ������ϻ�ȡʱ��Ҫ�첽����, ���Ը�class�µ����нӿڶ���Ҫһ���ص�����
@Usage:
*****************************************************************************/
var Server = 
{
    // ������Ϣ
    _cach: {},

/*****************************************************************************
@FuncName: public, Frame.Server.get
@DateCreated: 2012-02-09
@Author: huangdongxiao 02807
@Description: ��ȡȫ����Ϣ
@Usage:
    function setIdleTime(nIdleTime)
    {
        nIdleTime = parseInt(nIdleTime);
        // ...
    }
    Frame.Server.get("idletime", setIdleTime, 10);
@ParaIn:
    * sKey - String, �����֣�֧�����¼���
        <li>idletime���ӷ������ϻ�ȡ��ǰ��web��ʱʱ��
    * cb - Function, ��ȡ�����ݺ���֪ͨ����. 
    * default - void, ȱʡ����ֵ, ����ȡ�Ĳ���������ʱ���ظ�ֵ�����Բ�ָ����
@Return: void, ��ȡ����ֵ�����ص����͸��������ֵĲ�ͬ����ͬ.
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    get: function(sKey, cb, defvalue)
    {
        $.ajax({
            url: "../../wnm/frameWebUI.json",
            type: "GET",
            dataType: "json",
            success: function(data){
                var aBase = data.WebUI;
                if(aBase.length == 0)return ;
                var val = aBase[0].SessionAgingTime;

                oServer._cach[sKey] = val;
                cb && cb (val);
            },
            error:function(err,status){
                alert(err);
            }
        });
       /* var NC = Utils.Pages["Frame.NC"].NC_Frame;
        var oServer = this;
        var sPath;
        var oBase = Utils.Request.getTableInstance(NC.WebUI,{count:1});
        Utils.Request.getAll([oBase], {onSuccess: myCallback, menu:"FRAME"});

        function myCallback(oInfos)
        {
            var aBase = Utils.Request.getTableRows(NC.WebUI, oInfos);
            if(aBase.length == 0)return ;
            var val = aBase[0].SessionAgingTime;
            
            oServer._cach[sKey] = val;
            cb && cb (val);
        } */
        
        /*        
        switch(sKey)
        {
        case "sysname":
            oRequest.appendNode("Device").appendNode("Base").appendColumn("HostName");
            sPath = "Device.Base[0].HostName";
            break;
        case "entity":  // ȡ��һ�򲻿յ�sysoid
            oRequest.appendNode("Device").appendNode("PhysicalEntities").appendNode("Entity")
                .appendColumn("Model,VendorType,SerialNumber,Model,Name").appendColumn("Class", "3");
            sPath = "Device.PhysicalEntities[0]";
            MyConfig.config.local && (sPath = "Device.PhysicalEntities[1]");
            break;
        
        case "idletime":
            oRequest.appendNode("Fundamentals").appendNode("WebUI").appendColumn("SessionAgingTime");
            sPath = "Fundamentals.WebUI[0].SessionAgingTime";
            break;
        default:
            return false;
        }
        */
        return true;
    }
} //// end of ToopTip
Frame.Server = Server;


/*
��ʱ�����ڲ����ݽṹ��
{
    name: String; ��ʱ�����ƣ�Ϊ���Զ�������Դ�������Ʋ����ظ������������ظ�ʱ����Ϊ��reset���󣬻��������ϴεĶ�ʱ������
    create_times: int; �����Ĵ��������ڵ���
    time_out: int; ��ʱʱ��
    wait_time: int; �ѵȴ���ʱ�䣬������ʱ�䳬��time_outʱ�����ص���������
    loop: Boolean; �Ƿ���ѭ����ʱ��
    used: Boolean; �Ƿ����õı��ǡ�
    callback: Function; ��ʱ���Ļص�������������ѭ����ʱ�������ú�������falseʱ��ʱ������ֹ��һ�ζ�ʱ��ʱ����ֵ������
    paras: void; ���ݸ��ص������Ĳ������������������ͣ����ܲ���ʶ���ò���������
}
*/
var Timer = 
{
    _FREQUENCY: 10,
    _hTimer: false,
    _modules:{},
    _do: function()
    {
        for(var sName in Timer._modules)
        {
            var oTimer = Timer._modules[sName];
            if(!oTimer || !oTimer.used) continue;

            oTimer.wait_time += Timer._FREQUENCY;
            if(oTimer.wait_time < oTimer.time_out)
            {
                // ��û�е���ʱʱ��
                continue;
            }

            var ret = oTimer.callback(oTimer.paras);
            if(!oTimer.loop || (false === ret))
            {
                // һ���Զ�ʱ������ѭ����ʱ�󷵻���falseʱ����ֹ��ʱ��
                Timer.destroy(oTimer);
            }
        }
    },
    init: function()
    {
        if(this._hTimer)
        {
            clearInterval(this._hTimer);
        }

        // ��ʱ����
        //this._hTimer = setInterval(Timer._do, Timer._FREQUENCY);
    },

/*****************************************************************************
@FuncName: public, Frame.Timer.create
@DateCreated: 2011-11-01
@Author: huangdongxiao 02807
@Description: ������ʱ�󡣸�ҳ����ʹ�ö�ʱ��ʱ��ֹʹ��setTimeout, setInterval������ʹ�ñ�����������
@Usage: 
    var oTimer = false;

    // ����һ��1���ӵ�һ���Զ�ʱ��
    oTimer = Frame.Timer.create("sysinfo_cpu", function(){}, 1000);
    
    // ����һ��1���ӵ�ѭ����ʱ�����һص������д��в���
    oTimer = Frame.Timer.create("sysinfo_cpu", function(mypara)
    {
        if(1==mypara.id)
        {
        }
    }, 1000, true, {id:1});

    // ��ҳ���˳�ʱ��Ҫ��������
    if(oTimer)
    {
        Frame.Timer.destroy(oTimer);
    }
@ParaIn: 
    * sModule, string, ģ���������ڱ�ʾ���ĸ�ģ������ҳ�����õģ����㶨λ���⡣
    * pfAction, Function, ��ʱ����ʱ����ִ�к���������true or false��
        ������ѭ����ʱ�����򵱺������صĲ���trueʱ����ֹ��ʱ����
    * nTime, Integer, ��ʱ��ʱ�䣬����
    * bLoop, Boolean, true-ѭ����ʱ����false-��ѭ����ʱ��
    * para, void, ����pfAction�Ĳ���������ʹ��object���ʹ��ݶ������ݡ�
@Return: �����Ķ�ʱ������������ʱҪ�á���ʱ��������һ���ṹ��������ҳ�����޸����е�����
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    _create: function(sModule, pfAction, nTime, bLoop, para)
    {
        var oTimer = this._modules[sModule];
        if(!oTimer)
        {
            oTimer = 
            {
                type: "Frame.Timer",
                name: sModule, //String; ��ʱ������
                pageid: "",     //String; ��ʱ��������ҳ����ID�󶨣��󶨺���ҳ�����ߺ��ͻ��Զ�����
                create_times: 0, //int; �����Ĵ��������ڵ���
                time_out: parseInt(nTime), //int; ��ʱʱ��
                wait_time: 0,   //int; �ѵȴ���ʱ�䣬������ʱ�䳬��time_outʱ�����ص���������
                loop: (true===bLoop),    //Boolean; �Ƿ���ѭ����ʱ��
                used: true,     //Boolean; �Ƿ����õı��ǡ�
                callback: pfAction, //Function; ��ʱ���Ļص�������
                paras: para     //void; ���ݸ��ص������Ĳ������������������ͣ����ܲ���ʶ���ò���������
            };
            this._modules[sModule] = oTimer;
        }

        oTimer.create_times ++;
        this.reset(oTimer);
        return sModule;
    },
    create: function(sModule, pfAction, nTime, bLoop, para)
    {
        function _do()
        {
            oTimer.timer = false;
            
            var bContinue = pfAction(para);
            if ((true === bContinue) && (true === bLoop) )
            {
                oTimer.timer = setTimeout(_do, nTime);
            }
        }

        var oTimer = 
        {
            name: sModule,
            action: _do,
            time: nTime,
            loop: bLoop,
            timer: setTimeout(_do, nTime)
        };

        // ҳ���еĶ�ʱ����Ҫ�ȱ��浽DBM�У��ظ�����ʱ����ɾ����һ�ε�ʵ��
        if ( (0 == sModule.indexOf("Pages.")) && Frame.DBM)
        {
            var db = Frame.DBM.open("Frame.Timer", {openFlag:"read|write|create"});
            var oOldTimer = Frame.DBM.get(db, sModule, false);
            Timer.destroy(oOldTimer);           // ɾ���ɵĶ�ʱ��
            Frame.DBM.set(db, sModule, oTimer); // ��¼�µĶ�ʱ��
            Frame.DBM.close(db);
        }
        
        return oTimer;
    },

/*****************************************************************************
@FuncName: public, Frame.Timer.reset
@DateCreated: 2011-11-01
@Author: huangdongxiao 02807
@Description: ���ö�ʱ����ʹ�ö�ʱ�����¿�ʼ����ʱ�䡣
@Usage: 
@ParaIn: 
    * oTimer, Object, �����Ķ�ʱ������
@Return: ��
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    reset: function(oTimer)
    {
        if(!oTimer) return;

        if("Frame.Timer.2"==oTimer.type)
        {
            $.extend(oTimer, {
                wait_time: 0,   //int; �ѵȴ���ʱ�䣬������ʱ�䳬��time_outʱ�����ص���������
                used: false     //Boolean; �Ƿ����õı��ǡ�
            });
            return;
        }

        if(oTimer.timer)
        {
            clearTimeout(oTimer.timer);
        }
        
        oTimer.timer = setTimeout(oTimer.action, oTimer.time);
    },
    
/*****************************************************************************
@FuncName: public, Frame.Timer.destroy
@DateCreated: 2011-11-01
@Author: huangdongxiao 02807
@Description: ���ٶ�ʱ����
@Usage: 
@ParaIn: 
    * oTimer, Object, �����Ķ�ʱ������
@Return: ��
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    destroy: function(oTimer)
    {
        if(!oTimer) return;

        if("Frame.Timer.2"==oTimer.type)
        {
            oTimer.used = false;
            return;
        }

        if(oTimer.timer)
        {
            clearTimeout(oTimer.timer);
            oTimer.timer = false;
        }
    }
} ////{{ end of Timer }}
Frame.DBM && Frame.regNotify("Frame.Pages", "destroy", function(opt)
{
    var sModule = opt.name;
    var db = Frame.DBM.open("Frame.Timer", {openFlag:"read|write"});
    if(!db) return;
    
    var oTimer = Frame.DBM.get(db, sModule, false);
    Frame.DBM.close(db);
    
    Timer.destroy(oTimer);

    Frame.DBM.del("Frame.Timer", sModule);
});
Frame.Timer = Timer;

var OS = 
{
    NAME: "OS",

/*****************************************************************************
@FuncName: public, Frame.OS.delay
@DateCreated: 2011-10-13
@Author: huangdongxiao 02807
@Description: ��ʱִ��һ��������
@Usage: 
    // ���崦����
    function doMyAction(oPara)
    {
        alert(oPara);
    }
    
    // ��ʹ�ò���
    var hDelay = Frame.OS.delay("mydelay", 1000, doMyAction);
    
    // ʹ�ü򵥲���
    var hDelay = Frame.OS.delay("mydelay", 1000, doMyAction, 1);

    // ʹ�ø��Ӳ���
    var hDelay = Frame.OS.delay("mydelay", 1000, doMyAction, {name:"hdx",flag:"test", id=3});
    
@ParaIn: 
    * sModule, String, ģ���������ڶ�λ����
    * nTime, Interger, ��ʱ��ʱ�䣬����
    * pfAction, Function, ִ�к���ָ��
    * para, any, �û���������͸����ִ�к�����
@Return: �����Ѿ�������,�������̷���false,���򷵻�true
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    delay: function(sModule, nTime, pfAction, oPara)
    {
        return Timer.create(sModule+".Delay", pfAction, nTime, false, oPara);
    },
    
/*****************************************************************************
@FuncName: public, Frame.OS.cancelDelay
@DateCreated: 2011-10-13
@Author: huangdongxiao 02807
@Description: ȡ����ʱִ�У�delay�ķ�������������ĳһ��ʱ������δ����ʱ���Ե��øýӿ�ȡ����ִ�С�
@Usage: 
    // ���崦����
    function doMyAction(oPara)
    {
        alert(oPara);
    }
    
    // ��ʹ�ò���
    var hDelay = Frame.OS.delay("mydelay", 1000, doMyAction);
    
    function onCancelAction()
    {
        if(hDelay)
        {
            Frame.OS.cancelDelay(hDelay);
            hDelay = false;
        }
    }
@ParaIn: 
    * hDelay, Handle, ������ʱ����ʱ���صľ���
@Return: none
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    cancelDelay: function(hDelay)
    {
        if(false !== hDelay)
        {
            Timer.destroy(hDelay);
            hDelay = false;
        }
        return hDelay;
    },
    
/*****************************************************************************
@FuncName: public, Frame.OS.thread
@DateCreated: 2011-10-13
@Author: huangdongxiao 02807
@Description: ����һ���߳�
@Usage: 
    // ���崦����
    function doMyAction(oPara)
    {
        alert(oPara); // 1
    }
    
    // ��ʹ�ò���
    var hDelay = Frame.OS.thread("mymodule", doMyAction, 1);
@ParaIn: 
    * sModule, String, ģ���������ڶ�λ����
    * pfAction, Function, ������
    * oPara, paraList, �����������Ŀɱ������б�
@Return: none
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    thread: function(sModule, pfAction, oPara)
    {
        return this.delay(sModule, 0, pfAction, oPara);
    }
}
Frame.OS = OS;

var Signal = 
{
    _NAME: "Frame.Signal",
    
/*****************************************************************************
@FuncName: private, Frame.Signal._create
@DateCreated: 2011-08-15
@Author: huangdongxiao 02807
@Description: �жϲ�����һ���ź����������Ѿ������򲻽��д��������������򴴽���
    �ź��������ݽṹΪ��
    <code>
            oSignal = 
            {
                name: sSignal,
                status: "waiting",
                cb: []
            }
    </code>
@Usage: 
    // �����ź�����
    var sSignalName = "Xxx.Xxx.Xxx";

    // �����ź���
    var oSignal = Signal._create(sSignal);
@ParaIn: 
    * sModule, String, ģ�������ڿؼ��п����ÿؼ������ƴ��档
    * sSignal, string, �ź������ƣ��ɸ������źŵĿؼ����壬����ʹ�ÿؼ���·������"Libs.Frame.Xxx"��
@Return: Signal, ����ָ�����ź����Ѵ��ڣ��򷵻ظ��ź���������
    �����������ȴ�����Ȼ���ٷ����´������ź�������
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    _create: function(sModule, sSignal)
    {
        var db = Frame.DBM.open(sModule, {openFlag: "read"});
        if(null == db)
        {
            db = Frame.DBM.open(sModule, {openFlag: "read|write|create"});
        }

        var oSignal = Frame.DBM.get(db, sSignal, false);
        if(false === oSignal)
        {
            oSignal = {title:this._NAME, name: sSignal,status: "waiting",cb: []};
            Frame.DBM.set(db, sSignal, oSignal);
        }

        return oSignal;
    },

    reset: function(sModule, sSignal)
    {
        var db = Frame.DBM.open(sModule, {openFlag: "read"});
        if(null == db)
        {
            // no database
            return false;
        }

        var oSignal = Frame.DBM.get(db, sSignal, false);
        if(false === oSignal)
        {
            // no data item
            return false;
        }

        if("isReady" == oSignal.status)
        {
            oSignal.status = "reset";
        }

        for(var i=0; i<oSignal.cb.length; i++)
        {
            Timer.destroy(oSignal.cb[i].timer);
        }
        
        return true;
    },

/*****************************************************************************
@FuncName: public, Frame.Signal.wait
@DateCreated: 2011-08-15
@Author: huangdongxiao 02807
@Description: �ȴ�һ���źŵ��һ����һ���������ڵȴ��ؼ���ĳһ�ź�ʱʹ�ã�
    Ҳ������һ���ؼ��еȴ�����һ���ؼ��е��źš�ÿ���źŶ���Ҫ��һ���ź����ƣ�
    �ź������Զ��崮��ʽ�ɸ������źŵĿؼ����壬�ȴ���ʹ�á�
    һ���źſ��ܻ��ж����˵ȴ����źŵ������ȴ��߻ᰴ��˳�����д���
    ����ʱ���Է���false��ֹ�������˵Ĵ������ȴ��ߴ������Լ����������������뿪��
    �����ٴ���������ready�¼���
    �����ڵȴ�ʱ�ź��Ѿ������ֱ�ӽ���ͬ����������ִ�еȴ�������
    �ڶ����ź�����ʱ����ʹ�ÿؼ���·������"Libs.Frame.Xxx"��
    <P>Ӧ�ó�������һ���ؼ��漰������JS�ļ�ʱ�����Գ�����һ����һ��JS�ļ��ɸ�ģ��������
    �ڸ�JS�ļ����Լ�����ȫ������Ҫ��JS�ļ���������ҳ������Ҫ��ʵ�ʵ�JS load���Ϻ�����һЩ���飬
    ��ҳ������Ҫʹ�ÿؼ��ṩ���ź������еȴ�����������onPanelFinished
@Usage: 
    // �����ź�����
    var sSignalName = "Libs.Frame.Xxx";

    //���崦����������������Ҫ����
    function _Signal_PlotReady()
    {
        Frame.Msg.Info("signal is ready: " + sSignalName);
    }
    
    // �ȴ��ź���
    Frame.Signal.wait(sSignalName, "mytest",  _Signal_PlotReady);
    
    // Ҳ����ʹ������������
    Frame.Signal.wait(sSignalName, "mytest",  function()
    {
        Frame.Msg.Info("signal is ready: " + sSignalName);
    });
@ParaIn: 
    * sModule, String, ģ�������Ǳ��ȴ�ģ����ģ�����������Լ�ģ����ģ������
    * sSignal, String, �ź������ƣ��ɸ������źŵĿؼ����壬����ʹ�ÿؼ���·������"Libs.Frame.Xxx"��
    * fn, Function, �ź����������Ĵ���������ʽΪ String function (bTimeout)��
    <p>������˵��:
    <li>paras<br>
    bTimeout, boolean, �Ƿ���ʱ. ��waitʱ���������˳�ʱʱ��,���ڳ�ʱ��Ҳ�����õȴ�����,������Ϊtrue,��������������,������Ϊfalse
    <li>return: "continue", ��Ҫ�����ȴ�, ��ʱ���������ᱻ����,���������ٴ�֪ͨready,��������ִ��һ�θô�����; 
        "ok", �Ѿ���������,��ʱ���������Ӵ��������б�����,���������ٴ�֪ͨready,�������ٴ�ִ�иú���
    *iTimeout, integer, �ȴ���ʱʱ�䣬��λΪ�롣Ĭ��Ϊ0����ʾ������ʱ���ڸ�ʱ����������û�еȵ��źţ����Ժ����ٴ���
@Return: void
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    wait: function(sModule, sSignal, fn, iTimeout)
    {
        var oSignal = Signal._create(sModule, sSignal);

        Frame.Debuger.assert(oSignal, Frame.Util.sprintf("signal: %s not exist", sSignal));
        if("isReady" == oSignal.status)
        {
            // �ź��Ѿ�׼����,ֱ�ӵ��ô���������
            Frame.Debuger.info(sModule+": signal("+sSignal+") is ready, call function now");
            if("continue" != fn(false))
            {
                // �ȴ������Ѿ��������Լ�������, ֱ�ӷ���.
                return;
            }
            // else, �ȴ���������Ҫ�����ȴ��������źŽ��д���.
        }
        
        // �ź�û��׼����, ��Ҫ��������
        Frame.Debuger.info(Frame.Util.sprintf("%s: cache the signal - %s", sModule, sSignal));
        var hTimer = false;
        if(iTimeout > 0)
        {
            var iIndex = oSignal.cb.length;
            hTimer = Timer.create("Signal.wait", function()
            {
                // ��ʱ���еĵȴ�������û�д������󲻼����ȴ�
                Frame.Debuger.info(Frame.Util.sprintf("%s: signal(%s-%s) is timeout.", Signal._NAME, sSignal, oSignal.cb[iIndex].title));
                oSignal.cb[iIndex].cb(true);
                oSignal.cb[iIndex] = null;
            }, iTimeout*1000);
        }
        oSignal.cb.push({cb:fn, title: sModule, timer: hTimer});
    },

/*****************************************************************************
@FuncName: public, Frame.Signal.waitVar
@DateCreated: 2013-07-04
@Author: huangdongxiao 02807
@Description: �ȴ�ĳһ����������ʱִ��ָ���ĺ�����
    һ����������ģ������ͬ������<a href=#Frame.Signal.wait">Frame.Signal.wait</a>�ļ����÷�
@Usage: 
    // ��������
    var sMyName;
    
    // �ȴ�sMyName��ֵ��ִ��ָ���Ķ���
    Frame.waitVar(
        function(){return sMyName?true:false;},
        function(){alert(sMyName);}
    );

    // �Ӻ�̨��ȡ���ݣ�����ֵ��sMyName
    Frame.SRequest.getInstance("get", "1")
        .appendNode("Syslog").appendNode("LogHosts")
            .appendNode("Host")
                .appendColumn("Address", oData.Address)
    .root().get(function(){sMyName=this.Syslog.Host[0].Address;}
    
@ParaIn: 
    * pfReady, Function, wait�������жϺ���������trueʱ���������������ȴ���
        �����л�ѭ���жϣ����˸ú����ڵ�ʵ�ֲ�Ҫ�����򵥣�������ֻ��һ�������жϡ�
    * pfExcute, Function, wait����ʱִ�еĶ��󣬸ú���û�в�����������Ҫ�����߿����ȷ�װһ�¡�
@Return: void
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    waitVar: function(pfReady, pfExcute)
    {
        var hTimer = setInterval(function()
            {
                if(true===pfReady())
                {
                    clearInterval(hTimer);
                    pfExcute();
                }
            }, 10)
    },
    
/*****************************************************************************
@FuncName: public, Frame.Signal.ready
@DateCreated: 2011-08-15
@Author: huangdongxiao 02807
@Description: �����ź����ɡ����ؼ����źŵ���ʱ����Ҫ���øýӿ�֪ͨ�ȴ���ģ�����д���
@Usage: 
    // �����ź�����
    var sSignalName = "Libs.Frame.Xxx";
    
    // ֪ͨ��ģ���ź��Ѿ�׼����
    Frame.Signal.ready(sSignalName);
@ParaIn: 
    * sSignal, string, �ź������ƣ��ɸ������źŵĿؼ����壬����ʹ�ÿؼ���·������"Libs.Frame.Xxx"��
@Return: void
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    ready: function(sModule, sSignal)
    {
        var oSignal = Signal._create(sModule, sSignal);
        Frame.Debuger.assert(oSignal, "signal not exist");

        // notify all the waiters
        Frame.Debuger.info(Frame.Util.sprintf("%s: signal(%s) is ready.", sModule, sSignal));
        var aWaitCb = [];
        $.each(oSignal.cb, function(i, oInfo)
        {
            if(null !== oInfo)
            {
                if(false != oInfo.timer)
                {
                    Timer.destroy(oInfo.timer);
                    oInfo.timer = false;
                }
                if( oInfo.cb && ("continue" == oInfo.cb(false)) )
                {
                    // �ȴ�����û�д���������, ��Ҫ�����ȴ���һ��ready
                    aWaitCb.push(oInfo);
                }
            }
        });
        
        // clear all the notify Callbacks
        oSignal.status =  "isReady";
        oSignal.cb = aWaitCb;
    },
    
/*****************************************************************************
@FuncName: public, Frame.Signal.remove
@DateCreated: 2011-08-15
@Author: huangdongxiao 02807
@Description: ɾ���ź�����һ���ò���
@Usage: 
    Frame.Signal.remove(sSignalName);
@ParaIn: 
    * sSignal, string, �ź������ƣ��ɸ������źŵĿؼ����壬����ʹ�ÿؼ���·������"Libs.Frame.Xxx"��
@Return: void
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    remove: function(sModule, sSignal)
    {
        Frame.DBM.del(sModule, sSignal);
    }
} // end of Signal
Frame.Signal = Signal;

/*****************************************************************************
@FuncName: class, Frame.Ajax
@DateCreated: 2011-08-15
@Author: huangdongxiao 02807
@Description: Web�����ṩ��ajax�࣬������װ��JQuery��ajax��������web�������ص�һЩ����
    Frame.Ajax��Ҫ��SRequest���ã���ҳ������������һ�㲻��Ҫʹ�á���������������ҳ�棬
    ʹ��ǰ�����Ⱥ�web��ȷ��һ�¡�
@Usage: 
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
var Ajax = 
{
    _NAME: "Frame.Ajax",

/*****************************************************************************
@FuncName: public, Frame.Ajax.disable
@DateCreated: 2011-08-15
@Author: huangdongxiao 02807
@Description: ����ajax, �������豸����, �����˳���¼ʱ����ʹ�øú�����ֹ����������Ӱ��.
    ����һ��ȫ�ֵĲ��󣬵��øýӿں�������ajax���ö�������Ч���ظ�����ʱֻ�е�һ����Ч
@Usage: 
    Frame.Ajax.disable();
@ParaIn: None
@Return: void
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    disable: function()
    {
        Ajax._disable = true;
    },

/*****************************************************************************
@FuncName: public, Frame.Ajax.enable
@DateCreated: 2011-08-15
@Author: huangdongxiao 02807
@Description: ʹ��Ajax���� <a href="Frame.Ajax.diable">Frame.Ajax.disable</a> �ķ���������
    �ظ�����ʱֻ�е�һ����Ч
@Usage: 
    Frame.Ajax.enable();
@ParaIn: None
@Return: void
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    enable: function()
    {
        Ajax._disable = false;
    },

/*****************************************************************************
@FuncName: public, Frame.Ajax.send
@DateCreated: 2011-08-15
@Author: huangdongxiao 02807
@Description: Ajax�·��ӿ�. ���ӿ�һ����������ҳ�洦����ʹ��XCMP�·��Ĳ���Ҫʹ�ñ��ӿڡ�
@Usage: 
    // ʹ��Ĭ��ѡ��
    Frame.Ajax.send(sUrl);

    var oAjax ;
    function getData()
    {
        // �Զ���ѡ��
        oAjax = Frame.Ajax.send(sUrl, {
            paras: {para1: 1, para2:"abc", para3:"test"}, 
            showMsg: false,
            onFailed: function(sErrType, sMsg)
            {
                if ("failed" == sErrType)
                {
                    // �豸�Ϸ�����ʧ��
                    Frame.Msg.alert(sMsg);
                    $("#apply_reboot").button("enable");
                }
            }
        });
    }

    function stopRequest()
    {
        if(oAjax)
        {
            oAjax.abort();
            oAjax = false;
        }
    }
@ParaIn: 
    * sUrl, String, �·���URL, ����Ϊ��
    * opt, AjaxOption, Ajax�·�����. ����Ϊ��
@Return: JQueryAjax, ����JQuery��Ajax���󡣿���ʹ��abort������ֹ�ѷ��͵�����
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    send: function(sUrl, option)
    {

/*****************************************************************************
@typedef: AjaxOption
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: AjaxĬ��ѡ��. �������г�����ѡ���⣬jquery��ajax������ѡ��(���ο�jQueryAPI.chm)������ʹ�á�
<span class="notice">ע�⣺</span> Web����������onComplete��onSuccess��onFailed�����¼�������
�ֱ�����jQuery�е�complete��success��error�����˽�ֹ��ҳ����option�д���jQuery�е�����������
<div id="onajaxfailed" class="key">����������</div>
Ajax�·�ʧ�ܺ��Ĵ�������ʧ�ܵ�����������
    <ol>
    <li>set����ʱ��̨���������ö��󣬵�����û�гɹ�����ҵ�������ó�����
    <li>�û���ʱ��������Աͨ�������л��������ķ���free web user�����ٲ���ҳ������ʾ��ʱ������ȷ�������Զ�ת����¼ҳ�档
    <li>û��Ȩ�ޡ���û��setȨ�޵��û��·�set����ʱ�᷵�ظô�����һ�������ڵ��Խ׶Σ������汾����Ӧ�ó��ָ���ʾ
    <li>������ʱ���������·�����ʱ��timeout���������ڳ�ʱ��Ҳ��֪ͨ���¼������ô���һ�������ڸ߶Ƚ׶�
    <li>���粻ͨ�������󱸵������޸�IP�ȵ������粻ͨʱ����֪ͨ
    </ol>
���������ܻ���ȡ�����ַ��������ݸ�onFailed��
<div class="function-desc">
����ԭ�ͣ�function onFailed(sErrType, sErrMsg)<br>
����: 
    <li>sErrType, String, �������ͣ������¼����⻹�м����ڲ�ʹ����error, parseError�ȡ���ģ��������Ҫ�жϣ�
        ����ʹ�������жϣ���ֻ�ж��Լ����ĵ����ͣ������ĺ��Բ�����
        <ol>
        <li>failed, ҵ��ģ�����ô���
        <li>timeout, �ڳ�ʱʱ��������û������
        <li>abort, �������ж�
        <li>deny, û��Ȩ��
        <li>logout, �˳���¼
        <li>disconnect, �����ж�
        <li>unknow, δ֪����
        </ol>
    <li>sErrMsg, String, �����Ĵ����ַ�����HTML��ʽ��
<div>����ֵ��None</div>
</div>
���������ô�������, sErrTypeΪfailed��
<pre class=code>{
    "rpc-error":[
    {
        "error-type":"application",
        "error-tag":"operation-failed",
        "error-severity":"error",
        "error-path":"/rpc/edit-config[1]/config[1]/top[1]/Ifmgr[1]/Interfaces[1]/Interface[3]/PVID[1]",
        "error-message":"����ʧ�ܡ�",
        "error-info":
        {
            "top":
            {
                "Ifmgr":
                {
                    "Interfaces":
                    {
                        "Interface":
                        {
                            "ConfigSpeed":"1000",
                            "ConfigDuplex":"2",
                            "VlanType":"1",
                            "PVID":"6",
                            "Index":"284",
                            "Shutdown":"0",
                            "Description":"test more port setup"
                        }
                    }
                }
            }
        }
    },
    {
        // �ڶ���������
        // ...
    }]
}</pre>
<p>�����������ô����⣬�����Ķ������쳣�����������ݸ�ʽ�Ͳ���������ͬ��
    <ol>
    <li>this����ָ��������error-info�ṹ��������������ajax���󣬸�ģ������ͨ���ö�����ȡԭʼ����
    <li>�����ַ���һ��û�пɶ��ԣ���������ʾ���û�
    </ol>
<div id="onajaxsuccess" class="key">�ɹ��ص�����</div>
Ajax�·��ɹ����Ĵ�������û�в���������ͨ��this��ȡ��̨���ص����ݣ�get��set��ȡ�������ݸ�ʽ��ͬ��
        getʱ������һ�����·��Ľṹ��ͬ��JSON��������
<pre class=code>
    {
        Syslog:
        {
            Logs:[
                {Time: "2012-07-03T17:38", Servery: 3, ...},
                {Time: "2012-07-03T12:31", Servery: 2, ...}
            ]
        }
    }
</pre>
        setʱ���ص�������һ�����ý���(ֻ��һ��ok��һ�㲻��Ҫ����)��
        <div class="function-desc">
        ����ԭ�ͣ�function onSuccess()<br>
        ����ֵ��None
        </div>
@fields:
    * showMsg - Boolean, ��ajax�����������Ƿ��ɿ�����ʾ��ʾ��Ϣ. Ĭ��ֵΪtrue.
    * role, String, ��ǰ������Ȩ������, Ĭ����false,��������. ��ЧֵΪread, write, execute
    * menuId, String, ���������Ĳ˵�. ��roleһ���жϵ�ǰ�·���Ȩ��. ��Ȩ�޲���, ֱ��֪ͨ������, ���·����豸��. ��û�и�����ʱʹ�õ�ǰ�˵�
    * successMsg - String, �ɹ�ʱ����ʾ��Ϣ�ַ���. Ĭ�������¿��ܻ���ʾһ�������Ե��ַ���, 
        ����ĳҳ����Ҫ��ʾ���ַ���, ����ͨ�������Խ����޸�
    * failedMsg - String, ʧ��ʱ����ʾ��Ϣ�ַ���. Ĭ�������¿��ܻ���ʾ�豸�Ϸ��ص��ַ���.
        ����ĳҳ����Ҫ��ʾ�������ַ���, ����ͨ�������Խ����޸�
    * paras, JSON, �·�����, ��ʽΪ{paraname: paravalue}
    * getErrMsg, Function, ��ȡRPC����������Ϣ. ���������ò���ʱ����̨�Ĵ�������netconfЭ���ĸ�ʽ���أ����ܻ�ת��ΪJS������
        �����ñ��ӿڻ�ȡ��������Ӧ��������Ϣ��ͬ��̨���صĴ���һ����ʾ���û���<br>
        ����ԭ�ͣ�function(sXPath, oErrInfo)<br>
        ����ֵ��String,  �����ж�Ӧ�����������򷵻������ַ��������򷵻ؿմ����������ö˿ڵ�PVIDʱ���������Է���
        "���ö˿�Ethernet1/0/1��PVID������"���߷���"�˿�����Ethernet1/0/1, ������: PVID"��������ʾ���û�����ʾ���£�<br>
        <div class="dlg-alert">
        ����ʧ�ܡ�<br>
        �˿�����Ethernet1/0/1, ������: PVID
        </div>
    * onComplete - Function, �·����ɺ��Ļص�����, �����ֳɹ���ʧ��. ���¼�֪ͨ��, �Ի�֪ͨ�ɹ���ʧ�ܵ��¼�����
    * onSuccess - #onajaxsuccess/Function, �ɹ��ص��������·��ɹ������á�
    * onFailed - #onajaxfailed/Function, �����ص��������·�ʧ�ܺ��ĵ��á�
@Modification:
    * yyyy-mm-dd: Author, add or modify something
    * 2011-07-27: �ƶ���, ����closeOnEscape����
*******************************************************************************/
        var opt = {
            // �����Զ�������
            showMsg: true,
            role: false,
            successMsg: null,
            failedMsg: null,
          //  onGetErrMsg: onGetErrMsg,
            onComplete: $.noop,
            onSuccess: $.noop,
            onFailed: $.noop,

            // jquery��ajax����
            cache: false,
            dataType: "json",
            type: option?option.type:"POST",
            url: sUrl,
            data: option ? option.paras : null,
            complete: option? option.onComplete : null,
            success: function(oJson, sCode)
            {
                var pfOutput = $.noop;
                var sMsg;
                var bSuccess = true;

                if(Ajax._disable) return;

                if (oJson.ok)
                {
                    sMsg = (opt.successMsg) ? opt.successMsg : $.MyLocale.SET_SUCCESS;
                    pfOutput = Frame.Msg.info;
                }
                else if (oJson.error)
                {
                    sMsg = (opt.failedMsg) ? opt.failedMsg : oJson.error;
                    pfOutput = Frame.Msg.error;
                    bSuccess = false;
                }
                else if (oJson["rpc-error"])
                {
                    var aRpcErr = oJson["rpc-error"];
                    if(aRpcErr.length>1)
                    {
                        pfOutput = Frame.Msg.merror;
                        sMsg = getRpcErr(aRpcErr);
                    }
                    else
                    {
                        pfOutput = Frame.Msg.error;
                        sMsg = (opt.failedMsg) ? opt.failedMsg : getRpcErr(aRpcErr)[0];
                    }
                    bSuccess = false;
                }
                opt.showMsg && pfOutput(sMsg);

                if(bSuccess)
                {
                    if("text" == opt.dataType)
                    {
                        opt.onSuccess.apply({}, [oJson, sMsg]);
                    }
                    else
                    {
                        opt.onSuccess.apply(oJson, [sMsg]);
                        opt.onSuccess(oJson);
                    }
                }
                else
                {
                    opt.onFailed.apply(oJson, ["failed", sMsg]);
                }
            },
            error: function(oHttp, sDesc, oExcept)
            {
                var pfOutput = Frame.Msg.error;
                var pfAfterClosed = false;
                var sMsg = "";
                var sErrType = "unknow";

                if(Ajax._disable) return;

                Frame.Debuger.info("[ajax] error, url="+opt.url);
                if(("abort" == sDesc)||("timeout" == sDesc))
                {
                    sErrType = sDesc;
                    opt.showMsg = false;
                }
                else if (400 == oHttp.status)
                {
                    sErrType = "logout";
                    sMsg = $.MyLocale.TIMEOUT;
                    opt.showMsg = true;
                    Ajax.disable();
                    pfAfterClosed = Frame.logout;
                }
                else if (0 == oHttp.status)
                {
                    sErrType = "disconnect";
                    sMsg = $.MyLocale.DISCONNECT;
                    opt.showMsg = false;
                }
                else if (403 == oHttp.status)
                {
                    sErrType = "deny";
                    sMsg = opt.failedMsg || $.MyLocale.NO_PRIVILEGE;
                }
                else
                {
                    sMsg = sDesc+". staus=" + oHttp.status + ", text=" + oHttp.statusText;
                    Frame.Debuger.error("ajax: " + sMsg);
                    opt.showMsg = false;
                    sMsg = $.MyLocale.JSON_ERR;
                }

                opt.showMsg && pfOutput(sMsg, pfAfterClosed);
                if ("logout" == sErrType)
                {
                    return;
                }

                opt.onFailed && opt.onFailed.apply({}, [sErrType, sMsg]);
            }
        };

      /*  function getXPath(sXPath)
        {
            // "/rpc/edit-config[1]/config[1]/top[1]/Ifmgr[1]/Interfaces[1]/Interface[2]/VLANOpt[1]/PVID[1]"
            var nStart = sXPath.indexOf("/top[1]/");
            sXPath = sXPath.substring(nStart+8);      // Ifmgr[1]/Interfaces[1]/Interface[2]/VLANOpt[1]/PVID[1]
            return sXPath.replace(/\[[0-9]*\]/g,"");  // Ifmgr/Interfaces/Interface/VLANOpt/PVID
        }*/

        /*function onGetErrMsg(sXPath, oErrInfo)
        {
            var aJsonPath = sXPath.replace(/(\[[0-9]+\])/g,"").split('/');
            var sErrItem = aJsonPath[aJsonPath.length-1];
            var errLabel = $("#"+sErrItem).prev();
            return ""; //errLabel.html();
        }*/

       /* function getRpcErr(aErrs)
        {
            var aMsgAll = [];
            for(var i=0; i<aErrs.length; i++)
            {
                var oErr = aErrs[i];
                var sMsg = oErr["error-message"];
                if("access-denied" == oErr["error-tag"])
                {
                    // Ȩ�޲���ʱʹ�ÿ����ж�������ʾ��Ϣ
                    sMsg = $.MyLocale.NO_PRIVILEGE;
                }
                var sXPath = oErr["error-path"];    // ֱ�Ӵ�netconf���صĴ�����Ϣ��û��error-path��error-info
                var oErrInfo = oErr["error-info"] ? oErr["error-info"]["top"] : {};
                var sCfg = sXPath ? opt.onGetErrMsg(getXPath(sXPath), oErrInfo) : "";

                if(sCfg)
                {
                    sCfg = "<span class='error-type'>"+sCfg +": </span>";
                }

                aMsgAll.push("<div>" + sCfg +"<span class='error-reason'>" + sMsg + "</span></div>");
            }
            return aMsgAll;
        };*/
        
        if(Ajax._disable) return false;

        $.extend(opt, option);
        /*if(opt.role && opt.menuId)
        {
            var oProv = Frame.Menu.getPrivilege(opt.menuId);
            if(!oProv) return false; // page is loading
            if (true !== oProv[opt.role])
            {
                opt.error({"status":403});
                opt.complete && opt.complete();
                return false;
            }
        }*/
 //       Frame.Debuger.info("[ajax] send url:"+opt.url);
        return $.ajax(opt);
    }
} // end of Ajax
Frame.Ajax = Ajax;


var Theme = {
    init: function()
    {
        var jMenuTheme = $("#menuTheme");
        $(".theme", jMenuTheme).click(function(e)
        {
            var jEle = $(this);
            var sThemeName = jEle.attr("data-style");

            if (jEle.is(".active"))
            {
                return false;
            }

            // refresh page
            Frame.Cookie.set({"theme": sThemeName});
            setTimeout(function(e){Utils.Base.refreshCurPage ();}, 20);
            return false;

            // or load theme
            Theme.loadTheme(sThemeName, true);
            jMenuTheme.find(".active").removeClass("active");
            jEle.addClass("active");

            return false;
        });

        var sThemeName = Frame.Cookie.get("theme") || "blue";
        Theme.loadTheme(sThemeName, true);
        // $(".theme[data-style="+sThemeName+"]", jMenuTheme).click();
    }
    ,loadTheme: function(sThemeName, bResize)
    {
        // Frame.Cookie.set({"theme": sThemeName});
        sThemeName = "green";

        var sCss = Frame.Util.getPathUrl("frame/css/"+sThemeName+"/index.css");
        $("#mytheme").attr("href", sCss);

        var sConfig = Frame.Util.getPathUrl("frame/css/"+sThemeName+"/config.js");
        $.getScript(sConfig, function(){ThemeConfig.init()});
    }
    ,onChanged: function(sName)
    {
        $(window).resize();
        Frame.notify("all", "change.theme", sName);
    }
}
Frame.Theme = Theme;


/*
   ����һ����ҳ�棬�����б�ҳ���д�������ҳ���ȡ�
*/
var NewPage =
{
    _bOpened: false,
    jActiveEle: false  // ���Ԫ�ء���ȫ����ʾʱ��ʹ��jNewPage����ȫ����ʾʱʹ��jForm

    ,para: {}
    
    ,init: function(para)
    {
        if(para)
        {
            this.para = para;
        }

        if(!this.jActiveEle)
        {
            // this.jActiveEle = $("#edit_div .content");
            this.jActiveEle = $("#tabContent");
        }
    }
    
    ,isOpen: function()
    {
        return this._bOpened;
    }

    ,toggle: function()
    {
        if(this._bOpened)
        {
            this.close();
        }
        else
        {
            this.open()
        }
        return this;
    }
    
    ,open:function()
    {
        if(this._bOpened)
        {
            return this;
        }

        this._bOpened = true;
        Frame.notify("newPage", "open");
        return this;
    }
    ,close:function()
    {
        if(!this._bOpened)
        {
            return this;
        }

        this._bOpened = false;
        Frame.notify("newPage", "close");
        this.empty();
        return this;
    }
    ,empty: function()
    {
        Utils.Pages.destroy (this.jActiveEle);
        this.jActiveEle.empty();
        return this;
    }
    ,load: function(sUrl, pfInit)
    {
        Utils.Pages.loadModule(sUrl, this.para.data, this.jActiveEle, pfInit);
        return this;
    }
    ,update: function(oData, sModule)
    {
        Utils.Pages.updateJContent(this.jActiveEle, oData);
    }
}

var keepAlive =
{
    _lastOptTime: false,
    _hDelay: false,
    init: function()
    {
        // �û������, 5���ӷ�һ��keepalive����
        function userAlive()
        {
            var oCurTime = new Date();
            if ((oCurTime - keepAlive._lastOptTime) > MyConfig.config.keepAlive)
            {
                Frame.Ajax.send(Frame.Util.getDynUrl("keepalive.j"), {showMsg: false});
            }
            keepAlive._lastOptTime = oCurTime;
        }

        this._lastOptTime=new Date();
        this.start();
        $("body").bind("keyup", userAlive).bind("click", userAlive);
    },
    start: function()
    {
        // �����Ƿ���ʱ
        function checkTimeout()
        {
            var nIdleTimeMs = Frame.get("idletime", 10) * 60000;
            if (((new Date()) - keepAlive._lastOptTime) > nIdleTimeMs)
            {
                // ��ʱ�䲻����ʱ����Ҫlogout
                Frame.logout();
                return;
            }
            keepAlive._hDelay = Frame.OS.delay("Frame.KeepAlive", MyConfig.config.checkTimeout, checkTimeout);
        }

        if((false !== this._lastOptTime) && (false === keepAlive._hDelay))
        {
            // ��ʼ�����ɺ��ſ�ʼ����. startʱ���¿�ʼ��ʱ
            this._lastOptTime = new Date();
            checkTimeout();
        }
    },
    update: function()
    {
        if(false !== this._lastOptTime)
        {
            // ��ʼ�����ɺ��ſ�ʼ����
            Frame.Ajax.send(Frame.Util.getDynUrl("keepalive.j"), {showMsg: false});
            this._lastOptTime = new Date();
        }
    },
    pause: function()
    {
        // ���·�ǰ����ͣ, ��ֹ��̨��ʱ�����ᵼ��ǰ̨��ʱ�˳�
        Frame.OS.cancelDelay(keepAlive._hDelay);
        keepAlive._hDelay = false;
    }
}
Frame.keepAlive = keepAlive;

Frame.FileMnger = {
    showResult: function(bResult, sMsg)
    {
        Frame.Msg.alert(sMsg);
    }
}

Frame.Custom = 
{
    NAME: "Custom"
    ,VERSION: "1.0"
    ,changeLanguage: function(sLang)
    {
        $.getJSON(Frame.Util.getDynUrl("set-language.j?lang="+sLang), function(oResult)
        {
            if(oResult.error)
            {
                Frame.Debuger.warning("Change language failed");
            }
            // Frame.Custom.onLanguageChanged(sLang);
            window.location.reload();
        });

        Cookie.set({lang: sLang});
    }
    ,onLanguageChanged: function (sLang)
    {
        function _renderLanguage()
        {
            $.extend ($.MyLocale, $["MyLocale_"+sLang]);

            var oText = $.MyLocale.mainFrame;
            $.each(oText, function(key, item)
            {
                $("#"+key).html(item);
            });
            $("#username").text(Frame.get("username")).attr("title",Frame.get("username"));

            Frame.notify("all","language.changed");
        }

        function getCopyright(sLang)
        {
            function setCopyright()
            {
                if(!$.MyLocale.OEM[sLang])
                {
                    // save to locale
                    $.MyLocale.OEM[sLang] = $.MyLocale.OEM;
                }

                var oem = $.MyLocale.OEM = $.MyLocale.OEM[sLang];
                var sCopyright = Frame.Util.sprintf(oem.copyright, "", 2014);        
                $(".copyright").html(sCopyright);
            }

            if(!$.MyLocale.OEM[sLang])
            {
                var sJsFile = Frame.Util.getPathUrl("frame/oem/"+Frame.get("oem")+"/"+sLang+"/config.js");
                $.getScript(sJsFile, setCopyright);
            }
            else
            {
                setCopyright();
            }
        }

        Frame.NewMenu.init();
        $.extend ($.MyLocale, {OEM:{}});

        Frame.Debuger.info("Change to language: " + sLang);
        if($["MyLocale_"+sLang])
        {
            _renderLanguage();
        }
        else
        {
            var sJsFile = Frame.Util.getPathUrl("frame/"+sLang+"/locale.js");
            $.getScript(sJsFile, _renderLanguage);
        }
        //getCopyright(sLang);
    }
}

})(Frame)


;(function($F)
{
function getPageFilePath(sBase, sLibName)
{
    return sBase + $.trim(sLibName.replace(/\./g,"/").toLowerCase())+".js";
}

function log(sMsg)
{
	 Frame.Debuger.info("mjs: " + sMsg);
}

function mergeFiles(oModObj)
{
    var aJsFiles = [];
    var aUtils = oModObj.utils || [];
    var aWidgets = oModObj.widgets || [];
    var aLibs = oModObj.libs || [];
    var aSubModules = oModObj.subModules || [];

    aUtils.push("Widget");
    aUtils.push("Msg");
    // merge to a file list
    for (var i = 0; i < aLibs.length; i++)
    {
        aJsFiles.push(getPageFilePath("frame/libs/", aLibs[i]));
    }
    for (var i = 0; i < aWidgets.length; i++)
    {
        if ("TagInput" == aWidgets[i])
        {
            continue;
        }
        aJsFiles.push(getPageFilePath("frame/widgets_new/", aWidgets[i]));
    }
    for (var i = 0; i < aUtils.length; i++)
    {
        aJsFiles.push(getPageFilePath("frame/utils/", aUtils[i]));
    }
    for (var i = 0; i < aSubModules.length; i++)
    {
        aJsFiles.push(getPageFilePath("", aSubModules[i]));
    }
    return aJsFiles;
}

function getFileList(names, sBase)
{
    names = names||[];
    var aNames = ($.isArray(names)) ? names : names.split(";");
    var aFiles = [];
    for(var i=0; i<aNames.length; i++)
    {
        aFiles[i] = getPageFilePath(sBase, aNames[i]);
    }
    return aFiles;
}

var Libs = {
	load: function (libs, pfNotify) 
	{
        var aFiles = getFileList(libs, "frame/");
        loadJSFiles(aFiles, pfNotify);
	}
};
$F.Libs = Libs;

$.extend($F.Utils, 
{
    loadUtil: function (utilName, pfNotify) 
    {
        var aFiles = getFileList(utilName, "frame/utils/");
        loadJSFiles(aFiles, pfNotify);
    },
    regUtil: function (sUtilName, oUtilObj)
    {
        var oPool = this;
        if(!oPool[sUtilName])
        {
            oPool[sUtilName] = oUtilObj;
        }
        log("reg util: " + sUtilName);
    }
});

var Widgets = {
    _oPool:{},
    loadWidget: function (widgetName, pfNotify) 
    {
        var aFiles = getFileList(utilName, "frame/widget_new/");
        loadJSFiles(aFiles, pfNotify);
    },
    regWidget: function (sWidgetName, oRegInfo)
    {
        Libs.load(oRegInfo.libs, function()
        {
            var oPool = Widgets._oPool;
            if(!oPool[sWidgetName])
            {
                oRegInfo.loadEnd = new Date();
                oPool[sWidgetName] = oRegInfo;
            }
        });
    },
    initWidgets: function (oWidgets, jContent)
    {
        if (!oWidgets)
        {
            return;
        }

        var aWidgets = oWidgets;
        if(!$.isArray(oWidgets))
        {
            aWidgets = [oWidgets];
        }

        var oPool = Widgets._oPool;
        for (var i = 0; i < aWidgets.length; i++)
        {
            var oWidgetsInfo = oPool[aWidgets[i]];
            oWidgetsInfo.init(jContent);
        }
        return;
    },
    destroyWidgets: function (oWidgets, jContent)
    {
        if (!oWidgets)
        {
            return;
        }

        var aWidgets = oWidgets;
        if(!$.isArray(oWidgets))
        {
            aWidgets = [oWidgets];
        }

        var oPool = Widgets._oPool;
        for (var i = 0; i < aWidgets.length; i++)
        {
            var oWidgetsInfo = oPool[aWidgets[i]];
            oWidgetsInfo && oWidgetsInfo.destroy(jContent);
        }
        return;
    }
    ,onChangeTheme: function ()
    {
        var oPool = Widgets._oPool;
        for (var sName in oPool)
        {
            var oWidgetsInfo = oPool[sName];
            if (oWidgetsInfo && oWidgetsInfo.changeTheme)
            {
                oWidgetsInfo.changeTheme ();
            }
        }
    }
};
$F.Widgets = Widgets;

Utils.Pages = {
    _oModulePara:{}
    ,Mods: new jsFileMange()
    ,getWindow: function(jPage)
    {
        var jPageWindow = jPage.closest(".modal");
        if(jPageWindow.length == 0)
        {
            jPageWindow = jPage.closest(".sub-page");
        }
        return jPageWindow;
    }
    ,closeWindow: function(jPageWindow)
    {
        if(jPageWindow.is(".modal"))
        {
            // dialog page
            jPageWindow.modal("hide");
            return ;
        }

        // right panel
        history.back ();
        // Frame.getHelpPanel().close();
    }
    ,loadJS: function(sModId, olibs)
    {
		var oMods = this.Mods;
		var oModPara = this._oModulePara;

		function onPageReady()
        {
            sModId = sModId.toLowerCase();
			var oModule = oModPara[sModId] || {content:$("#tabContent"), data:null};
			var jContent = oModule.content;
			var oData = oModule.data;
			var oPageInfo = oMods.getModInfo(sModId);
			Widgets.initWidgets(oPageInfo.widgets, jContent);
			oPageInfo.init(oData, jContent);

            if (oPageInfo.resize)
            {
                oPageInfo.resize (jContent);
            }

			return;
		}

		if (!olibs)
		{
			olibs = sModId;
		}
		this.Mods.loadJs(sModId, olibs, onPageReady);		
    }
    ,getModule: function (module)
    {
        var sModId = ("string" == typeof(module)) ? module : module.attr("modId");
        return this.Mods.getModInfo(sModId);
    }
    ,regModule: function(sModId, oModObj)
    {
        sModId = sModId.toLowerCase();
        this.Mods.regModule(sModId, oModObj);
    }
	,updateModule: function(sModId, oPara, jContent)
	{
		var oMods = this.Mods;
		if ($("[modId='" + sModId + "']").length > 0)
		{
			var oPageInfo = oMods.getModInfo(sModId);
			var pf = oPageInfo.update || oPageInfo.init;
			pf(oPara, jContent);
			return;
		}
	}
	,updateJContent: function(jContent, oPara)
	{
		var sModId = jContent.attr("modId");
		if (sModId)
		{
			Utils.Pages.updateModule(sModId, oPara, jContent);
			return;
		}
	}
	,destroy: function(para)
	{
		var sModId, jContent;

        if ("string" == typeof(para))
        {
            sModId = para;
        }
        else
        {
            jContent = para;
            sModId = jContent.attr("modId");
        }

        if (sModId)
        {
            sModId = sModId.toLowerCase();
            var oModPara = this._oModulePara;
            var oModule = oModPara[sModId] || {content:$("#summary_div"), data:null};
            var jContent = oModule.content;
            var oPageInfo = this.Mods.getModInfo(sModId);

         //   Utils.Request.clearMoudleAjax(sModId);

            jContent.removeAttr("modId");

            // the page maybe not exist
            if (oPageInfo)
            {
                oPageInfo.destroy();
                Widgets.destroyWidgets(oPageInfo.widgets, jContent);
            }

            delete oModPara[sModId];
        }
    }
    ,loadModule: function(sModId, oPara, jContent, pfFunc)
    {
        var aTemp = sModId.split("#");
        var sAnchor = aTemp[1];
        sModId = aTemp[0];

        function scrollToAnchor()
        {
            if(sAnchor)
            {
                var jAnchor = $("#" + sAnchor, jContent); 
                if(jAnchor.length)
                {
                    $("#page_container").scrollTop(jAnchor.offset().top);
                }
            }
        }

        function loadEnd ()
        {
            var jDlg = $(this).closest(".modal");
            if(jDlg.length > 0)
            {
                // move the dialog to center, after loading
                jDlg.modal ("layout");
            }

            scrollToAnchor();

            if (pfFunc)
            {
                pfFunc.apply(this);
            }
        }

        this.destroy(jContent);

        sModId = sModId.toLowerCase();
		this._oModulePara[sModId] = {"content":jContent, "data":oPara};
		var sUrl = sModId;
		if(-1 == sUrl.indexOf(".html"))
        {
            var aUrl = sModId.split(".");
            var nLen = aUrl.length-1;
            sUrl = "";
            for(var i=0;i<=nLen;i++)
            {
                if(i == nLen)
                {
                    sUrl = sUrl + "[lang]/" + aUrl[i] + ".html"; 
                }
                else
                {
                    sUrl = sUrl + aUrl[i] + "/";
                }
            }
        }
        
        sUrl = Frame.Util.getPathUrl(sUrl);
        jContent.attr("modId", sModId);
        jContent.empty().load(sUrl, false, loadEnd);
	}
    ,_resize: function ()
    {
        var oModPara = Utils.Pages._oModulePara;

        for (var sModId in oModPara)
        {
            var oPageInfo = false;
            var oModule = oModPara[sModId];
            if (oModule && oModule.content)
            {
                oPageInfo = Utils.Pages.Mods.getModInfo(sModId);
            }
            if (oPageInfo && oPageInfo.resize)
            {
                oPageInfo.resize (oModule.content);
            }
        }
    }
    ,onChangeTheme: function ()
    {
        var oModPara = Utils.Pages._oModulePara;

        for (var sModId in oModPara)
        {
            var oPageInfo = false;
            var oModule = oModPara[sModId];
            if (oModule && oModule.content)
            {
                oPageInfo = Utils.Pages.Mods.getModInfo(sModId);
            }
            if (oPageInfo && oPageInfo.changeTheme)
            {
                oPageInfo.changeTheme (oModule.content);
            }
        }
    }
};

function loadJSFiles(aFiles, pfNotify, notifyPara)
{
	var iFileNum = 0;
    var aSend = [];

    function loadOver(sJsFile)
    {
        log("load end of " + sJsFile);
    	iFileNum++;
    	if(aFiles.length === iFileNum)
    	{
    		pfNotify && pfNotify(notifyPara);
    	}
    	return;
    }

    // not files need load
    if(0 === aFiles.length)
    {
        pfNotify && pfNotify(notifyPara);
    }

    for (var i = 0; i < aFiles.length; i++)
    {
    	var sJsFile = Frame.Util.getPathUrl(aFiles[i]);
        log("load start of " + sJsFile);
    	$.loadScript(sJsFile, loadOver);
    }
}

function jsFileMange()
{
	this.loadJs = loadJs;
	this.regModule = regModule;
	this.getModInfo = getModInfo;

	var _oModPool = {};

	function getModFormPool(sModId)
	{
        sModId = sModId.toLowerCase();
		var oMod = _oModPool[sModId];
		if (!oMod)
		{
			oMod = null;
		}
		return oMod;
	}

	function setModToPool(sModId, oMod)
	{
        sModId = sModId.toLowerCase();
		_oModPool[sModId] = oMod;
		return;
	}

	function getModInfo(sModId)
	{
        sModId = sModId.toLowerCase();
		var oMod = getModFormPool(sModId);
		return oMod ? oMod.oModInfo : null;
	}

	function isModRegOk(oMod)
	{
		var bOK = false;
		if (oMod)
		{
			var oLoadInfo = oMod.oLoadInfo;
			bOK = (oLoadInfo.bJsFileOk && oLoadInfo.bUtilsOk && oLoadInfo.bWidgetsOk);
		}
		return bOK;
	}

	function setItemOk(sModId, sType)
	{
		var oMod = getModFormPool(sModId);
		var oLoadInfo = oMod.oLoadInfo;

		log("setItemOk: " + sModId + ", " + sType);

		if(true === oLoadInfo[sType])
		{
			Frame.Debuger.assert(false, "Duplicate setting");
			return;
		}

		oLoadInfo[sType] = true;
		if(isModRegOk(oMod))
		{
			oMod.pfNotyList(sModId);
		}
		return;
	}

	function loadJs(sModId, olibs, pfModRegNtfy)
	{
		log("jsFileMange loadJs: " + sModId);
		var oModule = getModFormPool(sModId);
		if (isModRegOk(oModule))
		{
			log("registered: " + sModId);
			pfModRegNtfy && pfModRegNtfy(sModId);
			return true;
		}

		if (oModule)
		{
            // is loading
			return true;
		}
		
		oModule = {
			oLoadInfo: {bJsFileOk:false, bUtilsOk:false, bWidgetsOk:false},
			pfNotyList:null,
			oModInfo: null
		};
		if (pfModRegNtfy)
		{
			oModule.pfNotyList = pfModRegNtfy;
		}
		setModToPool(sModId, oModule);

		// loading
        var aFiles = getFileList(olibs, "");
        log("js loading: " + sModId);
        loadJSFiles(aFiles, function()
        {
        	setItemOk(sModId, "bJsFileOk");
        });
        return false;
    }

    function regModule(sModId, oModObj)
    {
        oModObj.loadEnd = new Date();
        getModFormPool(sModId).oModInfo = oModObj;

        var isReady = function(oPool, aNames)
        {
            var bReady = true;
            aNames = aNames||[];
            for(var i=0; i<aNames.length; i++)
            {
                if(!oPool[aNames[i]])
                {
                    bReady = false;
                    break;
                }
            }
            return bReady;
        };
        var pfDebug = function(t1)
        {
            var t2 = new Date();
            if(t1 && (t2-t1 > 5000))
            {
                Frame.Debuger.error("Please check your widgets or utils's name in modal " + sModId);
                return false;
            }

            return t1;
        }

        function waitForWidget(sModId, aWidgets)
        {
            var t1 = new Date();
            Frame.Signal.waitVar(
                function(){t1=pfDebug(t1); return isReady(Widgets._oPool, aWidgets)},
                function(){setItemOk(sModId, "bWidgetsOk")});
        }
        function waitForUtils(sModId, aUtils)
        {
            var t1 = new Date();
            Frame.Signal.waitVar(
                function(){t1=pfDebug(t1); return isReady(Utils, aUtils)},
                function(){setItemOk(sModId, "bUtilsOk")});
        }

        function onLoadOver()
        {
            waitForWidget(sModId, oModObj.widgets||[]);
            waitForUtils(sModId, oModObj.utils||[]);
        }

        var aJsFiles = mergeFiles (oModObj);
        loadJSFiles(aJsFiles, onLoadOver);
    }
}

Frame.regNotify("mjs", "resize",  Utils.Pages._resize);
Frame.regNotify("mjs", "change.theme",  function(){
    Utils.Pages.onChangeTheme();
    Widgets.onChangeTheme()
});

})(window)
﻿/*******************************************************************************
 Copyright (c) 2007, Hangzhou H3C Technologies Co., Ltd. All rights reserved.
--------------------------------------------------------------------------------
@FileName:libs/frame/util.js
@ProjectCode: Comware v7
@ModuleName: Frame.Util
@DateCreated: 2011-07-27
@Author: lixiulan 06658
@Description:
    定义公用接口
@Modification:
*******************************************************************************/

;(function($F)
{

var Util = {

/*****************************************************************************
@FuncName: public,Frame.Util.generateID
@DateCreated: 2011-08-15
@Author: huangdongxiao 02807
@Description: 生成一个唯一ID字符串。部分控件在生成HTML时需要指定一个ID，但该ID不需要向页面公开，
    此时可以使用该接口生成一个ID在内部使用。
@Usage:
        var sId = Frame.Util.generateID("mydiv");
        var sHtml = "<div id="+sId+">my div</div>";
@ParaIn:
    * sPrefix - string, ID前缀，建议使用控件名称。
@Return: 无
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
generateID:function(sPrefix)
{
    sPrefix = sPrefix||"webid";

    return sPrefix+"_"+(""+Math.random()).substring(2);
},


/*****************************************************************************
@FuncName: public,Frame.Util.toText
@DateCreated: 2012-05-04
@Author: huangdongxiao 02807
@Description: 转换HTML格式的字符为文本字符, 可以在页面中正确显示HTML的标签和空格等特殊字符。
    <p>不支持换行显示，文本中的回车换行将被视为空格处理。即\r\n会被转换为空格。
@Usage:
    var sText = "abc<b>b</b>, space:       -            end";

    // 显示结果有标签和多个空格："abc<b>b</b>, space:       -           end"
    $("#myid").html(Frame.Util.toText(sText));

    // 显示结果没有标签且多个空格的地方只显示一个："abcb, space: -  end"
    $("#myid").html(sText);
@ParaIn:
    * sHtml - String, 需要转换的HTML字符串。
@Return: 无
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
toText: function(sHtml)
{
    return sHtml.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/[\t\r\n]/g," ").replace(/  /g,"&nbsp; ");
},

/*****************************************************************************
@FuncName: public,Frame.Util.toSpeedStr
@DateCreated: 2012-05-04
@Author: huangdongxiao 02807
@Description: 转换端口的速率为显示的字符串: 0-Auto, <1000, xxx K, <1000000 - xxx M, else xxx G
@Usage:
@ParaIn:
    * sHtml - String, 需要转换的HTML字符串。
@Return: 无
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
toSpeedStr: function(nSpeed)
{
    var k = nSpeed;
    var s = "";

    if(undefined == k)
    {
        return "";
    }

            else if(k>1000000)
            {
                s = (k/1000000) + "G";
            }
            else if(k>1000)
            {
                s = (k/1000) + "M";
            }
            else if(k>0)
            {
                s = k + "K";
            }
            else // k == 0
            {
                s = "Auto";
            }

            return s;
        },

/*****************************************************************************
@FuncName: public,Frame.Util.getPortList
@DateCreated: 2012-11-12
@Author: huangdongxiao 02807
@Description: 根据Netconf返回的PortList串，获取有具体意义的端口字符串。如端口名串、ifindex串等
@Usage:
    var sPortName = "Eth0/1/2.2";
    var sSortName = Frame.Util.toPortStr(sPortName);
    // 先获取数据
    Frame.SRequest.getInstance("get", "all")
        .appendNode("MAC")
            .appendNode("MacUnicastTable").parent()
            .appendNode("MacGroupTable").root()
        .appendNode("Ifmgr").appendNode("Ports").appendNode("Port").appendColumn("IfIndex,PortIndex,AbbreviatedName").root()
    .get(myCallback,"I_MAC_Summary");

    // 回调函数中拼装数据，这里是使用接口的缩写。
    function myCallback()
    {
        var i;
        var oPortList = {};
        if(this.MAC)
        {
            var oMac = this.MAC || {};
            var aMAC = oMac.MacUnicastTable || [];
            var aGroupMac = oMac.MacGroupTable || [];
            var aPort = this.Ifmgr.Interfaces;

                 for(i=0;i<aPort.length;i++)
                 {
                     oPortList[aPort[i].IfIndex] = aPort[i].Name;
                 }
                 for(i=0;i<aMAC.length;i++)
                 {
                     aMAC[i].id = "mac_"+i;
                     aMAC[i].PortName = aMAC[i].PortIndex ? oPortList[aMAC[i].PortIndex] : aMAC[i].NickName;
                 }
                 for(i=0; i<aGroupMac.length; i++)
                 {
                     aGroupMac[i].id = "gmac_"+i;
                     aGroupMac[i].PortName = Frame.Util.getPortList(aPort, "AbbreviatedName", aGroupMac[i].PortList);
                     aMAC.push(aGroupMac[i]);
                 }

            Frame.MList.refresh(LIST_NAME, aMAC);
        }
    }
    
@ParaIn:
    *aPort, Array,  从接口管理表中取的接口数组。由于不同模块用到的数据不同，因此由各模块获取端口列表数据
    *sKey, String, 接口的属性名。接口数据是一个对象，本参数指定要返回哪一个属性拼成的串。
    *sPortList, String, NetConf的PortList类型的十六进制字符串，格式为"ABCDEF123456"
@Return: String
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
getPortList: function(aPort, sKey, sPortList)
{
    function getNameByChar(nFrom, ch, aName)
    {
        var nVal = parseInt(ch, 16);
        var aLog = [];
        for(var i=0; i<4; i++)
        {
            if(nVal&0x8)
            {
                aLog.push(nFrom*4+i);
                aName.push(aPort[nFrom*4 + i][sKey]);
            }
            nVal = 0xF&(nVal<<1);
        }
    }

            var aName = [];
            var nCount = sPortList.length;
            for(var i=0; i<nCount; i++)
            {
                getNameByChar(i, sPortList.charAt(i), aName);
            }
            return aName.join(',');
        },

/*****************************************************************************
@FuncName: public,Frame.Util.toPortStr
@DateCreated: 2012-11-12
@Author: huangdongxiao 02807
@Description: 转换端口名为一个定长的字符串, 用于比较大小。
@Usage:
    var sPortName = "Eth0/1/2.2";
    var sSortName = Frame.Util.toPortStr(sPortName);
@ParaIn:
    * sPortName - PortString, 需要转换的端口名，可以是全名，也可以是简名。如：Ethernet1/0/1, Eth1/0/1, Ten-GibitEthernet2/0/51:1
@Return: String
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
toPortStr: function(sPortName)
{
    var iftype = sPortName.replace(/([a-zA-Z\-]*)[0-9\/:.]*/,"$1");
    var ifnumber = sPortName.substring(iftype.length);
    var a=ifnumber.split(/[:./]/);
    for(var i=0; i<a.length; i++)
    {
        a[i] = ("0000"+a[i]).substring(a[i].length);
    }
    return iftype+a.join('');
},

/*****************************************************************************
@FuncName: public,Frame.Util.IpStr2Integer
@DateCreated: 2012-11-12
@Author: huangdongxiao 02807
@Description: 转换IP地址字符串为一个整数。
@Usage:
    var sIp = "192.168.1.10";
    var nIp = Frame.Util.IpStr2Integer(sIp);

    // 几种转换结果
    Frame.Util.IpStr2Integer("255.255.255.255")==0xFFFFFFFF
    Frame.Util.IpStr2Integer("169.254.77.15")==0xa9fe4d0f
    Frame.Util.IpStr2Integer("1.1.1.1")==0x1010101
    Frame.Util.IpStr2Integer("0.0.0.1")==1
    Frame.Util.IpStr2Integer("0.0.0.0")==0
    Frame.Util.IpStr2Integer("255")==0
    Frame.Util.IpStr2Integer("2.3.3.62.54")==0
    Frame.Util.IpStr2Integer("269.354.77.15")==0
@ParaIn:
    * sIp - IpString, 点分十进制的IP地址字符串
@Return: String
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
IpStr2Integer: function(sIp)
{
    var arr = (sIp||"").split(".");
    var nIp = 0;
    var nTemp;

    if(4 != arr.length)
    {
        // 非法的IP地址
        return 0;
    }
    
    for(var i=0; i<4; i++)
    {
        nTemp = parseInt(arr[i], 10);
        if(nTemp > 255 || nTemp < 0)
        {
            return 0;
        }
        nIp = nIp*0x100 + nTemp;
    }
    return nIp;
},

/*****************************************************************************
@FuncName: public, Frame.Util.getLastVerdorNo
@DateCreated: 2011-8-5。
@Author: L06658。
@Description: 获取VendorType 的最后一位。更通用一点说就是获取以点分隔的字符串中的最后一段
@Usage:
    Frame.Util.getLastVerdorNo(sVendorType);
@ParaIn:
    * sVendorType- String, 完整的sysoid
@ParaOut:
@Return: String, VendorType 的最后一位
@Caution:
@Reference:
@Modification:
* 2011-08-05: 李秀兰, 提供 获取VendorType 的最后一位
*****************************************************************************/
getLastVerdorNo: function (sVendorType)
{
    var arr = sVendorType.split(".");
    return arr[arr.length-1];
},

getProtocalStr: function(nProtocalType)
{
    var aPrtl = {
        "0": "HOPOPT", // IPv6 逐跳选项
        "1": "ICMP", // Internet 控制消息
        "2": "IGMP", // Internet 组管理
        "3": "GGP", // 网关对网关
        "4": "IP", // IP 中的 IP（封装）
        "5": "ST", // 流
        "6": "TCP", // 传输控制
        "7": "CBT", // CBT
        "8": "EGP", // 外部网关协议
        "9": "IGP", // 任何专用内部网关（Cisco 将其用于 IGRP）
        "10": "BBN-RCC-MON", // BBN RCC 监视
        "11": "NVP-II", // 网络语音协议
        "12": "PUP", // PUP
        "13": "ARGUS", // ARGUS
        "14": "EMCON", // EMCON
        "15": "XNET", // 跨网调试器
        "16": "CHAOS", // Chaos
        "17": "UDP", // 用户数据报
        "18": "MUX", // 多路复用
        "19": "DCN-MEAS", // DCN 测量子系统
        "20": "HMP", // 主机监视
        "21": "PRM", // 数据包无线测量
        "22": "XNS-IDP", // XEROX NS IDP
        "23": "TRUNK-1", // 第 1 主干
        "24": "TRUNK-2", // 第 2 主干
        "25": "LEAF-1", // 第 1 叶
        "26": "LEAF-2", // 第 2 叶
        "27": "RDP", // 可靠数据协议
        "28": "IRTP", // Internet 可靠事务
        "29": "ISO-TP4", // ISO 传输协议第 4 类
        "30": "NETBLT", // 批量数据传输协议
        "31": "MFE-NSP", // MFE 网络服务协议
        "32": "MERIT-INP", // MERIT 节点间协议
        "33": "SEP", // 顺序交换协议
        "34": "3PC", // 第三方连接协议
        "35": "IDPR", // 域间策略路由协议
        "36": "XTP", // XTP
        "37": "DDP", // 数据报传送协议
        "38": "IDPR-CMTP", // IDPR 控制消息传输协议
        "39": "TP++", // TP++ 传输协议
        "40": "IL", // IL 传输协议
        "41": "IPv6", // Ipv6
        "42": "SDRP", // 源要求路由协议
        "43": "IPv6-Route", // IPv6 的路由标头
        "44": "IPv6-Frag", // IPv6 的片断标头
        "45": "IDRP", // 域间路由协议
        "46": "RSVP", // 保留协议
        "47": "GRE", // 通用路由封装
        "48": "MHRP", // 移动主机路由协议
        "49": "BNA", // BNA
        "50": "ESP", // IPv6 的封装安全负载
        "51": "AH", // IPv6 的身份验证标头
        "52": "I-NLSP", // 集成网络层安全性 TUBA
        "53": "SWIPE", // 采用加密的 IP
        "54": "NARP", // NBMA 地址解析协议
        "55": "MOBILE", // IP 移动性
        "56": "TLSP", // 传输层安全协议使用 Kryptonet 密钥管理
        "57": "SKIP", // SKIP
        "58": "IPv6-ICMP", // 用于 IPv6 的 ICMP
        "59": "IPv6-NoNxt", // 用于 IPv6 的无下一个标头
        "60": "IPv6-Opts", // IPv6 的目标选项
        //"61": "", //任意主机内部协议
        "62": "CFTP", // CFTP
        //"63": "", //任意本地网络
        "64": "SAT-EXPAK", // SATNET 与后台 EXPAK
        "65": "KRYPTOLAN", // Kryptolan
        "66": "RVD", // MIT 远程虚拟磁盘协议
        "67": "IPPC", // Internet Pluribus 数据包核心
        //"68": "", //任意分布式文件系统
        "69": "SAT-MON", // SATNET 监视
        "70": "VISA", // VISA 协议
        "71": "IPCV", // Internet 数据包核心工具
        "72": "CPNX", // 计算机协议网络管理
        "73": "CPHB", // 计算机协议检测信号
        "74": "WSN", // 王安电脑网络
        "75": "PVP", // 数据包视频协议
        "76": "BR-SAT-MON", // 后台 SATNET 监视
        "77": "SUN-ND", // SUN ND PROTOCOL-Temporary
        "78": "WB-MON", // WIDEBAND 监视
        "79": "WB-EXPAK", // WIDEBAND EXPAK
        "80": "ISO-IP", // ISO Internet 协议
        "81": "VMTP", // VMTP
        "82": "SECURE-VMTP", // SECURE-VMTP
        "83": "VINES", // VINES
        "84": "TTP", // TTP
        "85": "NSFNET-IGP", // NSFNET-IGP
        "86": "DGP", // 异类网关协议
        "87": "TCF", // TCF
        "88": "EIGRP", // EIGRP
        "89": "OSPFIGP", // OSPFIGP
        "90": "Sprite-RPC", // Sprite RPC 协议
        "91": "LARP", // 轨迹地址解析协议
        "92": "MTP", // 多播传输协议
        "93": "AX.25", // AX.25 帧
        "94": "IPIP", // IP 中的 IP 封装协议
        "95": "MICP", // 移动互联控制协议
        "96": "SCC-SP", // 信号通讯安全协议
        "97": "ETHERIP", // IP 中的以太网封装
        "98": "ENCAP", // 封装
        //"99": "", //任意专用加密方案 
        "100": "GMTP", // GMTP 
        "101": "IFMP", // Ipsilon 流量管理协议 
        "102": "PNNI", // IP 上的 PNNI 
        "103": "PIM", // 独立于协议的多播 
        "104": "ARIS", // ARIS 
        "105": "SCPS", // SCPS 
        "106": "QNX", // QNX 
        "107": "A/N", // 活动网络 
        "108": "IPComp", // IP 负载压缩协议 
        "109": "SNP", // Sitara 网络协议 
        "110": "Compaq-Peer", // Compaq 对等协议 
        "111": "IPX-in-IP", // IP 中的 IPX 
        "112": "VRRP", // 虚拟路由器冗余协议 
        "113": "PGM", // PGM 可靠传输协议 
        //"114": "", //任意 0 跳协议 
        "115": "L2TP", // 第二层隧道协议 
        "116": "DDX", // D-II 数据交换 (DDX) 
        "117": "IATP", // 交互式代理传输协议 
        "118": "STP", // 计划传输协议 
        "119": "SRP", // SpectraLink 无线协议 
        "120": "UTI", // UTI 
        "121": "SMP", // 简单邮件协议 
        "122": "SM", // SM 
        "123": "PTP", // 性能透明协议 
        "124": "ISIS", // over IPv4 
        "125": "FIRE", // 
        "126": "CRTP", // Combat 无线传输协议 
        "127": "CRUDP", // Combat 无线用户数据报 
        "128": "SSCOPMCE", // 
        "129": "IPLT", // 
        "130": "SPS", // 安全数据包防护 
        "131": "PIPE", // IP 中的专用 IP 封装 
        "132": "SCTP", // 流控制传输协议 
        "133": "FC" // 光纤通道 
    };
    return aPrtl[nProtocalType] || nProtocalType;
},

/*****************************************************************************
@FuncName: public, Utils.Base.sprintf
@DateCreated: 2011-07-27
@Author: lixiulan 06658
@Description: Format string, support%s, %d, %x
@Usage:
Utils.Base.sprintf("Sub slot%d is empty",31);  // Sub slot31 is empty
Utils.Base.sprintf("Sub slot %d abc","31abc");   // Sub slot 31 is empty
Utils.Base.sprintf("Sub slot %x is empty",31);   // Sub slot 1f is empty
Utils.Base.sprintf("Sub slot %X is empty","31abc");   // Sub slot 1F is empty
Utils.Base.sprintf("Sub slot %s is empty","31abc");   // Sub slot 31abc is empty
@ParaIn:
    * sFormat - string, String formater。
    * valuelist - void, formater value list。
@Return: Formattered string
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
sprintf: function (sFormat, valuelist)
{
    var sTemp;
    if (arguments.length == 1)
        return sFormat;

    var arrTmp = new Array();
    /**
     * 参数为一个字符串数组的形式
     */
    if ($.isArray(valuelist))
    {
        arrTmp = valuelist;
    }
    /**
     * 参数为多个字符串或数字的形式
     */
    else
    {
        for (var j=1; j<arguments.length; j++)
        {
            arrTmp[j-1] = arguments[j];
        }
    }

    var sRet = "";
    for ( var i=0; i<arrTmp.length; i++ )
    {
        var n = sFormat.indexOf("%");
        if ( n==-1 )
        {
            break;
        }
        sRet += sFormat.substring(0,n);
        var ch = sFormat.charAt(n+1);
        var sNewChar;
        switch ( ch )
        {
        case '%':
            sNewChar = "%";
            break;
        case 's':
            sNewChar = arrTmp[i];
            break;
        case 'x':
            sTemp = parseInt(arrTmp[i], 16).toString(16);
            sNewChar = sTemp.toLowerCase();
            break;
        case 'X':
            sTemp = parseInt(arrTmp[i], 16).toString(16);
            sNewChar = sTemp.toUpperCase();
            break;
        case 'd':
            sNewChar = parseInt(arrTmp[i], 10);
            break;
        default:
            sNewChar = "%"+ch;
            break;
        }

        sRet += sNewChar;
        sFormat = sFormat.substring(n+2);
    }
    sRet += sFormat;
    return sRet;
},

/*****************************************************************************
@FuncName: public,Frame.Util.osprintf
@DateCreated: 2011-07-27
@Author: h02807
@Description: 按照顺序格式化字符串, 需要格式化的部分使用{index}标记,index从0开始。
    sprintf只能按照变参的顺序依次填充，本函数可以按照格式化串中指定的顺序填充参数。
    <p>本函数不支持数据类型，所有的参数都按照字符串处理。
@Usage:
    Frame.Util.osprintf("Error for {1} of {0}", "PVID", "Eth0/1/1");
    // return "Error for PVID of Eth0/1/1"
@ParaIn:
    * sFormat - string, 格式信息字符串。
    * valuelist - void, 格式化的参数列表。
@Return: 无
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
osprintf:function(sFormat, valuelist)
{
    if (arguments.length == 1)
        return sFormat;

    var arrTmp;
    /**
     * 参数为一个字符串数组的形式
     */
    if ($.isArray(valuelist))
    {
        arrTmp = valuelist;
    }
    /**
     * 参数为多个字符串或数字的形式
     */
    else
    {
        arrTmp = [];
        for (var j=1; j<arguments.length; j++)
        {
            arrTmp[j-1] = arguments[j];
        }
    }

    var sRet = sFormat;
    for(var i=0; i<arrTmp.length; i++)
    {
        sRet = sRet.replace("{"+i+"}", arrTmp[i]);
    }
    return sRet;
},

/*****************************************************************************
@FuncName: public, Frame.Util.getHexColor
@DateCreated: 2014-09-29
@Author: Huangdongxiao 02807
@Description: Translate the color string to Hex-color-string
@Usage:
    Frame.Util.getHexColor("#abcdef"); // return "#abcdef"
    Frame.Util.getHexColor("rgb(171, 205, 239)");   // return "#abcdef"
@ParaIn:
    * sColor, string, RGB color string, or Hex color string
@Return: String, Hex color string, like "#abcdef"
@Caution:
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
getHexColor: function (sColor)
{
    if ('#' == sColor.charAt(0))
    {
        return sColor;
    }

    // RGB string, like: rgb(171,252,123)
    if (! /^rgb\([0-9]{1,3},[ ]*[0-9]{1,3},[ ]*[0-9]{1,3}\)$/.test(sColor))
    {
        return false;
    }

    var aTemp = sColor.split(/[(,)]/);
    var r = parseInt(aTemp[1]).toString(16),
        g = parseInt(aTemp[2]).toString(16),
        b = parseInt(aTemp[3]).toString(16);
    return "#" + r + g + b;
},

/*****************************************************************************
@FuncName: public, Frame.Util.getPathUrl
@DateCreated: 2011-06-30
@Author: Huangdongxiao 02807
@Description: 获取绝对路径的URL串。在V7中由于使用ajax，因此在load页面时使用相对路径是从index.html开始计算的。
    但页面本身的路径和index.html并不在一起，让页面自己用 ../ 的方式去计算相对路径不容易理解，且不易维护。
    所以提供本接口统一处理路径。
    <p>本函数支持动态指定语言，可以使用[lang]代替URL中的语言部分
@Usage:
    var sUrl = "syslog/summary.js";
    var sAbsUrl = Frame.Util.getPathUrl(sUrl);

    // 带有语言的URL
    var sUrl = "syslog/[lang]/summary.html";
    var sAbsUrl = Frame.Util.getPathUrl(sUrl);

    // 错误的调用
    var sAbsUrl = Frame.Util.getPathUrl("syslog/[lang]/") + "summary.html";
    var sAbsUrl = Frame.Util.getPathUrl("syslog/[lang]") + "/summary.html";
@ParaIn:
    * sAction, string, URL信息字符串。URL规则:
    <LI>如果是以http(s)://或者/开头的绝对路径的URL则直接返回
    <LI>其它的URL则添加上根路径后返回
    <LI>必须是完整的URL串,不能是半截
@Return: String, 绝对路径的URL字符串
@Caution:
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
getPathUrl: function(sAction)
{
    /*
    <LI>自定义的URL前缀(url::),此时获取url::后面的串为真实的URL
    <LI>自定义的JS前缀(js::), 此时获取js::后面的串为一个JS函数. 暂时不支持
    */
    var aUrl = sAction.split("::");
    var sUrl = sAction;
    if(aUrl.length>1)
    {
        switch(aUrl[0])
        {
        case "js":
            sUrl = null;    // 不支持
            break;
        case "url":
        default:
            sUrl = aUrl[1];
            break;
        }
    }
    else
    {
        sUrl = sAction;
    }

    if(null != sUrl)
    {
        // 如果设置了表态文件不缓存时需要在URL后增加一个随机数
        if(/\[lang\]/.test(sUrl))
        {
            sUrl = sUrl.replace("[lang]", Frame.get("lang"));
        }
        if(true!==MyConfig.config.cachePage)
        {
            sUrl += "?u="+Frame.get("rid");
        }

        // 如果是HTTP或者HTTPS开头的, 不需要处理
        if(/^https?:/.test(sUrl)) return sUrl;

        // 如果是绝对路径开头的(即以/开头), 不需要处理
        if("/"==sUrl.charAt(0)) return sUrl;

        var sRoot = MyConfig.root || "/";
        return sRoot+sUrl;
    }
},

/*****************************************************************************
@FuncName: public, Frame.Util.getDynUrl
@DateCreated: 2011-06-30
@Author: Huangdongxiao 02807
@Description: 获取动态URL的绝对路径串。动态URL和静态URL不是在一个根目录，可以通过该函数获取到一个相关动态URL的绝对路径。
<p>在V7中各页面全部使用XCMP下发，且XCMP已经封装了URL的下发，因此不需要也不应该关心动态URL。
只有在框架中或者特殊的页面中会用到。V7上支持的动态URL包括：
<ul>
    <LI>get.j, XCMP获取数据URL，已经封装在SRequest中
    <LI>set.j, XCMP下发数据URL，已经封装在SRequest中
    <LI>logout.j, 退出登录，框架使用
    <LI>menu.j, 显示菜单，框架使用
    <LI>reboot.j, 重启设备， 重启页面使用
    <LI>check.j, 检查设备能力，登录页面使用
    <LI>vcode.bmp, 显示验证码，登录页面使用
    <LI>login.j, 执行登录动作，登录页面使用
    <LI>file/upload.j, 文件上传URL，已经封装在Frame.FileMnger中
    <LI>file/download.j, 下载文件
    <LI>file/delete.j, 删除文件
    <LI>config/backup.j, 备份配置文件，配置管理页面使用
    <LI>config/restore.j, 恢复配置文件，配置管理页面使用
    <LI>config/export.j, 导出配置文件，配置管理页面使用
    <LI>keepalive.j, 超时检测，框架使用
</ul>
@Usage:
    var sDynUrl = Frame.Util.getDynUrl("login.j");
@ParaIn:
    * sUrl, String, 动态URL的相关对路径，即上面列出来的几种URL之一。如login.j, file/upload.j
@Return: String, 绝对路径的URL字符串
@Caution:
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
getDynUrl: function (sUrl)
{
    var sDynUrl = MyConfig.root + "../wnm/" + sUrl;
    ////{{Demo start
    if(true === MyConfig.config.local) 
    {
        // 本地demo时使用php后缀
        sDynUrl = sDynUrl.replace(/\.j/, ".php");
    }
    ////}}Demo end

            var s = (-1==sDynUrl.indexOf('?')) ? '?' : '&';
            sDynUrl += s + "sessionid="+Frame.get("sessionid");

            return sDynUrl;
        }

        /*****************************************************************************
         @FuncName: public, Frame.Util.extendAll
         @DateCreated: 2013-10-12
         @Author: Huangdongxiao 02807
         @Description: Extend a JSON Data, which is a nesting object, to a simple object.
         If exist the same proterty name, it will be recovered
         @Usage:
         var oData = {
        p1: 1,
        p2: 2,
        p3: {a1: "aa", a2:"bb"}
    };

         var oNewData = {};
         Frame.Util.extendAll(oNewData, oData);
         // oNewData = {p1:1,p2:2,a1:"aa",a2:"bb"};
         @ParaIn:
         * oNewData, Object, The resule object which is include all the proterty, It always is a empty object, eg: {}
         * oData, Object, a nesting object.
         * properties, String/Array, the extend properties, if not exist, extend all.
         @Return: Object, the new Data, same as the first parameter.
         @Caution:
         @Modification:
         * yyyy-mm-dd: Auth, add or modify something
         *****************************************************************************/
        ,extendAll: function(oNewData, oData, properties)
        {
            if(undefined === properties)
            {
                for(var key in oData)
                {
                    var sVarType = typeof(oData[key]);
                    if(("string" == sVarType) || ("number" == sVarType) || ($.isArray(oData[key])))
                    {
                        oNewData[key] = oData[key];
                    }
                    if("object" == sVarType)
                    {
                        arguments.callee(oNewData, oData[key])
                    }
                }
            }
            else
            {
                var aFields = ("string"==typeof(properties)) ? properties.split(",") : properties;
                for(var i=0; i<aFields.length; i++)
                {
                    var key = aFields[i];
                    if(undefined === oData[key])
                    {
                        continue;
                    }

                    var sVarType = typeof(oData[key]);
                    if(("string" == sVarType) || ("number" == sVarType))
                    {
                        oNewData[key] = oData[key];
                    }
                    if("object" == sVarType)
                    {
                        arguments.callee(oNewData, oData[key], aFields);
                    }
                }
            }
            return oNewData;
        }

        ,parseStyle: function(sStyle)
        {
            var oStyle = {};
            var aStyle = (sStyle||"").split(';');
            for(var i=0,k=aStyle.length; i<k; i++)
            {
                var s = $.trim(aStyle[i]);
                if(s)
                {
                    var aTemp = aStyle[i].split(':');
                    var sKey = $.trim(aTemp[0]).toLowerCase();
                    var sVal = $.trim(aTemp[1]).toLowerCase();
                    oStyle[sKey] = sVal;
                }
            }
            return oStyle;
        }

        /*****************************************************************************
         @FuncName: public, Frame.Util.updateHtml
         @DateCreated: 2013-10-12
         @Author: Huangdongxiao 02807
         @Description: Update the HTML page whith the new value, which is the properties in the object "oData".
         <b>Notice:</b> The HTML elements must have proterty "id", and the "id" is equal one of the property
         in "oData". if no property is matched, skip it.
         @Usage:
         // HTML
         <div id="MyDiv">
         <span id="p1"></span>
         <span id="p2"></span>
         <span id="a1"></span>
         <span id="a2"></span>
         </div>

         // JS
         var oData = {p1:1,p2:2,a1:"aa",a2:"bb"};
         Frame.Util.updateHtml($("#MyDiv"), oData);

         // only update "p1", "p2"
         Frame.Util.updateHtml($("#MyDiv"), oData, "p1,p2");
         @ParaIn:
         * jScope, JObject, A JQuery object. eg: $("#MyEle");
         * oData, Object, a simple object. all the properties are simple type.
         * properties, String/Array, Optional. The properties for updating, it must be in oData.
         @Return: None
         @Caution:
         @Modification:
         * yyyy-mm-dd: Auth, add or modify something
         *****************************************************************************/
        ,updateHtml: function(jScope, oData, properties)
        {
            if(properties)
            {
                var aFields = ("string"==typeof(properties)) ? properties.split(",") : properties;
                for(var i=0,k=aFields.length; i<k; i++)
                {
                    var key = aFields[i];
                    if(undefined === oData[key])
                    {
                        continue;
                    }
                    $("#"+key, jScope).html(oData[key]);
                }
                return;
            }

            for(var key in oData)
            {
                $("#"+key, jScope).html(oData[key]);
            }
        }

/*****************************************************************************
@FuncName: public, Frame.Util.updateSelect
@DateCreated: 2013-07-04
@Author: Huangdongxiao 02807
@Description: 根据数组填充select下拉框
@Usage:
@ParaIn:
    * sSelectId, String, select下拉框的id
    * aData, Array, 数据数组，其元素为字符串类型.
@Return: void
@Caution:
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
,updateSelect: function(sSelectId, aData)
{
    var aOptions = [];
    var aData = (this.VPN || {VPN:[]}).VPN;
    for(var i=0; i<aData.length; i++)
    {
        aOptions.push(aData.Name);
    }
    $("#"+sSelectId).html("<option>"+aOptions.join("</option><option>")+"</option>");
}

/*****************************************************************************
@FuncName: public, Frame.Util.checkReboot
@DateCreated: 2014-09-17
@Author: Huangdongxiao 02807
@Description: 设备重启后检查是否重启完成。在调用本函数前建议先调用 Frame.keepAlive.pause()
    暂停框架的自动探测，重启完成后再调用 Frame.keepAlive.start() 恢复框架的自动探测。
    注意：自动探测的方法是定时向设备发送请求，如果能收到回应就说明重启完成。
    因此在调用本函数前必须保证设备已经开始重启了
@Usage:
    Frame.keepAlive.pause();
    Frame.Util.checkReboot(function(){
        alert("The device is ready, relogin please.");
        Utils.Base.redirect("/");
    })
@ParaIn:
    * opt, void, 可以是一个函数或者一个Object参数。
        当是Object时，可以有onRebootEnd, interval两个属性；
        当是函数时，与opt.onRebootEnd相同。
    * opt.onRebootEnd, Function, 重启完成后的处理函数
    * opt.interval, Integer, 探测时间间隔，单位：秒。默认时间为20秒
@Return: void
@Caution:
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
,checkReboot: function (opt)
{
    var k = 0;

            if ($.isFunction(opt))
            {
                opt = {onRebootEnd: opt};
            }
            opt = $.extend({interval: 20}, opt);

            function _sendRequest()
            {
                k++;
                $.ajax({
                    url: "/",
                    data: {sn: k},
                    success: function (oInfo)
                    {
                        opt.onRebootEnd && opt.onRebootEnd();
                    },
                    error: function ()
                    {
                        setTimeout(_sendRequest, opt.interval * 1000);
                    }
                });
            }

    _sendRequest();
}
/*
* window.open("url","name","parameters")
*   parameters 为窗口参数(各参数用逗号分隔)
* */
,openpage :function(opt){
        var option = {
            "pageURL":"",// 为子窗口路径
            "name":opt.name?opt.name:"_blank",// 弹出窗口的名字
            "height":"800px",// | pixel value | 窗口高度
            "Width":"1300px",// | pixel value | 窗口的像素宽度
            "screenX":"100px",// | pixel value | 窗口距屏幕左边界的像素长度
            "screenY":"100px",// | pixel value | 窗口距屏幕上边界的像素长度
            "hotkeys":"",// | yes/no | 在没菜单栏的窗口中设安全退出热键
            "innerHeight":"",// | pixel value | 窗口中文档的像素高度
            "innerWidth":"",// | pixel value | 窗口中文档的像素宽
            "location":"",// | yes/no | 位置栏是否可见
            "menubar":"",// | yes/no | 菜单栏是否可见
            "outerHeight":"",// | pixel value | 设定窗口(包括装饰边框)的像素高度
            "outerWidth":"",// | pixel value | 设定窗口(包括装饰边框)的像素宽度
            "resizable":"",// | yes/no | 窗口大小是否可调整
            "scrollbars":"yes",// | yes/no | 窗口是否可有滚动栏
            "titlebar":"yes",// | yes/no | 窗口题目栏是否可见
            "toolbar":"yes",// | yes/no | 窗口工具栏是否可见
            "z-look":"no",// | yes/no | 窗口被激活后是否浮在其它窗口之上
            "alwaysLowered":"no",// | yes/no | 指定窗口隐藏在所有窗口之后
            "alwaysRaised":"no",// | yes/no | 指定窗口悬浮在所有窗口之上
            "depended":"no",// | yes/no | 是否和父窗口同时关闭
            "directories":"no"// | yes/no | Nav2和3的目录栏是否可见
    }
     option = $.extend(option,opt);
      var parameters = "";
      $.each(option,function(key,value){
          if(key == "pageURL" || key == "name" ){
             return
          }
          if(value !=""){
             parameters +=key+"="+value+","
          }
      })
      window.open(option.pageURL,option.name,parameters);
}

} //// end of Util
   /* /!**
     *  jQuery 扩展方法
     *
     *      $.Object.count( p )
     *          获取一个对象的长度，需要指定上下文，通过 call/apply 调用
     *          示例: $.Object.count.call( obj, true );
     *          @param  {p}             是否跳过 null / undefined / 空值
     *
     *!/
    $.extend({
        //  获取对象的长度，需要指定上下文 this
        Object:{
            count: function( p ) {
                p = p || false;

                return $.map( this, function(o) {
                    if( !p ) return o;

                    return true;
                } ).length;
            }
        }
    });*/

    $F.Util = Util;
    var DataFormat = {
        /*
         * @params data new Data()
         * @params value计算几天前的数据
         * @params operate true false true表示为+ false表示需要-
         * @return 2015-11-11类型字符串
         */
        toYearString:function(data,value,operate){
            var nYear = data.getFullYear();
            var nMonth = data.getMonth()+1;
            var endDay = "";
            if(operate){
                endDay = value?data.getDate()+value:data.getDate();
            }else{
                endDay = value?data.getDate()-value:data.getDate();
            }
            return nYear+"-"+nMonth+"-"+endDay;
        },
        /*
         *return 2015-11-11 hh:mm:ss类型字符串
         * */
        toSecondsString:function(data,value){
            var nYear = data.getFullYear();
            var nMonth = data.getMonth()+1;
            var endDay = data.getDate();
            var currHours= data.getHours();
            if(value){
                if(currHours>value){
                    currHours =data.getHours()-value;
                }else{
                    currHours =23+data.getHours()-value;
                    endDay=endDay-1;
                }
            }
            var min = data.getMinutes();
            var seconds = data.getSeconds()
            return nYear+"-"+nMonth+"-"+endDay+" "+currHours+":"+min+":"+seconds;
        },
        /*
         *@paramsdata 2015-11-11 hh:mm:ss类型字符串
         * */
        getNineMiloSeconds:function(data){
            return new Date(data).getTime();
        },
        getHourSeconds:function(data,value){
            var formatDate= new Date(data);
            var nYear = formatDate.getFullYear();
            var nMonth = formatDate.getMonth()+1;
            var endDay = formatDate.getDate();
            var currHours= formatDate.getHours();
            if(value){
                if(currHours>value){
                    currHours =currHours-value;
                }else{
                    currHours =23+currHours-value;
                    endDay=endDay-1;
                }
            }
            var hoursStr =nYear+"-"+nMonth+"-"+endDay+" "+currHours+":00:00";
            return new Date(hoursStr).getTime();
        },
        getHour:function(data,value){
            var formatDate= new Date(data);
            var nYear = formatDate.getFullYear();
            var nMonth = formatDate.getMonth();
            var endDay = formatDate.getDate();
            var currHours= formatDate.getHours();
            if(value){
                if(currHours>value){
                    currHours =data.getHours()-value;
                }else{
                    currHours =23+currHours-value;
                    endDay=endDay-1;
                }
            }

            return nYear+"-"+nMonth+"-"+endDay+" "+currHours;;
        },
        /*
         * params data new Data()
         * return yyyymmddHHMMSSmins返回年月日时分秒毫秒
         * */
        getStringTime:function(data){
            var nYear = data.getFullYear();
            var nMonth = data.getMonth()+1;
            if(nMonth<10){
                nMonth ="0"+nMonth;
            }
            var endDay = data.getDate();
            if(endDay<10){
                endDay ="0"+endDay;
            }
            var currHours= data.getHours();
            if(currHours<10){
                currHours ="0"+currHours;
            }
            var min = data.getMinutes();
            if(min<10){
                min ="0"+min;
            }
            var seconds = data.getSeconds();
            if(seconds<10){
                seconds ="0"+seconds;
            }
            var minSeconds = data.getMilliseconds();
            if(minSeconds<10){
                minSeconds = "00"+minSeconds;
            }else if(minSeconds<100){
                minSeconds = "0"+minSeconds;
            }
            return nYear+""+nMonth+endDay+currHours+min+seconds+minSeconds;
        }
    };
    $F.DataFormat = DataFormat;
    function coord(el,prop)
    {
        var c = el[prop], b = document.body;

        while ((el = el.offsetParent) && (el != b))
        {
            c += el[prop];
        }

        return c;
    }

    var UI = {

        /*Frame.UI.coord*/
        coord: function (el)
        {
            var x = el["offsetLeft"]+$(el).outerWidth(),
                y = el["offsetTop"] + el.offsetHeight,
                b = document.body;

            while ((el = el.offsetParent) && (el != b))
            {
                x += el["offsetLeft"];
                y += el["offsetTop"];
            }

            return {x:x, y:y};
        },

        /*Frame.UI.popBox*/
        popBox: function(jEle, sMsg)
        {
            var jBox = $("#_popbox_div");
            if(jBox.length == 0)
            {
                $("body").append("<div id='_popbox_div'></div>");
                jBox = $("#_popbox_div");
                //$("body").click(function(){jBox.hide()});
            }

            var el = jEle.get()[0];
            var cx=coord(el,'offsetLeft');
            var cy=coord(el,'offsetTop') + el.offsetHeight;
            jBox.removeClass().addClass("pop-box").removeAttr("style").css({position:"absolute", left:cx, top:cy}).html(sMsg);
            return jBox;
        }

    }
    $F.UI = UI;

// Defination of IP Protocol
    var IpProtocol =
    {
        getStr: function(nProtocalType)
        {
            var aPrtl = {"6":"TCP", "17":"UDP"};
            return aPrtl[nProtocalType] || nProtocalType;
        },
        ICMP: 1,    TCP: 7,     UDP: 16, ICMP6: 58
    }
    $F.IpProtocol = IpProtocol;

    var MyScreen =
    {
        _hLock: false,
        getWidth: function ()
        {

        },
        getHeight: function ()
        {
            //
        },
        lock: function ()
        {
            //
            if(!MyScreen._hLock)
            {
                MyScreen._hLock = $('<div class="modal-backdrop in" style="z-index: 1030;"></div>').appendTo("body");
            }
        },
        unlock: function ()
        {
            //
            if(MyScreen._hLock)
            {
                MyScreen._hLock.remove();
                MyScreen._hLock = false;
            }
        }
    }
    $F.MyScreen = MyScreen;

})(Frame);
/*******************************************************************************
 Copyright (c) 2007, Hangzhou H3C Technologies Co., Ltd. All rights reserved.
--------------------------------------------------------------------------------
@FileName:libs/frame/dialog.js
@ProjectCode: Comware v7
@ModuleName: Frame.Dialog
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: 
    �Ի��������ؽӿ�,����FORM, �򵼺���ʾ��Ϣ����ʾ, �Ͱ�ť��disable/enable.
    �ṩ������:
    Frame.Dialog
    Frame.Msg
    Frame.Button
@Modification:
*******************************************************************************/

;(function($F)
{

/*****************************************************************************
@typedef: DialogOption
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ��ʾ�Ի���ʱ�����ݸ��Ի����Ĳ���
@fields:
* title - string, �Ի������⣬Ĭ�ϱ���Ϊ��MessageBox��
* width - integer,�Ի����Ŀ��ȣ�Ĭ�Ͽ���Ϊ400, ������MyConfig�н�������
* height - integer,�Ի����ĸ߶ȣ�Ĭ�ϸ߶�Ϊ300, ������MyConfig�н�������
* resizable - boolean, �Ƿ����Ըı��Ի����Ĵ�С��Ĭ��ֵΪfalse
* html - string, �Ի�������ʾ��HTML�ַ�����
* buttons - string, �Ի�����ť, ȱʡû�а�ť��֧�ְ�ť�� 
    <a href="../../frame/cn/locale.js.html#JQuery.MyLocale.Buttons">MyLocale.Buttons</a>
    �ж���, ������ť��ʹ��"|"��������, ��"OK|CANCEL"
* beforeclose - Function, �رնԻ���ǰ�ļ��麯���������ڸú��������ر�ǰ�Ĵ���
    <li>����ԭ�ͣ�boolean function onBeforeClose(sButton)
    <li>������sButton, String, ��buttons������ָ���İ�ť���ƣ���OK, Cancel
    <li>����ֵ��true - �����رնԻ��򣻷����������رնԻ���;
* onClosed - Function, �رնԻ��������á�����beforeclose������true�����������ú������رպ��Ĵ���
* closeOnEscape - boolean, �Ƿ�����ESC���رնԻ�����Ĭ��ֵΪtrue;
@Modification:
    * yyyy-mm-dd: Author, add or modify something
    * 2011-07-27: �ƶ���, ����closeOnEscape����
*******************************************************************************/
var DialogOption =
{
    title: "Dialog",
    //width: MyConfig.Dialog.DEFAULT.width,
    height: MyConfig.Dialog.DEFAULT.height,
    resizable: false,
    html: "",
    buttons: "",
    closeOnEscape: true,
    modal: true,

    onClosed: $.noop,
    beforeclose: $.noop
};

var ButtonIcon = {
    ADD:    "add",
    DEL:    "del",
    MDF:    "jmdf",
    SEARCH: "search",
    INSERT: "insert",
    STOP:   "stop",
    UP:     "up",
    DOWN:   "down",
    OK:     "apply",
    CANCEL: "cancel",
    CLOSE:  "close",
    RESET:  "reset",
    PRE:    "prev",
    NEXT:   "next",
    FINISH: "finish",
    SELECTALL:"selall",
    SELECTNONE:"selnone"
}

/*****************************************************************************
@FuncName: private, _dialog
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ��ʾ�Ի���
@Usage: usage�п��������Ժ�����ʹ�õĴ�������������û�п��Բ�д
    var sId = "mydlg";
    oDlg = _dialog(sId, {
        title: "Form",
        resizable: true,
        width: 600,
        height: 480,
        buttons: "OK|CANCEL",
        html: "<form>Your name:<input id='yourname'></form>",
        beforeclose: function(){return true;}
    });
@ParaIn: 
    * sId - string, �Ի�����ҳ���е�ID��
    * option - DialogOption, �Ի�����ѡ�
@Return: Dialog����,�ڻص������п��Ե���close�رնԻ���.
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
function _dialog(sId, opt)
{
    var _sClickedButton = null;
    var _bClosed = false;

    if(Msg.disabled)
    {
        return "";
    }
    
    var optDlg = $.extend({}, DialogOption, opt, {
            beforeclose: function(evt, ui)
            {
                _bClosed = _onBeforeClose();
                return _bClosed;
            }
        });

    function _onBeforeClose()
    {
        // ����ȡ����ťʱ����ֱ�ӹر�
        if (("CANCEL"==_sClickedButton) || ("CLOSE"==_sClickedButton))
        {
            return true;
        }

        // �����߲����Ĺر�ǰ�Ĵ���
        if(!opt.beforeclose)
        {
            return true;
        }

        // ������ť�ɵ�����ȷ���Ƿ����Թر�
        return (false!=opt.beforeclose(_sClickedButton));
    }

    function _click_Button(oBtn, sClick)
    {
        _sClickedButton = sClick;
        var $modalId = $(oBtn).parents(".modal");
        $F.Debuger.info("dialog button click: " + _sClickedButton);

        if(sClick == "OK")
        {
            optDlg.beforeclose && optDlg.beforeclose();
            $modalId.modal("hide");
        }
        else if((sClick == "Cancel") || (sClick == "Close"))
        {
            $modalId.modal("hide");
            optDlg.afterclose && optDlg.afterclose();
        }
        return;
    }
    function _create_Modal()
    {
        var sBtn = (opt.closeHeaderBtn)?"":"<button type='button' class='close' aria-hidden='true'></button>";
        $("body").append("<div id="+sId+" class='modal hide fade modal-default'>"+
                "<div class='modal-header'>"+sBtn+
                    "<h3></h3>"+
    	        "</div>"+
    	        "<div class='modal-body row-fluid'>"+
                     "<div class='modal-wordbreak'></div>"+	        
    	        "</div>"+
            	"<div class='modal-footer form-actions'></div>"+
	        "</div>");
    }
    function _set_ModalData(jMsgContainer,optDlg)
    {
        //jMsgContainer.attr('data-width',optDlg.width);

        switch(optDlg.modal)
        {
            case 1:
            case "middle":
                jMsgContainer.addClass("modal-large");
                break;
            case 3:
            case "big":
                jMsgContainer.addClass("modal-super");
                break;
            case 2:
            case "small":
                jMsgContainer.addClass("modal-small");
                break;
            default:
                break;
        }
        var sHtml = optDlg.html.replace(/portlet(-body)?/g,"");
        jMsgContainer.find("h3").html(optDlg.title);
        jMsgContainer.find(".modal-body").find(".modal-wordbreak").html(sHtml);
        var jButtonContainer = jMsgContainer.find(".modal-footer");
        jButtonContainer.empty();
        var aButton = optDlg.buttons.split("|");
    
    	for(var i=0;i<aButton.length;i++)
        {
            if(-1 != aButton[i].indexOf("OK"))
            {
    	        jButtonContainer.append("<a id="+sId+"_dialog_"+"OK class='btn btn-primary' dlgtype='OK' data-dismiss='modal'>" +$.MyLocale.Buttons.YES+"</a>");
            }
            else if(-1 != aButton[i].indexOf("CANCEL"))
            {
    	        jButtonContainer.append("<a href='#' id="+sId+"_dialog_"+"Cancel class='btn' dlgtype='Cancel' data-dismiss='modal'>" +$.MyLocale.Buttons.NO+"</a>");
            }
            else if(-1 != aButton[i].indexOf("CLOSE"))
            {
    	        jButtonContainer.append("<a href='#' id="+sId+"_dialog_"+"Close class='btn btn-primary' dlgtype='Close' data-dismiss='modal'>" +$.MyLocale.Buttons.CLOSE+"</a>");
            }
        }
        $("a", jButtonContainer).on("click", function(){
            _click_Button(this, $(this).attr("dlgtype"));
            return false;
        });
        
        $(".modal-header button").on("click", function(){
            _click_Button(this, "Close");
            return false;
        });
    }
    
    var jMsgContainer = $("#"+sId);
    if(0 == jMsgContainer.length)
    {
       _create_Modal();  
    }
    jMsgContainer = $("#"+sId);
    _set_ModalData(jMsgContainer,optDlg);
    
    var oDlg = jMsgContainer.modal();
    return oDlg;
}

function _dialogcheck(sId, opt)
{
    var _sClickedButton = null;
    var _bClosed = false;

    if(Msg.disabled)
    {
        return "";
    }

    var optDlg = $.extend({}, DialogOption, opt, {
        beforeclose: function(evt, ui)
        {
            _bClosed = _onBeforeClose();
            return _bClosed;
        }
    });

    function _onBeforeClose()
    {
        // ����ȡ����ťʱ����ֱ�ӹر�
        if (("CANCEL"==_sClickedButton) || ("CLOSE"==_sClickedButton))
        {
            return true;
        }

        // �����߲����Ĺر�ǰ�Ĵ���
        if(!opt.beforeclose)
        {
            return true;
        }

        // ������ť�ɵ�����ȷ���Ƿ����Թر�
        return (false!=opt.beforeclose(_sClickedButton));
    }

    function _click_Button(oBtn, sClick)
    {
        _sClickedButton = sClick;
        var $modalId = $(oBtn).parents(".modal");
        $F.Debuger.info("dialog button click: " + _sClickedButton);

        if(sClick == "OK")
        {
            optDlg.beforeclose && optDlg.beforeclose();
            $modalId.modal("hide");
        }
        else if((sClick == "Cancel") || (sClick == "Close"))
        {
            $modalId.modal("hide");
            optDlg.afterclose && optDlg.afterclose();
        }
        return;
    }
    function _create_Modal()
    {
        var sBtn = (opt.closeHeaderBtn)?"":"<button type='button' class='close' aria-hidden='true'></button>";
        $("body").append("<div id="+sId+" class='modal hide fade modal-default'>"+
            "<div class='modal-header'>"+sBtn+
            "<h3></h3>"+
            "</div>"+
            "<div class='modal-body row-fluid'>"+
            "<div class='modal-wordbreak'></div>"+
            "<div style='margin-top:30px'>"+
            "<input type='checkbox' id='fileUpload' style='width:20px;height:20px;'>"+"</input>"+
            "<span style='padding-left:10px;font-size:12px;'>"+getRcText('fileupload')+"</span>"+
            "</div>"+
            "</div>"+
            "<div class='modal-footer form-actions'></div>"+
            "</div>");
    }
    function _set_ModalData(jMsgContainer,optDlg)
    {
        //jMsgContainer.attr('data-width',optDlg.width);

        switch(optDlg.modal)
        {
            case 1:
            case "middle":
                jMsgContainer.addClass("modal-large");
                break;
            case 3:
            case "big":
                jMsgContainer.addClass("modal-super");
                break;
            case 2:
            case "small":
                jMsgContainer.addClass("modal-small");
                break;
            default:
                break;
        }
        var sHtml = optDlg.html.replace(/portlet(-body)?/g,"");
        jMsgContainer.find("h3").html(optDlg.title);
        jMsgContainer.find(".modal-body").find(".modal-wordbreak").html(sHtml);
        var jButtonContainer = jMsgContainer.find(".modal-footer");
        jButtonContainer.empty();
        var aButton = optDlg.buttons.split("|");

        for(var i=0;i<aButton.length;i++)
        {
            if(-1 != aButton[i].indexOf("OK"))
            {
                jButtonContainer.append("<a id="+sId+"_dialog_"+"OK class='btn btn-primary' dlgtype='OK' data-dismiss='modal'>" +$.MyLocale.Buttons.YES+"</a>");
            }
            else if(-1 != aButton[i].indexOf("CANCEL"))
            {
                jButtonContainer.append("<a href='#' id="+sId+"_dialog_"+"Cancel class='btn' dlgtype='Cancel' data-dismiss='modal'>" +$.MyLocale.Buttons.NO+"</a>");
            }
            else if(-1 != aButton[i].indexOf("CLOSE"))
            {
                jButtonContainer.append("<a href='#' id="+sId+"_dialog_"+"Close class='btn btn-primary' dlgtype='Close' data-dismiss='modal'>" +$.MyLocale.Buttons.CLOSE+"</a>");
            }
        }
        $("a", jButtonContainer).on("click", function(){
            _click_Button(this, $(this).attr("dlgtype"));
            return false;
        });

        $(".modal-header button").on("click", function(){
            _click_Button(this, "Close");
            return false;
        });
    }

    var jMsgContainer = $("#"+sId);
    if(0 == jMsgContainer.length)
    {
        _create_Modal();
    }
    jMsgContainer = $("#"+sId);
    _set_ModalData(jMsgContainer,optDlg);

    var oDlg = jMsgContainer.modal();
    return oDlg;
}

   function getRcText(sRcId){
       return Utils.Base.getRcString("change_password_rc",sRcId);
   }

   function getRcString(sRcId,sRcName){
       return $("#"+sRcId).attr(sRcName);
   }

var Msg = 
{
    NAME: "MSG",
    disabled: false, /* ������Ϊtrueʱ���е���ʾ��Ϣ������ʾ */
    
/*****************************************************************************
@FuncName: public, Frame.Msg.info
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ��ҳ�����ʵ���λ����ʾһ����ʾ��Ϣ, ������2���Ӻ��Զ���ʧ. һ�������·��ɹ�����ʾ�ɹ�����ʾ��Ϣ
    ʧ�ܵ���ʾ��Ϣ������Ҫ��֤�û��϶����Կ���, ���˲��øú�����ʾ
<div><img src="../../images/msg.info.jpg"></div>
һ�������£��·��ɹ������ܻ��Զ���ʾ����ʾ��Ϣ�����ø�ҳ���Լ�����
@Usage: 
    function onMySubmit(oForm)
    {
        // check ...
        
        // submit ...
        
        Frame.Msg.wait("�������� ...");
    }
    
    function submitSuccess()
    {
        // todo: processing after submit
        // ......
        
        // show success information
        Frame.Msg.info("���óɹ�");
    }
@ParaIn: 
    * sMsg, string, ��ʾ��Ϣ�ַ�����
    * sType, String, ��ʾ��������. ������"ok", "info", "error". default is "ok"
@Return: ��.
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    info: function(sMsg, sType)
    {
        var sId="frame_msg_info";

        if(MyConfig.Dialog.INFO.useDlg)
        {
            var oDlg = _dialog(sId, {
                    height: 100,
                    html:sMsg
                });
            oDlg.siblings(".ui-dialog-titlebar").children(".ui-dialog-titlebar-close").hide();

            Frame.Timer.create("Frame.Msg.info",function()
            {
               oDlg.close();
            }, MyConfig.Dialog.INFO.visibleTime);
            return sId;
        }

        var iFadetime=400;

        var jInfo = $("#" + sId);
        if (0 == jInfo.length)
        {
            jInfo = $("<div id="+sId+" style='display:none;'></div>");
            $("body").append(jInfo);
        }

        sType = sType||"ok";
        sMsg = "<div class='msg-"+sType+"'></div>"+sMsg;
        jInfo
            .attr ("class", "msg-box msg-"+sType)
            .html (sMsg)
            .fadeIn (iFadetime);
        
        Frame.Timer.create("Frame.Msg.info",function()
        {
            $("#"+sId).fadeOut();
        },MyConfig.Dialog.INFO.visibleTime);
    },

/*****************************************************************************
@FuncName: public, Frame.Msg.wait
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ��ҳ������ʾһ���ȴ��Ի����ȴ�ҳ��ִ��ĳһ����, ���������ɺ���ҳ��
�󶯷���"close"�¼��رոöԻ���. �Ի�����û�йر�ͼ��,û��ȷ����ȡ���Ȱ�ť, 
�û������ֶ��رնԻ���.
<div><img src="../../images/msg.wait.jpg"></div>
<div class=notice>֧�ֵ��¼��б�</div>
<li>close - �رնԻ���
<li>change - �ı��Ի����е���ʾ��Ϣ, ����Ϊ{msg: "your message in dialog"}
@Usage: 
    var hWait = false;
    function onMySubmit(oForm)
    {
        // todo: check your input
        
        // do submit
        
        // show wait information
        hWait = Frame.Msg.wait("������������...");
    }
    
    function onSubmitEnd()
    {
        // close the wait window
        Frame.notify(hWait, "close");
    }

    // �ȴ������н��ȱ仯��ʾ.
    function changeMsg()
    {
        var k = 1;
        var hTimer = setInterval(function()
        {
            Frame.notify(hWait, "change", {msg:k+" seconds passed."});
            k++;
            if(k>=10)
            {
                clearInterval(hTimer);
            }
        }, 1000);
    }
    changeMsg();
@ParaIn: 
    * sMsg - string, �ȴ���Ϣ�ַ�����
@Return: �Ի���ID, ���������ɺ�ҳ����������ID����close�¼��ԹرնԻ���.
@Caution: 
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
    wait: function(para)
    {
        var oPara = $.isPlainObject(para) ? para : {msg: para};

        // ����һ��Ψһ��ID
        var sDlgId = "frame_msg_wait";
        var sString = '<span><div class="wait loading-small"></div><span>'+oPara.msg+'</span></span>';
        var oDlg = _dialog(sDlgId, {
                height: 130,
                title: oPara.title || $.MyLocale.WAITING, 
                html:sString, 
                closeHeaderBtn:true,
                closeOnEscape: false
            });
        oDlg.siblings(".ui-dialog-titlebar").children(".ui-dialog-titlebar-close").hide();

        return {
            hWait: sDlgId, 
            close: function(){$("#"+sDlgId).modal("hide");},
            change: function(){$("#"+sDlgId+" .msg").html(oPara.msg);}
        };
    },

/*****************************************************************************
@FuncName: public, Frame.Msg.alert
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ��ʾ��ʾ��Ϣ�Ի���, ��window.alert��һ����չ. �Ե����Ի�������ʽ��ʾһ����ʾ��Ϣ. 
    �ýӿڲ���������, ���˵���ȷ��������ִ�еĴ�����Ҫ��װ��һ��������, ��Ϊcb��������.
<div><img src="../../images/msg.alert.jpg"></div>
@Usage: 
    Frame.Msg.alert("�ļ��Ѿ��ϴ�����", function()
    {
        Frame.Debuger.log("�Ի����ѹر�");
    });
@ParaIn: 
    * sMsg - string, ��ʾ��Ϣ�ַ�����
    * cb - function, ����ȷ�����Ļص�����, ����û�С�
@Return: ��.
@Caution: ��ʾ��Ϣ�Ի���������JS����ִ��.
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
    alert: function(sMsg, cb)
    {
        var oPara = $.isPlainObject(sMsg) ? sMsg : {msg: sMsg, cb: cb};

        var opt = $.extend({
            title: oPara.title || $.MyLocale.ALERT_TITLE, 
            html:oPara.msg, 
            buttons:"CLOSE", 
            beforeclose:oPara.cb
        }, MyConfig.Dialog.ALERT);
        _dialog("frame_msg_alert", opt);
    },

/*****************************************************************************
@FuncName: public, Frame.Msg.error
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ��ʾ������ʾ�Ի���, ��window.alert��һ����չ
<div><img src="../../images/msg.error.jpg"></div>
@Usage: 
    Frame.Msg.error("������");
@ParaIn: 
    * sMsg - string, ������Ϣ�ַ�����
    * cb - function, ����ȷ�����Ļص�����, ����û�С�
@Return: ��.
@Caution: ������ʾ�Ի���������JS����ִ��.
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
    error:function(sMsg, cb)
    {
        var opt = $.extend({
            title:$.MyLocale.ERROR_TITLE, 
            html:sMsg, 
            buttons:"CLOSE", 
            afterclose:cb
        }, MyConfig.Dialog.ERROR);

        _dialog("frame_msg_error", opt);
    },

/*****************************************************************************
@FuncName: public, Frame.Msg.merror
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ��ʾ������������ʾ�Ի���. ���������һ��, 
    ��������<a href="srequest.js.html#Frame.SRequest.SRequestRoot.errorContinue">errorContinue</a>ѡ����,
    ���������˶�������, ����ʹ�øýӿ���ʾ������Ϣ. ��������Ϣ�϶�ʱ, �����ִ�ֱ������.
    �ýӿ�һ���ɿ�������ʾ����ʱ���ݴ�����Ϣ�Զ�����, ��ҳ��һ�㲻��Ҫ����.
<div><img src="../../images/msg.merror.jpg"></div>
@Usage: 
    // ƴ�����ַ���, �����ǿ���ʹ���ַ�����ʽ.
    var sMErr = "<div class='row'>���ýӿ�Eth0/1/1��Duplex���� <span class='error-reason'>��֧�ִ˲���</span></div>" 
        +"<div class='row'>���ýӿ�Eth0/1/2��Duplex���� <span class='error-reason'>��֧�ִ˲���</span></div>"
        +"<div class='row'>���ýӿ�Eth0/2/1��Duplex���� <span class='error-reason'>��֧�ִ˲���</span></div>"
        +"<div class='row'>���ýӿ�Eth0/2/2��Duplex���� <span class='error-reason'>��֧�ִ˲���</span></div>"
    Frame.Msg.error(sMErr);
@ParaIn: 
    * sMsg - string, ������Ϣ�ַ����������Ǵ��ı��ַ���, Ҳ������HTML�ַ���. ʹ��HTML�ַ���ʱ��Ҫ��֤HTML����Ч�Ժ���ȷ��.
    * cb - function, ����ȷ�����Ļص�����, ����û�С�
@Return: ��.
@Caution: ������ʾ�Ի���������JS����ִ��.
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
    merror:function(aMsg, cb)
    {
        var sMsg = '<div class="row">' + aMsg.join('</div><div class="row">') + '</div>';
        
        var opt = $.extend({
            title:$.MyLocale.ERROR_TITLE, 
            html:sMsg, 
            buttons:"CLOSE", 
            beforeclose:cb
        }, MyConfig.Dialog.ERROR);

        _dialog("frame_msg_merror", opt);
    },
    
/*****************************************************************************
@FuncName: public, Frame.Msg.confirm
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ��ʾȷ�϶Ի���, ����window.confirm
<div><img src="../../images/msg.confirm.jpg"></div>
@Usage: 
    Frame.Msg.confirm("ȷʵҪɾ��ѡ�е����е�����?", function()
    {
        // �û�ѡ����OK��ť
        // ...
    });
@ParaIn: 
    * sMsg - string, ��ʾ��Ϣ�ַ�����
    * cb - function, ����ȷ�����Ļص�����, ����û�С������û�����ȡ����ť, �򲻻����øûص�.
@Return: ��.
@Caution: ȷ�϶Ի���������JS����ִ��.
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
    confirm: function(sMsg, para)
    {
        var pfNoop = function(){}
        var pfOK = para;
        var pfCancel = pfNoop;
        var oPara = para;

        if(!$.isPlainObject(oPara))
        {
            oPara = {
                onOK: para||pfNoop,
                onCancel: pfNoop
            }
        }

        var opt = $.extend({
            title:$.MyLocale.CONFIRM_TITLE, 
            html:sMsg, 
            buttons:"OK|CANCEL", 
            beforeclose:oPara.onOK,
            afterclose:oPara.onCancel
        }, MyConfig.Dialog.CONFIRM);
        return _dialog(oPara.sId || "frame_msg_confirm", opt);
    },

    confirmcheck: function(sMsg, para)
    {
        var pfNoop = function(){}
        var pfOK = para;
        var pfCancel = pfNoop;
        var oPara = para;

        if(!$.isPlainObject(oPara))
        {
            oPara = {
                onOK: para||pfNoop,
                onCancel: pfNoop
            }
        }

        var opt = $.extend({
            title:$.MyLocale.CONFIRM_TITLE,
            html:sMsg,
            buttons:"OK|CANCEL",
            beforeclose:oPara.onOK,
            afterclose:oPara.onCancel
        }, MyConfig.Dialog.CONFIRM);
        return _dialogcheck(oPara.sId || "frame_msg_confirmcheck", opt);
    },


    warning: function(sMsg, cb)
    {
        var opt = $.extend({
            title:$.MyLocale.CONFIRM_TITLE, 
            html:sMsg, 
            buttons:"OK|CANCEL", 
            beforeclose:function(sClick){("OK"==sClick) && cb && cb();}
        }, MyConfig.Dialog.CONFIRM);
        return _dialog("frame_msg_warning", opt);
    },
    
/*****************************************************************************
@FuncName: public, Frame.Msg.prompt
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ��ʾһ�����������ĶԻ���, ����window.prompt��֧�ֿ��ܵ��������͵ĺϷ��Լ��顣�Ը��ӵļ��飬������cb�������Լ����ɡ�
<div><img src="../../images/msg.prompt.jpg"></div>
@Usage: 
    Frame.Msg.prompt("��������������", function(sVal)
    {
        // �û�������OK��ť
        Frame.Msg.alert("����"+sVal);
    },{def:"tester", type:"text"});
@ParaIn: 
    * sMsg - string, ��ʾ��Ϣ�ַ�����
    * cb - function, ����ȷ�����Ļص�����, ����û�С������û�����ȡ����ť, �򲻻����øûص�.
    * opt, Object, �û�ѡ�֧������ѡ�
        <li>defaultVal, ȱʡֵ�����ڶԻ�����ʾ�ĳ�ʼֵ���������ַ�����Ҳ����������
        <li>ctype, ���������ͣ�������password��file����<a href="form.js.html#input_check_type">FORM֧�ֵļ�������</a>
        <li>requred, boolean, �Ƿ���������
@Return: ��.
@Caution: ȷ�϶Ի���������JS����ִ��.
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
    prompt: function(sMsg, cb, opt)
    {
        var settings = {
            defaultVal: "",
            ctype: "text",
            required: false,
            cls: "width_small"
        };
        opt && $.extend(settings, opt);
        
        var dlgOpt = $.extend({
            title: opt.title||$.MyLocale.PROMPT_TITLE, 
            html: '<div class="description"></div>'+Frame.Form.createEle(settings),
            buttons:"OK|CANCEL", 
            beforeclose: function(sClick){return ("OK"==sClick) ? onOK() : true;}
        }, MyConfig.Dialog.PROMPT);

        var oDlg = _dialog("frame_msg_prompt", dlgOpt);
        oDlg.find(".description").html(sMsg)
            .next().keyup(function(e){(13==e.keyCode) && (true===onOK()) && oDlg.close()});
        return oDlg;
        
        function onOK()
        {
            // û��ָ��CB���������سɹ�
            if(!cb) return true;
            
            var jInput = oDlg.find("input");
            if(!Frame.Form.checkEle(jInput))
            {
                // ���ܼ��鲻ͨ��
                return false;
            }
            
            return cb(jInput);
        }
    }
} //// end of Frame.Msg
$F.Msg = Msg;

function _parseTitle(sHtml)
{
    return sHtml.replace(/[\w\W]*<title>([\w\s\W]*)<\/title>[\w\W]*/,"$1");
}

function _checkChange()
{
    //return "Changed, do you continue?";
    return null;
}

var Button = {
    NAME: "Frame.Button",
    
/*****************************************************************************
@FuncName: public, Frame.Button.Mode
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ��ťģʽ. �ڴ�����ťʱ����ʹ�ø�ģʽ�ڶ����õ������Լ򻯴����ͱ�֤��ҳ����ͳһ.
    ֧�ֵİ�ťģʽ���£�
    <table class="para_list">
    <tr><td>INFO</td><td>��ʾ��Ϣ��ťģʽ</td></tr>
    <tr><td>ALERT</td><td>alert������ʾ��Ϣģʽ</td></tr>
    <tr><td>CONFIRM</td><td>ȷ�϶Ի�����ťģʽ</td></tr>
    <tr><td>CLOSE</td><td>�رնԻ�����ťģʽ</td></tr>
    <tr><td>CREATE</td><td>���򴴽��Ի����İ�ťģʽ</td></tr>
    <tr><td>MODIFY</td><td>�����޸ĶԻ����İ�ťģʽ</td></tr>
    <tr><td>DELETE</td><td>����ɾ��ȷ�϶Ի����İ�ťģʽ</td></tr>
    <tr><td>WIZARD</td><td>�����򵼶Ի����İ�ťģʽ</td></tr>
    </table>
@Usage: 
    // ����һ�򴴽���ť
    $( "#addr_create" ).button(Frame.Button.Mode.CREATE);
    
    // ����һ���޸İ�ť
    $( "#addr_modify" ).button(Frame.Button.Mode.MODIFY);
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
    Mode:
    {
        INFO:
        {
            icons: {
                primary: "fa"
            }
        },
        OPEN:
        {
            icons: {
                primary: "fa fa-columns"
            }
        },
        COPY:
        {
            icons: {
                primary: "fa fa-copy"
            }
        }, 
        FILTER:
        {
            icons: {
                primary: "fa fa-filter"
            }
        },
        ALERT:
        {
            icons: {
                primary: "fa fa-alert"
            }
        },
        WARNING:
        {
            icons: {
                primary: "fa fa-close"
            }
        },
        CONFIRM:
        {
            icons: {
                primary: "fa fa-help"
            }
        },
        CLOSE:
        {
            icons: {
                primary: "fa fa-close"
            }
        },
        EXPAND:
        {
            icons: {
                secondary: "fa fa-default"
            }
        },
        COLLASE:
        {
            icons: {
                secondary: "fa fa-default"
            }
        },
        MENU:
        {
            icons: {
                secondary: "fa fa-default"
            }
        },
        CREATE:
        {
            icons: {
                primary: "fa fa-plus"
                //,secondary: "icon-triangle-1-s"
            }
        },
        MODIFY:
        {
            icons: {
                primary: "fa fa-pencil"
                //,secondary: "icon-triangle-1-s"
            }
        },
        DELETE:
        {
            icons: {
                primary: "fa fa-trash-o"
                //,secondary: "icon-closethick"
            }
        },
        SEARCH:
        {
            icons: {
                primary: "fa fa-search"
            }
        },
        RESET:
        {
            icons: {
                primary: "fa fa-default"
            }
        },
        FIX:
        {
            icons: {
                primary: "fa fa-thumb-tack"
            }
        },
        CHART:
        {
            icons: {
                primary: "fa fa-bar-chart-o"
            }
        }, 
        SCAN:
        {
            icons: {
                primary: "fa fa-default"
            }
        }, 
        CLEAR:
        {
            icons: {
                primary: "fa fa-remove"
            }
        }, 
        UPDATE:
        {
            icons: {
                primary: "fa fa-refresh"
            }
        },
        MOVE:
        {
            icons: {
                primary: "fa fa-arrows"
            }
        },
        WIZARD:
        {
            icons: {
                primary: "fa fa-wrench"
            }
        },
        UPLOAD:
        {
            icons: {
                primary: "fa fa-arrow-circle-o-up"
            }
        },
        DOWNLOAD:
        {
            icons: {
                primary: "fa fa-arrow-circle-o-down"
            }
        },
        FLAG:
        {
            icons: {
                primary: "fa fa-flag"
            }
        },
        START:
        {
            icons: {
                primary: "fa fa-play"
            }
        },
        STOP:
        {
            icons: {
                primary: "fa fa-stop"
            }
        },
        DISABLE:
        {
            icons: {
                primary: "fa fa-ban"
            }
        },
        ENABLE:
        {
            icons: {
                primary: "fa fa-check"
            }
        },
        REFRESH:
        {
            icons: {
                primary: "fa fa-refresh"
            }
        },
        PANEL:
        {
            icons: {
                primary: "fa fa-tasks"
            }
        },
        DEFAULT:
        {
            icons: {
                primary: "fa fa-default"
            }
        }
    },

/*****************************************************************************
@FuncName: public, Frame.Button.create
@DateCreated: 2012-06-24
@Author: huangdongxiao 02807
@Description: ������ť����ҳ����ʹ��input@type=button������button��ǩʱ��������ʹ��Ĭ�ϵİ�ť���ۡ�
    �ýӿڿ���Ϊ��ť����ͳһ��CSS������ͳһ������ť�����á�ע���ýӿڲ�����ť���κ��¼�
    <p>ҳ���г��õİ�ť�����ܶ����ڳ�ʼ��ǰͳһ��������ҳ��ֻ��Ҫ����ҳ���������İ�ť���ɡ�
    �磺�����ļ����ݺ͵�����ť
@Usage: 
    // ��my_form�����е�BUTTON��ťͳһ����
    Frame.Button.create("#my_form button");
@ParaIn: 
    * sSelector - string, jqueryѡ�����ַ�����
    * mode, #Frame.Button.Mode, ��ťģʽ�����Բ�ָ��
@Return: ��.
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
    create: function(sSelector, mode)
    {
        $( sSelector).button(mode);
    },

    onApply: function()
    {
        var sFormId = $(this).attr("form");
        if(!sFormId)
        {
            return false;
        }
    
        $("#"+sFormId).submit();
        return false;
    },

    onCancel: function()
    {
        Frame.getHelpPanel().close();
        return false;
    },

/*****************************************************************************
@FuncName: public, Frame.Button.disable
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ������ֹ��ť
@Usage: 
    // ��ֹmy_form�����е�INPUT
    Frame.Button.disable("#my_form input");
@ParaIn: 
    * selector - string, jqueryѡ�����ַ�����������jButton������
@Return: ��.
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
    disable: function(selector)
    {
        var jButton = (typeof(selector)=="string") ? $(selector) : selector;
        jButton.button("disable").removeClass("ui-state-hover");
    },

/*****************************************************************************
@FuncName: public, Frame.Button.enable
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ����ʹ�ܰ�ť
@Usage: 
    // ʹ��my_form�����е�INPUT
    Frame.Button.enable("#my_form input");
@ParaIn: 
    * selector - string, jqueryѡ�����ַ�����������jButton������
@Return: ��.
@Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
    enable: function(selector)
    {
        var jButton = (typeof(selector)=="string") ? $(selector) : selector;

        jButton.button("enable");
    }
};
$F.Button = Button;

/*****************************************************************************
@typedef: FormDlgOption
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ��ʾһ��FORM��ʱ�����ݸ�Frame.Dialog.form�Ĳ���
@fields:
* title - string, �Ի������⣬������ָ������ʹ��ҳ���е�TITLE��ǩ��Ϊ�Ի����ı��⡣����ָ���˸ò��������Ա�����Ϊ׼��
* width - integer,�Ի����Ŀ��ȣ���ָ��ʱʹ��Ĭ�Ͽ���
* height - integer,�Ի����ĸ߶ȣ�����������һ�Ű�ť�ĸ߶ȡ���ָ��ʱʹ��Ĭ�ϸ߶�
* src - selector, �����öԻ����ĵ�����ť��HTMLԪ�ء����öԻ�������srcָ����Ԫ�ط�����
* html - string, �Ի�������ʾ��HTML�ַ�����
* url - string, �Ի�����ʾ��URL�����Ի�����ʾʱ����ָ����URL�л�ȡҳ�棬Ȼ����ʾ�ڶԻ����С�
    ����ָ����html���ԣ�������url���ԡ�URL��·���Ǵ�ģ������ʼ������Ҫ����
    <a href="util.js.html#Frame.Util.getPathUrl">Frame.Util.getPathUrl</a> ����ת�����磺"syslog/cn/setup.html"
* init - Function, ҳ���ĳ�ʼ����������ҳ��load���ɺ󣬿��ܻ�����init������ҳ���Լ����г�ʼ������
    ҳ�治����ʹ��BODY��onload�¼����г�ʼ����
* onSubmit - Function, ����ȷ�������ύ����һ���ڸú����ڽ���XCMP�·�������
    Ҳ������һЩ�ۺ��Եļ��顣����ֵ��Ϊboolean���ͣ�����false���رնԻ���; true, �رնԻ���

@Modification:
    * yyyy-mm-dd: Author, add or modify something
*******************************************************************************/
var FormDlgOption = 
{
    buttons: "OK|CANCEL",

    onInit: $.noop,
    onSubmit: $.noop,
    onClosed: $.noop
}

var Dialog = {
    
/*****************************************************************************
@FuncName: public, Frame.Dialog.dialog
@DateCreated: 2011-06-24
@Author: huangdongxiao 02807
@Description: ��ʾһ���Ի���
<div><img src="../../images/dialog.dialog.jpg"></div>
@Usage: 
    // ��ʾһ�������Ի���
    Frame.Dialog.dialog({title: "test", html: "Dialog test"});
@ParaIn: 
    * opt - FormDlgOption, ��������������html��url������һ����
@Return: ��.
@ Modification:
    * yyyy-mm-dd: Auth, add or modify something
*****************************************************************************/
    dialog: function(option)
    {
        var sId = "frame_dialog";

        var opt = {};
        if(typeof option == "string")
        {
            opt = {html: option};
        }
        $.extend(opt, FormDlgOption, {buttons:"CLOSE", onClosed:opt.onClosed}, option);
        
        function showPage(sHtml)
        {
            // show dialog
            var dlg = _dialog(sId, opt);
            
            opt.onInit();
            return dlg;
        }

        if(opt.html)
        {
            return showPage(opt.html);
        }

        if(opt.url)
        {
            var sUrl = Frame.Util.getPathUrl(opt.url);
            Frame.Debuger.info("Dialog load from "+sUrl);
            $("<div></div>").load(sUrl, false, showPage);
            return true;
        }

        return false;
    }//// end of dialog
} //// end of Dialog
$F.Dialog = Dialog;

var _alert = window.alert;
var _confirm = window.confirm;
window.alert = function(sMsg){_alert("Please use Frame.Msg.info/error/wait/alert\r\n\r\n"+sMsg);}
window.confirm = function(sMsg){return _confirm("Please use Frame.Msg.confirm\r\n\r\n"+sMsg);}
})(Frame);
/*******************************************************************************
 Copyright (c) 2011, Hangzhou H3C Technologies Co., Ltd. All rights reserved.
--------------------------------------------------------------------------------
@FileName:libs/frame/dbm.js
@ProjectCode: Comware v7
@ModuleName: Frame.DBM
@DateCreated: 2011-08-09
@Author: huangdongxiao 02807
@Description:
    �������ݴ洢����װ�������ݵĴ洢������������֧��HTML5��ʹ��HTML5�����ݴ洢���ܣ�
    ������֧����ʹ��cookie���棬��ʱ�����ô洢�����������󳤶ȵ����ơ�
@Modification:
*******************************************************************************/

;(function($F)
{


function isInclude(sOpt, sKey)
{
    var aOpt=sOpt.split("|");
    for(var i=0; i<aOpt.length; i++)
    {
        if(aOpt[i]==sKey)
        {
            return true;
        }
    }
   return false;
}

/*****************************************************************************
@typedef: DbmOption
@DateCreated: 2011-08-09
@Author: huangdongxiao 02807
@Description: DBM������������
@fields:
    * retentionDuration, integer, �ϻ�ʱ�䣬����Ϊ��λ��0��ʾ��Զ���ϻ�����Ĭ��ֵΪ0
    * persistFlag, string, �־û���־��ȡֵΪ"none" or "cfg"��Ĭ��ֵΪ"none".
    * openFlag, string, �Ժ��ַ�ʽ�������ݿ⣬������"read", "write" or "create"�����ϣ�
        ���Ϸ�ʽΪʹ�á�|��ƴ�������� "read|write|create"
    * version, void, ���ݿ��汾��Ϣ���������ݿ�ʱ���Ὣversion��¼Ϊ���ݿ����ԣ�
        ����ʱ�᷵�����������ݿ��İ汾��Ϣ���汾��Ϣ���ݵĽ����ɵ����߸�����
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*******************************************************************************/
var DbmOption = {
    retentionDuration: 0,
    persistFlag: "none",
    openFlag: "read|write|create",
    version: null
}

if(!window.localStorage)
{
    window.localStorage =
    {
        // ɾ�����еı��ش洢����
        clear: function()
        {
            Frame.Cookie.clear();
        },

        // ����һ������
        setItem: function(sKey, sValue)
        {
            var para = {};
            para[sKey] = sValue;
            Frame.Cookie.set(para, -1);
        },

        // ��ȡ������һ������
        getItem: function(sKey)
        {
            return Frame.Cookie.get(sKey);
        },

        // ɾ�����ش洢��һ������
        removeItem: function(sKey)
        {
            Frame.Cookie.del(sKey);
        }
    }
}

/*****************************************************************************
@FuncName: private, _Db_Data
@DateCreated: 2011-08-08
@Author: huangdongxiao 02807
@Description:  ���ݿ��ڲ��洢�ṹ
{
    db_1: // ���ݿ�����, ÿ����һ�����ݿ��ͻ���һ���ö���
    {
        attr:   // �����ݿ�������
        {
            flag:"read|write",
            retentionDuration: 100
        },
        keys: // �����ݿ���keys
        {
            key_1:  // ������һ��key, ����setʱ������һ��key
            {
                attr: // ��key������, �����¼�֪ͨ����, ����regNotifyʱ����һ��, ����deRegNotifyʱ��ɾ��һ��
                {
                    nofifyCb:[pf1, fp2, fp3]
                },
                value:"abc" // key��Ӧ��ֵ, ����setʱ���ı���ֵ. ��ֵ�������ɸ�ʹ����ȷ��, DBM�����н��ͺ�����
            },
            "cpu": // key 2 ...
            {
                // ...
            }
        }
    },
    db_2:
    {
        // ...
    }
};
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
var _DB_Data = {};

/*****************************************************************************
@FuncName: class, Frame.DBM
@DateCreated: 2011-08-15
@Author: huangdongxiao 02807
@Description: ��̨DBM��ǰ̨ʵ�֣�����ҳ���е����ݣ�����ʵ�����ݵ���ʱ�����������Ա��档
	Ӧ����ҳ�������ݵĹ����͸��Ի����ݵ������Ա��档���ݹ���ʱֻ�ڱ��ε�¼�ڼ���Ч��
@Usage: 
@Caution: 
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
var DBM =
{
    NAME: "frame.dbm",

/*****************************************************************************
@FuncName: private, Frame.DBM.init
@DateCreated: 2011-08-08
@Author: huangdongxiao 02807
@Description:  ��PC��װ�������Ե����ݿ⡣��ϵͳ����ʱ, ��Ҫ�������Ա���������װ�ص�ϵͳ��,�����ûָ��Ķ���.
    �ö�����ϵͳ��ʼ��ʱ���ã���ģ�鲻��Ҫ���ġ�
    <P>DBM������һ��ϵͳ�����ݿ� -- sys.frame.dbm���÷ֺŰѸ������Ա��������ݿ�����ƴ��һ���ַ��������ڸ����ݿ��У�
    ��¼������loadϵͳ���ݿ⣬Ȼ�������ҵ�ҳ���б��������ݿⲢһһ���ء�
@Usage:
Frame.DBM.init();
@ParaIn:None
@Return: None
@Caution:��δʵ�֡����ݵĻָ������ɸ�ģ����ģ����ʼ��ʱ�����ָ���
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    init: function()
    {
        var sSysDbm = window.localStorage.getItem("sys."+this.NAME);
        if(!sSysDbm)
        {
            // û�������Ա���������
            return;
        }

        var aCfg = sSysDbm.split(';');
        for(var i=0; i<aCfg.length; i++)
        {
            this.load(aCfg[i]);
        }
    },
    
/*****************************************************************************
@FuncName: public, Frame.DBM.load
@DateCreated: 2011-08-08
@Author: huangdongxiao 02807
@Description:  ��PC��װ��һ�������Ե����ݿ⡣�ɸ�ģ���ڳ�ʼ��ʱ���á�
    <p>��ĳһģ����Ҫ�����Ա�������ʱ����ʹ��persistFlag=cfg�ķ�ʽ����DBM, �������Ϻ���������close�ر�. 
    �ڹر�ʱ���������Ե����ݱ��浽PC��. ͬʱҲ����ϵͳ�ڴ��б���һ���Ա��ں����Ĳ����м���ʹ��. ���´ε�¼ʱ,
    ϵͳ�ڳ�ʼ���л����ñ��ӿڰ�PC�ϵ����ñ���������װ�ص�ϵͳ��, ��ģ���Ϳ��Լ���ʹ����.
    <p>�������ݿⱣ���ĸ�ʽΪ: ���ݳ���+key+"="+value����Ҫ����key=name, value=syslog��һ��ֵʱ���ȼ���syslog�ĳ���Ϊ6��
    ����ǰ���ĸ�ʽ, �����ַ���Ϊ: 6name=syslog�������ж���ʱ����������ƴ�������ɣ� ���������ַ��������������ݣ��ֱ���
    name, pagesize��info����JS��һ�����ֵĳ�����1��
    <div class=code>��6name=syslog2pagesize=3030info=this is a local info, Ҳ����������������</div>
@Usage:
Frame.DBM.load("Frame.MList");
@ParaIn:
    * sDbName, string, ��������
@Return: ���ݿ�������ʧ��ʱ����null�����򷵻���Ч�ľ�����
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    load: function(sDbName)
    {
        var sCfg = window.localStorage.getItem("dbm."+sDbName);
        if(sCfg)
        {
            // sCfg = "6name=syslog2pagesize=30"
            var hDb = this.open(sDbName, {openFlag: "create|write"});
            while(sCfg.length>0)
            {
                var nLen = parseInt(sCfg); // 6, length of "syslog"
                var n1 = (nLen+"").length; // 1, length of nLen
                var nEqStart = sCfg.indexOf('=');   // 5, start from '='
                var nValStart = nEqStart + 1;       // 6, start from "syslog"
                var key = sCfg.substring(n1, nEqStart); // "name"
                var val = sCfg.substring(nValStart, nValStart+nLen); // "syslog"

                this.set(hDb, key, val);
                
                sCfg = sCfg.substring(nValStart+nLen);
            }
            this.close(hDb);
        }
    },

/*****************************************************************************
@FuncName: public, Frame.DBM.open
@DateCreated: 2011-08-08
@Author: huangdongxiao 02807
@Description:  ����һ�����ݿ⡣���ݿ����Ʊ���Ψһ�����ܺ�����ģ���ظ�������ʹ��ģ������
@Usage:
    ////////////////////////////////////////////////////////////
    // ��1: �������ݿ�"system",������һ��sysname. sysnameΪ"h3c"
    var db = Frame.DBM.open("system", {openFlag: "create|write"});
    Frame.DBM.set(db, "sysname", "h3c");
    Frame.DBM.close("system");

    ////////////////////////////////////////////////////////////
    // ��2: ֻ����ʽ�������ݿ�, ����ȡ������sysname
    var db = Frame.DBM.open("system", {openFlag: "read"});
    var sName = Frame.DBM.get(db, "sysname");
    Frame.DBM.close("system");

    ////////////////////////////////////////////////////////////
    // ��3: ɾ��system���ݿ�
    Frame.DBM.open("system", opt);
@ParaIn:
    * sDbName, string, ��������. ֻ�����ַ����֡��»��ߺ͵�����
    * opt, DbmOption, �������ݿ���ѡ��
@Return: ���ݿ�������ʧ��ʱ����null�����򷵻���Ч�ľ�����
@Caution:<li>���ݿ����Ʊ���Ψһ�����ܺ�����ģ���ظ�������ʹ��ģ������
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    open: function(sDbName, opt)
    {
        var hDb = _DB_Data[sDbName];

        // create
        if((undefined == hDb) && isInclude(opt.openFlag, "create") )
        {
            _DB_Data[sDbName] = null;
            _DB_Data[sDbName] =  {name:sDbName, attr:{}, keys:{}};
            hDb = _DB_Data[sDbName];
    
            var nDuration = opt.retentionDuration;
            if(nDuration>0)
            {
                Frame.Timer.create("DBM."+sDbName,function(){_DB_Data[sDbName]=null;}, nDuration*1000);
            }
        }
        
        // open
        if(hDb)
        {
            $.extend(hDb.attr, {
                    bIsRead: isInclude(opt.openFlag, "read"),
                    bIsWrite: isInclude(opt.openFlag, "write")
                }, opt);
        }

        return hDb;
    },

/*****************************************************************************
@FuncName: public, Frame.DBM.close
@DateCreated: 2011-08-08
@Author: huangdongxiao 02807
@Description:  �ر����ݿ⡣
<UL>
    <li>ҵ��ģ�����ô˽ӿڹر�DB�����ͷ����ص���Դ��
    <li>DBM���������б�����DB���ݻ��������ڣ�����<br>
        1��ĳ�����̵���DBM_Deleteɾ��DB<br>
        2������������retentionDuration�����κν��̴򿪵�DB��retention duration���ں��Զ�ɾ����
</UL>
@Usage:
    Frame.DBM.close(sDbName, false);
@ParaIn:
    * db, string/object, ���ݿ�����,�������ݿ�����
    * flush, boolean, �ر�ʱ�Ƿ񱣴������Ե����ݡ������Ե�������ִ��setʱֻ�Ǳ��浽�������У�
        ���ر�ʱ�Ż���������ˢһ�»�������Ĭ��ֵΪtrue
@Return: boolean, ����û�б����ɹ�ʱ����false�����򷵻�true
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    close: function(db, bFlush/*=true*/)
    {
        var hDb = ("string"==typeof(db)) ? _DB_Data[db] : db;
        
        if((hDb.attr.persistFlag == "cfg") && (true===bFlush))
        {
            var sCfgValue = "";
            // save to local
            for(var key in hDb.keys)
            {
                var sValue = hDb.keys[key].value;
                if(null !== sValue)
                {
                    sValue = sValue+"";
                    sCfgValue += sValue.length + key+"="+sValue;  // ֵ�ĳ���+key+"="+value
                }
            }

            var sDbName = "dbm."+hDb.name;
            if("" == sCfgValue)
            {
                window.localStorage.removeItem (sDbName);
            }
            else
            {
                window.localStorage.setItem(sDbName, sCfgValue);
            }
        }
    },

/*****************************************************************************
@FuncName: public, Frame.DBM.del
@DateCreated: 2011-08-08
@Author: huangdongxiao 02807
@Description:  ɾ�����ݿ⡣ɾ�����ɺ󣬲����ٶԸ����ݿ����κβ�����
@Usage:
    Frame.DBM.del(sDbName);
@ParaIn:
    * sDbName, String/Object,  Openʱָ�����������ƻ����Ѿ��򿪵����ݿ�����
    * sKey, String, ��Ҫɾ�����ֶ����ƣ�������ָ����ɾ���������ݿ�.
@Return: boolean, �ɹ�ʱ����true�����򷵻�false
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    del: function(db, sKey)
    {
        var hDb = ("string"==typeof(db)) ? _DB_Data[db] : db;
        var sDbName = hDb.name;

        var bDelDb = (undefined == sKey);
        if(bDelDb)
        {
            // û��ָ���������ֶΣ�ɾ���������ݿ�
            //delete _DB_Data[sDbName];
            _DB_Data[sDbName] = null;
        }
        else
        {
            // ָ���˾������ֶΣ�ֻɾ�����ֶ�
            //delete _DB_Data[sDbName].keys[sKey];
            _DB_Data[sDbName].keys[sKey] = null;
        }

        return true;
    },

/*****************************************************************************
@FuncName: public, Frame.DBM.set
@DateCreated: 2011-08-09
@Author: huangdongxiao 02807
@Description:  �����ݿ��б���һ����ֵ������ָ����key�Ѵ��ڣ����򸲸ǲ�����
    �����������������Ӳ���������ֵΪnull������ɾ��������
@Usage:
    // ����һ���ַ���
    Frame.DBM.set(hDb, "interface", "Ethernet 1/0/1");

    // ����һ������
    var MyObj =
    {
        NAME: "MyObj 1.1";
        toString: function()
        {
            return this.NAME;
        }
    }
    Frame.DBM.set(hDb, "obj", MyObj);

    // ����һ������
    var aData = [1,3,5,6,9];
    Frame.DBM.set(hDb, "arr", aData);
@ParaIn:
    * hDb, HANDLE, ���ݿ����������������ݿ�ʱ�ķ���ֵ
    * sKey, string, ��Ҫ�����ļ�ֵ����. ֻ�����ַ����ֺ��»�������
    * value, void, ��Ҫ������ֵ�������ǲ�ͬ�����ͣ������ַ��������֡����顢�����ȣ�������Ҫ�������Ա��棬
        �����Ͳ��Ǽ������ͣ�����Ҫ��toString��������Ϊ�����ձ���ʱֻ�����ַ������б��档
        <p>�����ñ������������´ε�¼web���ܺ����Լ���ʹ�ã������������ǷǼ������͵���Ҫģ������ʽת����
@Return: boolean, �ɹ�ʱ����true, ���򷵻�false
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    set: function (hDb, sKey, value)
    {
        if(!hDb.attr.bIsWrite)
        {
            return false;
        }

        hDb.keys[sKey] = hDb.keys[sKey] || {};

        if(hDb.keys[sKey].value != value)
        {
            // ֵ�б仯, ֪ͨ���ĵ�ģ��
            var notifys = hDb.keys[sKey].notify || [];
            for(var i=0; i<notifys.length; i++)
            {
                notifys[i](value);
            }

            // ����DBM�еı�����ֵ
            hDb.keys[sKey].value = value;
        }
        return true;
    },

/*****************************************************************************
@FuncName: public, Frame.DBM.get
@DateCreated: 2011-08-09
@Author: huangdongxiao 02807
@Description:  ��ȡ���ݿ��б����ļ�ֵ��
@Usage:
    var hDb = Frame.DBM.open("mydb");
    Frame.DBM.set(hDb, "interface", "Ethernet 1/0/1");
    Frame.DBM.get(hDb, "interface", "none"); // return "Ethernet 1/0/1"
    Frame.DBM.get(hDb, "int", "none"); // return "none"
    Frame.DBM.get(hDb, "int"); // return false
@ParaIn:
    * hDb, HANDLE, ���ݿ����������������ݿ�ʱ�ķ���ֵ
    * sKey, string, ��ֵ����
    * def, void, getʧ��ʱ���ص�Ĭ��ֵ������û��û�иò���������ʧ��ʱ����false
@Return: void, �ɹ�ʱ����sKey��Ӧ������, ���򷵻�def����false
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    get: function (hDb, sKey, def)
    {
        var value;

        if(!hDb.attr.bIsRead)
        {
            return false;
        }
        
        (hDb.keys[sKey]) && (value =  hDb.keys[sKey].value);
        if(undefined === value)
        {
            value = def;
        }
        return  value;
    },

/*****************************************************************************
@FuncName: public, Frame.DBM.regNotify
@DateCreated: 2011-08-09
@Author: huangdongxiao 02807
@Description:  �����ݿ��б���һ����ֵ������ָ����key�Ѵ��ڣ����򸲸ǲ����������������������Ӳ�����
@Usage:
    // ģ��Aע��һ��sysname�ı�ʱ��֪ͨ����
    Frame.DBM.regNotify("system", "sysname", function(sName){return true;});

    // ģ��Bע��һ��sysname�ı�ʱ��֪ͨ�����ô����Ḳ��A�Ĵ���
    Frame.DBM.regNotify("system", "sysname", function(sName){return true;});
@ParaIn:
    * hDb, HANDLE, ���ݿ����������������ݿ�ʱ�ķ���ֵ
    * sKey, string, ��Ҫ�����ļ�ֵ����
    * notifyCB, Function, �¼�֪ͨ�ص���������ʽΪ function notifyCB(dataChanged)��
        ��ģ������ʹ�ûص������еĲ������Լ��Ĳ������ݲ��ṩ�ı�ǰ�����ݡ�
        ���ݵ����ͺ͸�ʽ�ɸ�ģ���Լ����ͣ�DBMģ�鲻ȥ���������ݡ�
        ������Ҫ����true���ڳ������ش���ʱ����false����ʱ����ֹͣ������֪ͨ
@Return: boolean, �ɹ�ʱ����true, ���򷵻�false
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    regNotify: function (hDb, sKey, notifyCB)
    {
        hDb.keys[sKey] = $.extern({notify:[]},hDb.keys[sKey]);
        
        hDb.keys[sKey].notify.push(notifyCB);
    },

/*****************************************************************************
@FuncName: public, Frame.DBM.deRegNotify
@DateCreated: 2011-08-09
@Author: huangdongxiao 02807
@Description:  ȡ��һ�����ݸı�֪ͨ��ע��
@Usage:
    // ģ��Aע��һ��sysname�ı�ʱ��֪ͨ����
    Frame.DBM.regNotify("system", "sysname", function(sName){return true;});

    // ȡ��ģ��Aע��ע����sysname�ı�ʱ��֪ͨ����
    Frame.DBM.deRegNotify("system", "sysname", function(sName){return true;});
@ParaIn:
    * hDb, HANDLE, ���ݿ����������������ݿ�ʱ�ķ���ֵ
    * sKey, string, ��Ҫ�����ļ�ֵ����
    * notifyCB, Function, �¼�֪ͨ�ص�������
@Return: boolean, �ɹ�ʱ����true, ���򷵻�false
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
    deRegNotify: function (hDb, sKey, notifyCB)
    {
        if(hDb.keys[sKey] && hDb.keys[sKey].notify)
        {
            hDb.keys[sKey].notify = $grep(hDb.keys[sKey].notify, function(item){return item!=notifyCB});
        }
    }

} //// end of Plot
$F.DBM = DBM;

})(Frame);

;(function($)
{
    var UTILNAME = "Base";
    var oBaseTimer = false;

    function indexOf(sKey,arry)
    {
        var n = -1;
        for(var i=0;i<arry.length;i++)
        {
            if(sKey === arry[i])
            {
                n = i;
                break;
            }
        }

        return n;
    }

    /*function addCommaNum(num)
    {
        var doAdd = function(str){

            if(!(typeof(str) === "string" || typeof(str) === "number") || Number(str) != Number(str))
            {
                return str;
            }
            
            str = String(str);
            var len = str.length;
            if(len <= 3)
            {
                return str;
            }

            var r = len%3;
            if(r > 0)
            {
                str = str.slice(0,r) + "," + str.slice(r,len).match(/\d{3}/g).join(",");
            } 
            else
            {
                str = str.slice(r,len).match(/\d{3}/g).join(",");
            }

            return str;
        };

        if($.isPlainObject(num))
        {
            for(key in num)
            {
                num[key] = doAdd(num[key]);
            }

        }
        else
        {
            num = doAdd(num);
        }

        return num;
    }*/

    function addComma(sNum,Stype/*Stype=rate,.memory*/,nStart,nEnd) {
        function doFormat(num,type,start,end){
            if(!(typeof(num) === "string"||typeof(num)==="number")||Number(num)!=Number(num)){
                return num;
            }
            var max,len,remain,unit,fixed;
            start=start||0;
            end = typeof end=="undefined"?3:end;
            switch(type){
                case "memory":
                    max = 1000;
                    unit=["B","KB","MB","GB"];
                    break;
                 case "rate":
                    max = 1024;
                    unit=["bps","Kbps","Mbps","Gbps"];
                    break;
                default:
                    max = Infinity;
                    unit=[""];
                    fixed = 0;
                    break;      
            }
            while(num >=max &&start < end){
                num = num/max;
                start++;
                fixed =1;
            }
            num = Number(num).toFixed(fixed).split(".");
            if(fixed){
                unit = "."+num[1]+unit[start];
            }else{
                unit = unit[start];
            }
            num = num[0];
            len = num.length;
            if(len<3){
                return num +unit;
            }
            remain = len % 3;
            if(remain > 0){
                num = num.slice(0,remain)+","+num.slice(remain,len).match(/\d{3}/g).join(",");

            }else{
                num = num.slice(remain,len).match(/\d{3}/g).join(",");
            }
             return num +unit;

        };

        if($.isPlainObject(sNum)){
            for(key in sNum){
                 sNum[key] = doFormat(sNum[key],Stype,nStart,nEnd);
            }
        }else{
            sNum = doFormat(sNum,Stype,nStart,nEnd);
        }
        return sNum;
    }

    function loadMenu(sMenu)
    {
        return Frame.NewMenu.loadPage(sMenu);
    }

    function refreshCurPage()
    {
    	// return Frame.NewMenu.refreshPage();
        if($(".modal-scrollable").length)// whether has dlg
        {
            oBaseTimer && clearTimeout(oBaseTimer);
            oBaseTimer = setTimeout(refreshCurPage,500);
        }
        else
        {
            return Frame.NewMenu.refreshPage();
        }
    }

    function getCurMenuId()
    {
        return Frame.NewMenu.getCurMenuId();
    }

    function openRSidePanel(
        sUrl /*"Acl.Add_basicrule"*/, 
        oPara /*the paras of new page*/, 
        pfInit /*ignore if no sUrl*/)
    {
        var oPanel = Frame.getHelpPanel({data: oPara});
        if (sUrl)
        {
            oPanel.open().load(sUrl, pfInit);
        }
        else
        {
            oPanel.open();
        }
        return;
    }

    function closeRSidePanel()
    {
        Frame.getHelpPanel().close();
    }

    function isEmptyObj(oObj)
    {
        var bEmpty = true;
        for (var i in oObj)
        {
            bEmpty = false;
            break;
        }
        return bEmpty;
    }

    function createAttrs(oAttr)
    {
        var aAttr = [];
        oAttr = oAttr||{};
        for(var key in oAttr)
        {
            aAttr.push(key+'="'+oAttr[key]+'"');
        }
        return aAttr.join(" ");
    }
    
    function createHtml(sTagName, sText, oAttr)
    {
        var sAttr = createAttrs(oAttr);
        return Frame.Util.sprintf("<%s %s>%s</%s>", sTagName, sAttr, sText, sTagName);
    }

    function updateHtml(jScope, oData)
    {
        $.each(oData, function (sKey, sValue)
            {
                sKey = sKey.replace(/\./g, "\\.");
                sValue = (null == sValue) ? "" : sValue+"";
                $("#"+sKey, jScope).removeClass("loading-small").html(sValue);
            });
        return;
    }

    function disableLink (bEnable, jLink)
    {
        if (bEnable)
        {
            jLink.removeAttr("state")
                .removeClass ("ui-state-disabled")
                .attr("href", jLink.attr("_href"))
                .removeAttr ("_href");
        }
        else
        {
            jLink.attr("state", "disabled")
                .attr("_href", jLink.attr("href"))
                .removeAttr("href").
                addClass("ui-state-disabled");
        }
    }

/* 
Paras: sPort1/sPort2, Port name, such as Ethet1/0/1, Vlan-interface1, Loopback1, Ethnet1/0/1.2
*/
function  comparePort(sPort1, sPort2)
{
    var getIfType = function (sPort)
    {
        return sPort.replace(/[0-9\/]*/g, "");
    }

    var getIfNumber = function (sPort)
    {
        return sPort.replace(/[a-zA-Z]*/g, "").split('/');
    }

    // 容错处理
    sPort1 = sPort1 || "";
    sPort2 = sPort2 || "";
    if (sPort2 == sPort1)
    {
        return 0;
    }

    var sIftype1 = getIfType(sPort1);
    var sIftype2 = getIfType(sPort2);
    if(sIftype1<sIftype2)
    {
            return -1;
    }
    else if(sIftype1>sIftype2)
    {
            return 1;
    }

    var aIfnumber1 = getIfNumber(sPort1);
    var aIfnumber2 = getIfNumber(sPort2);
    for(var i=0; i<aIfnumber1.length; i++)
    {
        if(aIfnumber1[i]-aIfnumber2[i] != 0)
        {
             return aIfnumber1[i]-aIfnumber2[i];
        }
    }   
    return 0;
}

function save()
{
    openDlg("Config.Save",{},{className:"modal-default"});
}

function encode (a)
{
    var s = a;
    if (a && "string" == typeof(a))
    {
        s = a.replace(/&/g,"&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&#34;").replace(/'/g, "&#39;");
    }
    return s;
}

function dumpObj (obj, sFormat)
{
    var aHtml = [];
    var Maker = {
        "table": 
        {
            start: function ()
            {
                return "<table>";
            },
            append: function (key, value)
            {
                return "<tr><td>" + key + "</td><td>" + value + "</td></tr>";
            },
            end: function ()
            {
                return "</table>";
            }
        },
        "list":
        {
            start: function ()
            {
                return "<ul>";
            },
            append: function (key, value)
            {
                return "<li>" + key + ": " + value + "</li>";
            },
            end: function ()
            {
                return "</ul>";
            }
        }
    };

    var pfMaker = Maker[sFormat] || Maker["table"];

    obj = obj || {};
    aHtml.push (pfMaker.start ());
    for (var key in obj)
    {
        aHtml.push (pfMaker.append (key, obj[key]));
    }
    aHtml.push (pfMaker.end ());

    return aHtml.join ('');
}
/**
sUrl: String, the new page for loading. if it is null, only showing
**/
    function openDlg(sUrl, oPagePara, oDlgPara)
    {
        var jDlg;
        var sDlgId = "dlg_cnt_global";

        oDlgPara = oDlgPara||{};

        if(oDlgPara.scope)
        {
            if ("string" == typeof(oDlgPara.scope))
            {
                sDlgId = oDlgPara.scope;
            }
            else
            {
                jDlg = oDlgPara.scope;
            }
        }

        if (!jDlg)
        {
            var hTimer;
            jDlg = $("#"+sDlgId);
            if(jDlg.length > 0)
            {
               if(jDlg.hasClass('modal-overflow'))
               {
                   jDlg.modal('hide');
               }else
               {
                   hTimer = jDlg.data("timer");
                   clearTimeout(hTimer);
                   jDlg.remove();
               }

            }
            jDlg = $("<div></div>").attr("id", sDlgId).appendTo($("body"));
            jDlg.bind("hide", function (){
                hTimer = setTimeout(function(){jDlg.remove();}, 1500);
                jDlg.data("timer", hTimer);
            });
        }

        var sClass = "modal fade " + (oDlgPara.className || "");
        jDlg.removeClass().addClass(sClass);

        if(sUrl)
        {
            Utils.Pages.loadModule(sUrl, oPagePara , jDlg, function()
            {
                jDlg.modal();
            });
        }
        else
        {
            if (oDlgPara.html)
            {
                jDlg.html (oDlgPara.html);
            }
            jDlg.modal();
        }

        return {close: function(){jDlg.modal("hide");}}
    }

    function getHash(aData, sKey)
    {
        var oHash = {};

        $.each(aData,function(index,oItem)
        {
            var sHashKey = oItem[sKey];
            if (!oHash[sHashKey])
            {
                oHash[sHashKey] = [];
            }

            oHash[sHashKey].push(oItem);
        });

        return oHash;
    }

    function cloneObj(oSrc)
    {
        var oDes = {};
        $.each(oSrc, function (index, oItem) {oDes[index] = oSrc[index];return;});
        return oDes;
    }

/*****************************************************************************
@FuncName: public,Utils.Base.getRcString
@DateCreated: 2011-10-08
@Author: huangdongxiao 02807
@Description: Get resource string, which defined in HTML file. We can't use the STRING in JS file, 
    because the JS file must be compatiable all the language. So, the const STRING must be defined
    in HTML file, and then used in JS file. The rule for defination of STRING is as below:
    <li>The common STRING is defined in public. such as Add, Delete and so on
    <li>The personal STRING, such as "The user name must be started with character"
    <p>The STRING is as a property defined in a DIV element, and the DIV must have a class "rc-define", 
    and the DIV must have a "id" property, it named MODULE+"_"+FUNCTION+"_rc"
@Usage:
// HTML
<div id="syslog_summary_rc" class="rc-define"
    my_note1="This is note 1 string"
    my_note2="This is note 2 string"
    confirm="Confirm to shutdown all the interface?"
    ></div>

// JS
var sMyNote1 = Frame.Util.getRcString("syslog_summary_rc", "my_note1");
var sConfirm = Frame.Util.getRcString("syslog_summary_rc", "confirm");

// You can write a function for reduce the code in a JS file
function getRcText(sRcName)
{
    return Frame.Util.getRcString("syslog_summary_rc", sRcName);
}

// Submit
function _onSubmit()
{
    if("" == $("#user_name").val())
    {
        Frame.Msg.alert(getRcText("my_note1"));
        return false;
    }
}
@ParaIn:
    * sRcId, string, The "id" property of DIV
    * sRcName, string, The resource id.
@Return: String
    <li>The string, if the resource id is exist
    <li>else, return empty string("")
@Caution:
@Modification:
    * yyyy-mm-dd: Author, add or modify something
*****************************************************************************/
function getRcString(sRcId, sRcName)
{
    return $("#"+sRcId).attr(sRcName) || "";
}

function toText(sHtml)
{
    return sHtml.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/[\t\r\n]/g," ").replace(/  /g,"&nbsp; ");
}

function showError(msg, jScope)
{
    var sErrMsg = ($.isArray(msg)) ? msg.join("") : msg;
    var jPage = jScope ? jScope.closest(".page") : jScope;
    jPage = jPage || [];
    var jError = $(".form-actions:visible", jPage);
    if (("" != sErrMsg) && (Utils.Msg) && (Utils.Msg.error) )
    {
    	Utils.Msg.error(sErrMsg);       
    }
    else if ((jError.length > 0))
    {
        $(".error-info", jError).remove();
        if ("" != sErrMsg)
        {
            $("<div class='error-info error'></div>")
                .html (sErrMsg)
                .prependTo (jError)
                .show ();
        }
    }
}

function getCheckGrpVal(sGroupName, jScope)
{
    return $(":radio[name='"+sGroupName+"'][checked]", jScope).val();
}

function redirect(oParas, sUrl/*=null*/)
{
    // if no sUrl, goto current page
    if(oParas)
    {
        Utils.Base.activeTab = oParas.sTab;
        delete  oParas.sTab;
    }
    window.location = Utils.Base.createUrl(oParas, sUrl);
}

function isObjEqual(obj1, obj2, aIndex)
{
    var nIndexCount = aIndex.length;

    if(obj1 == obj2) return "eq";
    if(typeof(obj1) != typeof(obj2)) return "neq";
    if(!$.isPlainObject(obj1)) return "neq";

    // check index
    for(var i=0; i<nIndexCount; i++)
    {
        if(obj1[aIndex[i]] != obj2[aIndex[i]])
        {
            return "neq";
        }
    }

    // check all fields
    for(var key in obj2)
    {
        // ignore the private attributes
        if('_' == key[0])
        {
            continue;
        }

        if(obj1[key] !== obj2[key])
        {
            return (nIndexCount>0) ? "mdf" : "neq";
        }
    }

    return "eq";
}
function getChanged(aData1, aData2, aIndex)
{
    var aAdded=[], aRemoved=[], aModified=[];
    var aFlag2 = [];
    var found;
    var i, j, ii, jj;

    aData1 = aData1 || [];
    aData2 = aData2 || [];
    aIndex = aIndex||[];

    ii=aData1.length, jj=aData2.length;

    for(i=0; i<ii; i++)
    {
        found = "neq";
        for(j=0; j<jj; j++)
        {
            if(!aFlag2[j])
            {
                found = isObjEqual(aData1[i], aData2[j], aIndex);
                if("neq" != found)
                {
                    aFlag2[j] = found;
                    break;
                }
            }
        }
        if("neq" === found)
        {
            aRemoved.push(aData1[i]);
        }
    }

    for(var j=0,jj=aData2.length; j<jj; j++)
    {
        if("mdf" == aFlag2[j])
        {
            aModified.push(aData2[j]);
        }
        else if(!aFlag2[j])
        {
            aAdded.push(aData2[j]);
        }
    }

    return {added: aAdded, removed: aRemoved, modified: aModified};
}

function resetForm(oForm)
{
    $("input[type=text],input[type=password],select",oForm).each(function() {
        $(this).val("");
        Utils.Widget.setError($(this),"");
    });
}
var MyUrl = 
{
    _spchar: ['&',   '@',  '[',   ']',   '<',   '>',  '"',   ' ',   '=',   'C'  ],
    _newstr: ["Cam", "Ca", "Cfl", "Cfr", "Cjl", "Cr", "Cqu", "Csp", "Ceq", "Ccc"],
    escape: function (str)
    {
        if (typeof (str) == "number")
        {
            return str;
        }

        var aPattern =MyUrl._spchar;
        var aSwitch = MyUrl._newstr;
        for(var i=aPattern.length-1; i>=0; i--)
        {
            var sPattern = aPattern[i].replace('[', "\\[").replace(']', "\\]");
            var reg = new RegExp(sPattern, "g");
            str = str.replace(reg, aSwitch[i]);
        }
        return str;
    }
    ,unescape: function(val)
    {
        var aPattern =MyUrl._newstr;
        var aSwitch = MyUrl._spchar;
        for(var i=0; i<aPattern.length; i++)
        {
            var reg = new RegExp(aPattern[i], "g");
            val = val.replace(reg, aSwitch[i]);
        }
        return val;
    }
    ,create: function (oParas, sPageId)
    {
        var sSearch, aParas = [];

        oParas = oParas||{};
        for(var key in oParas)
        {
            if (undefined !== oParas[key])
            {
                aParas.push(key + "=" + MyUrl.escape(oParas[key]));
            }
        }

        sPageId = sPageId || Frame.NewMenu.getCurMenuId();
        sSearch = (aParas.length > 0) ? ("?"+aParas.join('&')) : "";
        return "#" + sPageId + sSearch;
    }
    ,parse: function (sParas)
    {
        var oParas = {};

        if (!sParas)
        {
            sParas = window.location.hash;
        }

        if (sParas.charAt(0) == '#')
        {
            sParas = sParas.substring(1);
        }

        var aTemp = sParas.split("?");
        if(1 == aTemp.length)
        {
            sParas = aTemp [0];
            if (-1 == sParas.indexOf('='))
            {
                return oParas;
            }
        }
        else
        {
            // remove the first char "?"
            sParas = aTemp[1];
        }

        var aPara = sParas.split('&');
        for(var i=0; i<aPara.length; i++)
        {
            var aTemp = aPara[i].split('=');
            var sKey = aTemp[0];
            var sVal = aTemp[1];
            oParas[sKey] = MyUrl.unescape(sVal);
        }

        return oParas;
    }
}

var oBase = {
    activeTab : false,
	loadMenu : loadMenu,
	refreshCurPage : refreshCurPage,
    getCurMenuId : getCurMenuId,
    openRSidePanel : openRSidePanel,
    closeRSidePanel: closeRSidePanel,
    getCheckGrpVal: getCheckGrpVal,
    isEmptyObj : isEmptyObj,
    isSupport: function(sMenuId){return Frame.NewMenu.isSupport(sMenuId)},
    isSupportPanel: function(){return Frame.arrSlotInfo ? true : false},

    createHtml: createHtml,
    updateHtml : updateHtml,
    updateSysname: function(sName){Frame.set("sysname", sName)},
    disableLink: disableLink,
    save: save,

    // string
    sprintf: Frame.Util.sprintf,
    encode: encode,
    dumpObj: dumpObj,
    comparePort: comparePort,

    openDlg: openDlg,
    getHash: getHash,
    cloneObj : cloneObj,
    getRcString : getRcString,
    toText : toText,
    showError: showError,
    lockScreen: Frame.MyScreen.lock,
    unlockScreen: Frame.MyScreen.unlock,

    redirect: redirect,
    getChanged: getChanged,
    createUrl : MyUrl.create,
    parseUrlPara: MyUrl.parse,
   // addCommaNum: addCommaNum,
    addComma:addComma,
    indexOf : indexOf,
    resetForm : resetForm
};

Utils.Base = oBase;
})(jQuery);
/* beibei.js */
//右键菜单
var isindex = true;
var aiState = "";
var visitor = "xxx";
var sayTimerHandler = undefined;
var moveTimerHandler = 0;
var aiAddr = "http://www.tuling123.com/openapi/api";
var aiKey = "828507344169c6ff7fbdad2abbcb00a9";
jQuery(document).ready(function ($) {
    var forbidenSelectFlag = false;
    var isEmotionPlaying = false;
    var _move = false;
    var ismove = false; //移动标记
    var _x, _y; //鼠标离控件左上角的相对位置
    var xiaobeiAIIsActive = false;
    var socket={};
    var f;

    var emotionArray = ["like","happy","sad","alone","fight","cool","jeer","love","hug","miss","surprise","sick","tired","enjoy","awkward","scared","speechless","crazy","calm","hungry"];

    $(document).on("click","#online_service",function(){
        if(xiaobeiAIIsActive){
            return;
        }
        initAI();
    })
    $(document).on("click","#xiaobeiai_close",function(){
        finiAI();
    })

    $(document).on("mouseover", "#xiaobeiai", function (){
        $("#xiaobeiai_close").show();
    })
    $(document).on("mouseleave", "#xiaobeiai", function (){
        $("#xiaobeiai_close").hide();
    })

    $(document).on("click", "#aiQuestionLink", function (){
        aiState = "writing";
        $("#message").hide();
        $("#aiQuertionInput").show();
        $("#aiQuertionInput").focus();
    })

    function interactWithAI(msg){
        var userName = $("#username").text();
        aiState = "waitting";
        $("#aiQuertionInput").hide();
        $("#aiQuertionInput").val("");
        console.log(msg);
        socket.emit("querybeibei",{url:aiAddr,key:aiKey,userid:userName,info:escape(msg)},function(data){
            console.log(JSON.stringify(data));
            if(data["result"]=="success"){
                var m = JSON.parse(data["body"]).text;
                showMessage(m, 20000);
                aiState = "";
                $("#beibei").focus();
                resetBeibeiActiveTimer();
                beibeiEmotionPlay(data["text"]);
            }

        })
        //$.ajax({
        //    url: aiAddr,
        //    method:"post",
        //    data: {
        //        key:aiKey,
        //        info:msg,
        //        userid:escape(userName)
        //    },
        //    success: function( data ) {
        //        showMessage(data["text"], 50000);
        //        aiState = "";
        //        $("#beibei").focus();
        //        resetBeibeiActiveTimer();
        //        beibeiEmotionPlay(data["text"]);
        //    }
        //});
    }

    $(document).on("keydown", "#aiQuertionInput", function (event){
        /*enter*/
        //if(window.event.keyCode == 13){
        if(event.keyCode==13){
            var msg = $("#aiQuertionInput").val().trim();
            if(msg == ""){
                aiState = "";
                $("#aiQuertionInput").hide();
                $("#beibei").focus();
            }else{
                interactWithAI(msg);
            }
        }
        /*ESC*/
        if(event.keyCode == 27){
            aiState = "";
            $("#aiQuertionInput").hide();
        }
    });
    $(document).on("selectstart","body",function(){
        if(forbidenSelectFlag){
            return false;
        }
    });
    $(document).on("blur", "#aiQuertionInput",function(){
        $("#aiQuertionInput").hide();
        aiState = "";

    })

    //$(document).on("mouseenter", "#beibei", function(){
    //    if(!ismove){
    //        //beibeiEmotionPlayForRandom();
    //        //showMessage("我隐身了你看不见我。", 4000);
    //        $("#beibei").fadeTo("300", 0.2);
    //
    //        resetBeibeiActiveTimer();
    //    }
    //})
    //$(document).on("mouseleave", "#beibei", function(){
    //    if(!ismove){
    //        //beibeiEmotionPlayForRandom();
    //        //showMessage("我又出来了。", 4000);
    //        $("#beibei").fadeTo("300", 1);
    //
    //        resetBeibeiActiveTimer();
    //    }
    //})

    $(document).on("click", "#beibei", function () {
        if (!ismove && aiState == ""){
            aiState = "writing";
            $("#message").hide();
            $("#aiQuertionInput").show();
            $("#aiQuertionInput").focus();
        }else{
            ismove = false;
            forbidenSelectFlag = false;
        }
    })

    function beibeiEmotionPlayForMsg(msg){
        function beibeiFindEmotion(msg, cback){
            var i = Math.floor(Math.random() * emotionArray.length);
            cback(emotionArray[i]);
        }
       beibeiFindEmotion(msg, beibeiEmotionPlay);
    }
    function beibeiEmotionPlayForInit(){
        beibeiEmotionPlay("like");
    }

    function beibeiEmotionPlayForRandom(){
       var i = Math.floor(Math.random() * emotionArray.length);
        beibeiEmotionPlay(emotionArray[i]);
    }

    function beibeiEmotionPlay(emotionName){
        //var path = "../beibei/img/";
        //var extend = ".png";
        //var emotionPath = path + emotionName +extend;
        //if(!isEmotionPlaying){
        //    var timer = 0;
        //    var emotion  = new Image;
        //    var len = 0;
        //    var t = 0;
        //    emotion.src = emotionPath;
        //    emotion.onload = function(){
        //        len = parseInt(emotion.width / 148);
        //        isEmotionPlaying = true;
        //        timer = setInterval(function(){
        //            $("#beibei").css("background",  "url(" + emotionPath + ") no-repeat " + 148 * -t + "px 0");
        //            t++;
        //            if(t > len){
        //                $("#beibei").css("background","url(../beibei/img/small.png) no-repeat");
        //                isEmotionPlaying = false;
        //                clearInterval(timer);
        //            }
        //        },82);
        //    }
        //}
    }

    $(document).on("keydown","#beibei",function(event){
        /*ESC*/
        if(window.event.keyCode == 27){
            aiState = "";
            $("#aiQuertionInput").hide();
        }else{
            aiState = "writing";
            $("#aiQuertionInput").val("");
            $("#message").hide();
            $("#message").css("display","none");
            $("#aiQuertionInput").show();
            $("#aiQuertionInput").focus();
            event.stopPropagation();
            return false;
        }
    })

    //显示消息函数
    function showMessage(a, b) {
        if (b == null) b = 10000;
        jQuery("#message").hide().stop();
        jQuery("#message").html(a);
        //jQuery("#message").fadeIn();
        $("#message").css("display","inline-block");
        jQuery("#message").fadeTo("1", 1);
        jQuery("#message").fadeOut(b);
        //jQuery("#message").stop();
        //jQuery("#message").html(a);
        //jQuery("#message").fadeIn();
        //jQuery("#message").fadeOut(b);
    };

    ////鼠标在消息上时
    //$("#message").hover(function () {
    //    if(aiState == ""){
    //        $("#message").stop();
    //        $("#message").fadeTo("100", 1);
    //    }
    // });s


    ////鼠标在上方时
    //$("#beibei").mouseover(function () {
    //    if(aiState == ""){
    //        $("#beibei").fadeTo("300", 0.1);
    //        msgs = ["我隐身了，你看不到我", "我会隐身哦！嘿嘿！", "别动手动脚的，把手拿开！", "把手拿开我才出来！","你看不见我"];
    //        var i = Math.floor(Math.random() * msgs.length);
    //        showMessage(msgs[i]);
    //    }
    //});
    //$("#beibei").mouseout(function () {
    //    $("#beibei").fadeTo("300", 1)
    //});

    /*初始化*/
    function initAI(){
        if($.cookie("JSESSIONID") == undefined || $.cookie("JSESSIONID") ==""){
            alert("ERROR_SESSIONID: "+ $.cookie("JSESSIONID"));
            return;
        }
        xiaobeiAIIsActive = true;
        forbidenSelectFlag = false;
        isEmotionPlaying = false;
        _move = false;
        ismove = false; //移动标记
        f = $("#xiaobeiai").offset().top;
        visitor = $("#username").text();
        if (isindex) { //如果是主页
            var now = (new Date()).getHours();
            if (now > 0 && now <= 6) {
                showMessage(visitor + ' 你是夜猫子呀？还不睡觉？', 6000);
            } else if (now > 6 && now <= 11) {
                showMessage(visitor + ' 认识你好开心哦！', 6000);
            } else if (now > 11 && now <= 14) {
                showMessage(visitor + ' 中午了，吃饭了么？不要饿着了！', 6000);
            } else if (now > 14 && now <= 18) {
                showMessage(visitor + ' 下午好，很高兴我们又见面了。', 6000);
            } else {
                showMessage(visitor + ' 你好我叫贝贝，快来逗我玩吧！', 6000);
            }
        }

        $("#xiaobeiai").animate(
            {
                top: $("#xiaobeiai").offset().top+300,
                left: document.body.offsetWidth-160
            },
            {
                queue: false,
                duration: 1000,
                complete:beibeiEmotionPlayForInit
            }
        );
        $("#beibei").focus();

        sayTimerHandler = setInterval(aiSay, 35000);

        socket = io.connect("https://lvzhouchat.h3c.com",{secure:true});
        //socket = io.connect("https://localChatTest.h3c.com:3011",{secure:true});
        socket.on('connect', function(){
            console.log("beibei_connect");

            socket.emit('authentication', {chatid:$.cookie("JSESSIONID"),query:true}, function(){
            });
            //socket.emit('authentication', {user:"liuchao",query:true}, function(){
            //});
        })

        socket.on('authenticated', function(info){
            console.log("beibei_authenticated_" + info);
        })


    }
    function finiAI(){
        xiaobeiAIIsActive = false;
        if(sayTimerHandler){
            clearInterval(sayTimerHandler);
            sayTimerHandler = undefined;
        }
        $("#xiaobeiai_close").css("display","none");

        //$("#xiaobeiai").css({top:"-200px",left:"160px"});
        $("#xiaobeiai").animate(
            {
                top: -200,
                left: 160
            },
            {
                queue: false,
                duration: 1000,
            }
        );
        if(socket!={}){
            socket.close();
            socket = {};
        }
    }


    function aiSay(){
        if(aiState == "" && !ismove){
            var msgs = [{msg:"陪我聊天吧！",action:"alone"},
                        {msg:"好无聊哦，你都不陪我玩！",action:"alone"},
                        {msg:"我可爱吧！嘻嘻!",action:"like"},
                        {msg:"主人我好喜欢你哦！",action:"love"},
                        {msg:"你看我裤不裤？",action:"cool"},
                        {msg:"要抱抱！！！",action:"hug"},
                        {msg:"好开心哦，又呲成长快乐了.",action:"happy"},
                        {msg:"阀开心! 你都不陪我聊天",action:"sad"}];
            var i = Math.floor(Math.random() * msgs.length);
            showMessage(msgs[i]["msg"], 7000);
            beibeiEmotionPlay(msgs[i]["action"]);
        }
    }
    function resetBeibeiActiveTimer(){
        if(sayTimerHandler){
            clearInterval(sayTimerHandler);
            sayTimerHandler = setInterval(aiSay, 35000);
        }
    }

    //
    ////无聊动动
    //moveTimerHandler =setInterval(function () {
    //    if(aiState == ""){
    //        var msgs = ["乾坤大挪移！", "我飘过来了！~", "我飘过去了", "我得意地飘！~飘！~"];
    //        var i = Math.floor(Math.random() * msgs.length);
    //        s = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6,0.7,0.75,-0.1, -0.2, -0.3, -0.4, -0.5, -0.6,-0.7,-0.75];
    //        var i1 = Math.floor(Math.random() * s.length);
    //        var i2 = Math.floor(Math.random() * s.length);
    //        $("#xiaobeiai").animate({
    //            left: document.body.offsetWidth/2*(1+s[i1]),
    //            top:  document.body.offsetHeight/2*(1+s[i1])
    //        },
    //        {
    //            duration: 2000,
    //            complete: showMessage(msgs[i])
    //        });
    //    }
    //
    //}, 70000);


    //滚动条移动
    $(window).scroll(function () {
        $("#xiaobeiai").animate({
            top: $(window).scrollTop() + f +300
        },
        {
            queue: false,
            duration: 1000
        });
    });

    $("#beibei").mousedown(function (e) {
        forbidenSelectFlag = true;
        _move = true;
        _x = e.pageX - parseInt($("#xiaobeiai").css("left"));
        _y = e.pageY - parseInt($("#xiaobeiai").css("top"));
     });
    $(document).mousemove(function (e) {
        if (_move) {
            var x = e.pageX - _x;
            var y = e.pageY - _y;
            var wx = $(window).width() - $('#xiaobeiai').width();
            var dy = $(document).height() - $('#xiaobeiai').height();
            if(x >= 0 && x <= wx && y > 0 && y <= dy) {
                $("#xiaobeiai").css({
                    top: y,
                    left: x
                }); //控件新位置
            ismove = true;
            }
        }
    }).mouseup(function () {
        _move = false;
        forbidenSelectFlag = false;
    });

});


